{"title":"List of spells/parse-spl-data","url":"http://crawl.chaosforge.org/List_of_spells/parse-spl-data","type":"raw","data":"{{delete|No longer used}}\n<pre>\n<nowiki>\n#! /usr/bin/perl -w\n# parse-spl-data, by http://crawl.chaosforge.org/index.php?title=User:Neil\n# Copyright (C) 2011.  No rights reserved.\n#\n# You may use, distribute, modify, study, fold, spindle, or mutilate this\n# software as you see fit, but know that there is NO WARRANTY, EXPRESS\n# OR IMPLIED (to the extent permitted by law).\n#\n# The latest version of this program may be found at:\n#  http://crawl.chaosforge.org/List_of_spells/parse-spl-data\n\nuse strict;\nuse Getopt::Long qw(:config gnu_getopt);\n\nour ($PROGNAME, $DATE, $CRAWL_VERSION);\nour $VERSION = \"0.1.0\";\n\n\nsub crawl_version {\n        my ($indir) = @_;\n\t# Look for util/release_ver first\n\tif (open VERSION, \"<\", \"${indir}util/release_ver\") {\n\t\tmy $ver = <VERSION>;\n\t\tchomp $ver;\n\t\tclose VERSION;\n\t\treturn $ver;\n\t}\n\t# TODO: maybe try running git\n\treturn \"<unknown>\";\n}\n\n# Translate a range into something friendlier for display.  -1 (no range)\n# becomes the empty string, while \"LOS_RADIUS\" becomes just LOS.\n# TORNADO_RADIUS becomes 5 (its value), but maybe we should use \"Tornado\"\n# instead.\nsub xlate_range {\n\tmy $range = shift;\n\treturn \"LOS\" if $range eq \"LOS_RADIUS\";\n\treturn 6 if $range eq \"TORNADO_RADIUS\";\n\treturn \"\" if $range eq \"-1\";\n\treturn $range;\n}\n\n# Wiki-format a list of spell schools, linking to the corresponding\n# magic skill.\nsub format_schools {\n\tjoin \"/\", map {\n\t\tmy $school = ucfirst(lc $_);\n\n\t\t# Convert school names to skill names for linking\n\t\tmy $skill = $school;\n\t\tif ($school =~ /^(Poison|Air|Fire|Ice|Earth)$/) {\n\t\t\t$skill = \"$school Magic\";\n\t\t} elsif ($school !~ /[ys]$/) {\n\t\t\t# \"Necromancy\" isn't pluralised as a skill,\n\t\t\t# and \"Hexes\" and \"Charms\" are already\n\t\t\t# pluralized as a magic school.  The others\n\t\t\t# are singular as a school, plural as a skill.\n\t\t\t$skill = \"${school}s\";\n\t\t}\n\n\t\t$skill eq $school ? \"[[$school]]\" : \"[[$skill|$school]]\";\n\t} @_;\n}\n\nsub ucfirst_array {\n    my $items = join \",\", map {\n        my $name = ucfirst(lc $_);\n        \"\\\"$name\\\"\";\n    } @_;\n    \"{ $items }\";\n}\n\n# Add a spell if it exists\nsub maybe_add_spell {\n\tmy ($spell, $by_id, $by_key, $sortkey) = @_;\n\treturn undef unless $spell->{name};\n\n\t# Ignore spells that do not occur in any book\n\treturn \"\" unless scalar @{$spell->{books}};\n\t# ..and NO_SPELL, which \"occurs\" in books but not really.\n\treturn \"\" if $spell->{id} eq \"NO_SPELL\";\n\n\t# Sanity checks: abort if we encounter one of these, as it means\n\t# something funny is up with our book-parsing.\n\n\t# Spells that belong to certain monster-only schools.\n\tfor my $school (@{$spell->{schools}}) {\n\t\tdie \"SPTYP_NONE for $spell->{name}\" if $school eq \"NONE\";\n\t}\n\t# Spells that don't belong to a school at all, even SPTYP_NONE.\n\tdie \"No school for $spell->{name}\" unless scalar @{$spell->{schools}};\n\n\t# Monster and testing spells.\n\tfor my $flag (@{$spell->{flags}}) {\n\t\tdie \"Monster spell $spell->{name}\" if $flag eq \"MONSTER\";\n\t\tdie \"Testing spell $spell->{name}\" if $flag eq \"TESTING\";\n\t}\n\n\t# It's worth keeping.\n\t$by_id->{$spell->{id}} = $spell;\n        if ($sortkey eq \"alpha\") {\n                $by_key->{$spell->{name}} = $spell;\n        } elsif ($sortkey eq \"letter\") {\n                my $let = uc(substr $spell->{name}, 0, 1);\n                push @{$by_key->{$let}}, $spell;\n        } elsif ($sortkey eq \"level\") {\n                push @{$by_key->{$spell->{level}}}, $spell;\n        } elsif ($sortkey eq \"school\") {\n                for my $school (@{$spell->{schools}}) {\n                        push @{$by_key->{$school}}, $spell;\n                }\n        } elsif ($sortkey eq \"flag\") {\n                for my $flag (@{$spell->{flags}}) {\n                        push @{$by_key->{$flag}}, $spell;\n                }\n        }\n\treturn 1;\n}\n\n# Sorting functions\nsub sort_by_name {\n\t$a->{name} cmp $b->{name}\n}\n\nsub sort_by_level {\n\t$a->{level} <=> $b->{level} or sort_by_name\n}\n\nsub sort_by_school {\n\t# A Schwartzian transform would be more efficient, but we have\n\t# few enough spells that it's not necessary.\n\tjoin(\"/\", @{$a->{schools}}) cmp join(\"/\", @{$b->{schools}})\n\t\tor sort_by_name\n}\n\n### MAIN\n\n\nsub main {\n        # Input directory.\n        my $indir = \"./\";\n\n        # Map from letter, school, flag, book name, or level to list of spells.\n        my %by_key = ();\n        my %by_letter = ();\n        my %by_school = ();\n        my %by_flag = ();\n        my %by_book = ();\n        my %by_level = ();\n\n        # Map from ID or name to spell\n        my %by_id = ();\n        my %by_name = ();\n\n        # Map from spell name to list of book names.\n        my %book_spells = ();\n\n\n\n        my $sortkey = \"alpha\";\n        my $sortfn = \\&sort_by_name;\n        my $module = \"default\";\n\n        GetOptions(\n                   \"a|alphabetic\" => sub { $sortkey = \"letter\"; $sortfn = \\&sort_by_name; },\n                   \"b|book\" => sub { $sortkey = \"book\"; $sortfn = undef; },\n                   \"f|flag\" => sub { $sortkey = \"flag\"; $sortfn = \\&sort_by_level; },\n                   \"l|level\" => sub { $sortkey = \"level\"; $sortfn = \\&sort_by_school; },\n                   \"s|school\" => sub { $sortkey = \"school\"; $sortfn = \\&sort_by_level; },\n                   \"m|module-book\" => sub { $module = \"book\"; $sortkey = \"book\" ; $sortfn = undef; },\n                   \"k|module-spell\" => sub { $module = \"spell\"; $sortkey = \"letter\"; $sortfn = \\&sort_by_name; },\n                   \"h|help\" => sub {\n                           print <<\"EOF\";\nUsage: $0 [options] [directory]\n\nProduce a wiki table of DCSS spells.  The specified directory should contain\nspl-data.h an book-data.h.  If omitted, the current directory is used.\n\nOptions include:\n  -a, --alphabetic    Arrange alphabetically (default).\n  -b, --book          Arrange by book, then level.\n  -f, --flag          Arrange by flag, then level.\n  -k, --module-spell  Generate a Lua table of spells.\n  -l, --level         Arrange by level, then schools.\n  -m, --module-book   Generate a Lua table of spellbooks.\n  -s, --school        Arrange by school, then level.\n  -h, --help          Display this help.\n\nSpells of the same schools and level are sorted by name.  With the --book,\n--school, and --flag option, spells may appear multiple times.\nEOF\n                           exit 0;\n                   },\n                  );\n\n        if (@ARGV) {\n                $indir = shift @ARGV;\n                $indir .= \"/\" unless $indir eq \"\" or $indir =~ m!/$!;\n        }\n\n        $DATE = gmtime;\n        $CRAWL_VERSION = crawl_version($indir);\n        ($PROGNAME = $0) =~ s!.*/!!;\n\n        parse_book_data($indir, \\%book_spells, \\%by_book);\n        parse_spl_data($indir, \\%book_spells, \\%by_id, \\%by_key, $sortkey);\n        for my $k (keys %by_book) {\n                # Convert the list of spell ids to a list of spells, but\n                # remove those that aren't in %by_id because maybe_add_spell\n                # skipped them.\n                my @spells =  map { $by_id{$_} || () } @{$by_book{$k}};\n                if (@spells) {\n                        $by_book{$k} = \\@spells;\n                } else {\n                        # Remove the book if it has no spells.\n                        delete $by_book{$k};\n                }\n        }\n\n        # Print data\n        if ($module eq \"default\") {\n                if ($sortkey eq \"book\") {\n                        module_default($sortkey, $sortfn, \\%by_book);\n                } else {\n                        module_default($sortkey, $sortfn, \\%by_key);\n                }\n        } elsif ($module eq \"book\") {\n                module_book(\\%by_book);\n        } elsif ($module eq \"spell\") {\n                module_spell($sortfn, \\%by_key);\n        }\n}\n\nsub parse_book_data {\n        my ($indir, $book_spells, $by_book) = @_;\n        # Name of current book.\n        my $book = \"bug\" ;\n        open BOOKS, \"${indir}book-data.h\"\n          or die \"could not open ${indir}book-data.h: $!\";\n        while (<BOOKS>) {\n                # Skip conditional sections.  Really we need to look at\n                # the condition, but that requires the C preprocessor and\n                # I'd rather avoid that.\n\n                #next if /^#if/../^#endif/;\n                next if /^#if TAG_MAJOR_VERSION == 34/../^#endif/;\n\n                # Kind of hackish --- quit at the first rod\n                last if m!// Rod!;\n\n                if (m!^{\\s*// (.*)!) {\n                        # Get the spell name from the comment.\n                        $book = $1;\n                        # Disambiguation for Conjuration\n                        my $extra = \"\";\n\n                        # Remove parenthesized bits\n                        $book =~ s/\\s+\\([^)]*\\)//g;\n\n                        # Remove extra description\n                        if ($book =~ s/ - (.*)//) {\n                                # But remember it for Conjuration\n                                if ($1 =~ /Fire and Earth/) {\n                                        $extra = \" (fire+earth)\";\n                                } elsif ($1 =~ /Air and Ice/) {\n                                        $extra = \" (ice+air)\";\n                                }\n                        }\n\n                        # Remove roman numeral counter\n                        $book =~ s/\\s+[IVX]+$//;\n\n                        # Replace \"Tome of\" with \"Book of\" (special case for Dragon)\n                        $book =~ s/^Tome of/Book of/;\n\n                        # And special-case Minor Magic.\n                        $book =~ s/^Minor/Book of Minor/;\n\n                        # Append disambiguation\n                        $book .= $extra;\n                } else {\n                        while (/SPELL_(\\w+)/g) {\n                                push @{$book_spells->{$1}}, $book;\n                                push @{$by_book->{$book}}, $1;\n                        }\n                }\n        }\n        close BOOKS;\n}\n\nsub parse_spl_data {\n        # Current spell.  Members are\n        #   {name}    : Spell name\n        #   {id}      : SPELL_* identifier (without the SPELL_)\n        #   {schools} : List of SPTYP_* constants (without the SPTYP_)\n        #   {flags}   : List of SPFLAG_* constants (without the SPFLAG_)\n        #   {books}   : List of book names.\n        #   {level}   : Level\n        #   {cap}     : Power cap\n        #   {minrange}: Minimum range, or \"LOS\" or \"\"\n        #   {maxrange}: Maximum range, or \"LOS\" or \"\"\n        #   {noisy}   : Noise modifier\n        #\n        #   {data}    : List of extra data; converted to {level}-{noise} at the end\n        #               of the spell block.\n        my ($indir, $book_spells, $by_id, $by_key, $sortkey) = @_;\n        my $spell = {};\n        open SPELLS, \"${indir}spl-data.h\"\n          or die \"could not open ${indir}spl-data.h: $!\";\n        while (<SPELLS>) {\n                chomp;\n                if (/^{/) {\n                        $spell = {};\n                } elsif (/^}/) {\n                        # Unpack data\n                        my (\n                            $sch, $flag, $lev, $cap, $minr, $maxr, $nm, @rest\n                           ) = @{$spell->{data}};\n\n                        # Parse out schools and flags\n                        $spell->{schools} = [\n                                             map { s/SPTYP_//; $_ } split /\\s*\\|\\s*/, $sch\n                                            ];\n                        $spell->{flags} = [\n                                           map { s/SPFLAG_//; $_ } split /\\s*\\|\\s*/, $flag\n                                          ];\n\n                        # Include the rest of the data\n                        $spell->{level} = $lev;\n                        $spell->{cap} = $cap;\n                        $spell->{minrange} = xlate_range $minr;\n                        $spell->{maxrange} = xlate_range $maxr;\n                        $spell->{noisy} = $nm;\n\n                        maybe_add_spell($spell, $by_id, $by_key, $sortkey);\n                } elsif (/^\\s*SPELL_(\\w+),\\s+\"([^\"]*)\",/) {\n                        $spell->{id} = $1;\n                        $spell->{name} = $2;\n                        if (exists $book_spells->{$1}) {\n                                $spell->{books} = [ @{$book_spells->{$1}} ];\n                        } else {\n                                $spell->{books} = [];\n                        }\n                } else {\n                        # Strip comments first.\n                        s!\\s*//.*!!;\n                        # Get comma-delimited sections\n                        while (/\\s*([^,]+)(,|$)/g) {\n                                if (substr($1, 0, 1) eq \"|\") {\n\t\t\t\t# Continuation line; really we should check\n\t\t\t\t# whether the previous line ended with a\n\t\t\t\t# comma, but this is probably good enough.\n                                        $spell->{data}[-1] .= $1\n                                } else {\n                                        push @{$spell->{data}}, $1;\n                                }\n                        }\n\n                }\n        }\n        close SPELLS;\n}\n\n\nsub module_default {\n        my ($sortkey, $sortfn, $by_key) = @_;\n        # Descriptions of spell flags\n        my %flag_descs = (\n                          ALLOW_SELF => <<\"EOF\",\nThe spell is not helpful, but you will not receive a \"Really target yourself?\"\nprompt.  You may still receive \"That beam is likely to hit you.\" for\n\"[[#Dir or target|dir or target]]\" spells such as Mephitic Cloud.\nEOF\n                          AREA => <<\"EOF\",\nThe spell harms an area.  Pacified fleeing monsters will not use emergency\nspells with this flag.\nEOF\n                          BATTLE => <<\"EOF\",\nThe spell is a non-[[Conjuration]] spell disliked by [[Elyvilon]].  There is no\npiety penalty for using such spells, but a randart spellbook containing one of\nthese spells will never have Elyvilon's name on it.\nEOF\n                          CHAOTIC => <<\"EOF\",\nThe spell is hated by [[Zin]], who will impose penance on any player casting\nit, and reward killing monsters who can cast it.\nEOF\n                          CORPSE_VIOLATING => <<\"EOF\",\nThe spell is hated by [[Fedhas Madash]], who will impose penance on any player\ncasting it.\nEOF\n                          DIR => <<\"EOF\",\nThe spell requires choosing a direction (and not a target).\nEOF\n                          DIR_OR_TARGET => <<\"EOF\",\nThe spell requires choosing a direction or target, and is stopped by\ninterposing creatures.\nEOF\n                          ESCAPE => <<\"EOF\",\nThe spell helps you get out of trouble.  Xom considers such spells boring, and\nwill not gift spellbooks containing them.  Furthermore, the spell is an option\nwhen control-clicking yourself in tiles mode.\nEOF\n                          GRID => <<\"EOF\",\nThe spell targets a grid square, disregarding any creatures in the way.  This\nis a form of smite targeting that does not require a target.\nEOF\n                          HASTY => <<\"EOF\",\nThe spell is hated by [[Cheibriados]], who will impose penance on any player\ncasting it.\nEOF\n                          HELPFUL => <<\"EOF\",\nThe spell helps you or the target; if targeted, the targeting commands\ncycle through friendlies rather than hostiles.  Xom considers such spells\nboring, and will not gift spellbooks containing them.\nEOF\n                          NEUTRAL => <<\"EOF\",\nThe spell is neither harmful nor helpful; if targeted, the targeting\ncommands cycle through all creatures, not just hostiles.  Xom considers\nsuch spells boring, and will not gift spellbooks containing them.\nEOF\n                          NONE => <<\"EOF\",\nThe spell has no special flags.  Such spells are always untargeted.\nEOF\n                          NOT_SELF => <<\"EOF\",\nThe spell may not target you or your square.\nEOF\n                          RECOVERY => <<\"EOF\",\nThe spell helps you recover from ill effects.  Xom considers such spells\nboring, and will not gift spellbooks containing them.  Furthermore, the spell\nis an option when control-clicking yourself in tiles mode.\nEOF\n                          TARGET => <<\"EOF\",\nThe spell targets a creature, disregarding any other creatures in the way.\nThis is a form of smite targeting that requires a target creature.\nEOF\n                          TARG_OBJ => <<\"EOF\",\nThe spell targets an object, disregarding any other creatures in the way.\nThis is a form of smite targeting that requires a target object.\nEOF\n                          UNCLEAN => <<\"EOF\",\nThe spell is hated by [[Zin]], who will impose penance on any player casting\nit, and reward killing monsters who can cast it.\nEOF\n                          UNHOLY => <<\"EOF\",\nThe spell is a non-necromantic unholy spell.  It is hated by [[good]] gods\n([[Elyvilon]], [[The Shining One]], and [[Zin]]), who will impose penance on\nany player casting it.\nEOF\n                         );\n        print <<\"EOF\";\n==Spells== <!-- We *must* have a heading before the table, or the TOC will end up inside the table! -->\n\n<!-- Automatically generated by $PROGNAME $VERSION\n     from Dungeon Crawl Stone Soup version $CRAWL_VERSION\n  -->\n{| class=\"prettytable\"\n!rowspan=2|Image\n!rowspan=2|Name\n!rowspan=2|Schools\n!rowspan=2|Level\n!rowspan=2|Power<br>cap\n! colspan=2 |Range\n!rowspan=2|Flags\n!rowspan=2|Books\n|----\n!min\n!max\nEOF\n\n        # TODO: allow sorting by other criteria\n        for my $key (sort keys %{$by_key}) {\n                my @spells = @{$by_key->{$key}};\n                @spells = sort $sortfn @spells if $sortfn;\n\n                print \"|----\\n! colspan=9 style=\\\"text-align:left\\\"|\\n====\";\n\n                # Format and link the key appropriately\n                if ($sortkey eq \"book\") {\n                        print \"[[$key]]\";\n                } elsif ($sortkey eq \"school\") {\n                        print format_schools $key;\n                } elsif ($sortkey eq \"level\") {\n                        print \"level $key\";\n                } elsif ($sortkey eq \"flag\") {\n                        my $fl = ucfirst lc $key;\n                        $fl =~ s/_/ /g;\n                        print $fl;\n                } else {\n                        print $key;\n                }\n                print \"====\\n\";\n                if ($sortkey eq \"flag\") {\n                        my $desc = $flag_descs{$key};\n                        if ($desc) {\n                                $desc =~ s/\\n/ /g;\n                                print \"|----\\n| colspan=9|$desc\\n\";\n                        }\n                }\n                for my $spell (@spells) {\n                        # Format schools and flags\n                        my $schools = format_schools @{$spell->{schools}};\n\n                        my $flags = join \", \", map {\n                                s/_/ /g; lc $_\n                        } @{$spell->{flags}}, ($spell->{noisy} ? \"noise $spell->{noisy}\" : ());\n                        my $books = join \"<br>\", map { \"[[$_]]\" } @{$spell->{books}};\n\n\n                        print <<\"EOF\";\n|----\n|[[File:{{lc:$spell->{name}.png}}]]\n|style=\"padding-left:1em\"|[[$spell->{name}]]\n|$schools\n|$spell->{level}\n|$spell->{cap}\n|$spell->{minrange}\n|$spell->{maxrange}\n|$flags\n|$books\nEOF\n                }\n        }\n\n        print <<\"EOF\";\n|----\n|}\nEOF\n\n}\n\n\nsub module_book {\n        my ($by_book) = @_;\n    print <<\"EOF\";\n--[=[\n     Table of spellbooks\n ]=]--\n\nlocal m = {}\nEOF\n\n    my @letters = qw(a b c d e f g);\n    my $i = 0;\n    for my $key (sort keys %$by_book) {\n        print \"m[\\\"$key\\\"] = {\\n\";\n        my @spells = @{$by_book->{$key}};\n        $i = 0;\n        for my $spell (@spells) {\n            my $schools = format_schools @{$spell->{schools}};\n            print \"  {\\n\";\n            print \"    [\\\"letter\\\"] = \\\"$letters[$i++]\\\", \\n\";\n            print \"    [\\\"name\\\"] = \\\"$spell->{name}\\\", \\n\";\n\t    my $lc_name = lc($spell->{name});\n            print \"    [\\\"image\\\"] = \\\"[[File:${lc_name}.png]]\\\", \\n\";\n            print \"    [\\\"level\\\"] = \\\"$spell->{level}\\\", \\n\";\n            print \"    [\\\"schools\\\"] = \\\"$schools\\\", \\n\";\n            print \"  },\\n\";\n        }\n        print \"}\\n\"\n    }\n    print \"return m\\n\";\n}\n\nsub module_spell {\n        my ($sortfn, $by_letter) = @_;\n        # Table of spells\n        print <<\"EOF\";\n--[=[\n     Table of spells\n ]=]--\n\nlocal m = {}\nEOF\n\n        for my $key (sort keys %$by_letter) {\n            my @spells = @{$by_letter->{$key}};\n            @spells = sort $sortfn @spells if $sortfn;\n            for my $spell (@spells) {\n                my $schools = ucfirst_array @{$spell->{schools}};\n                my $flags = ucfirst_array @{$spell->{flags}};\n                $flags =~ s/_/ /g;\n                $flags =~ s/Mr check/MR check/; # special case\n                $flags =~ s/^{ \\\"None\\\" }$/nil/; # special case\n                my $books = join \",\", map { \"\\\"$_\\\"\" } @{$spell->{books}};\n                my $range;\n                if ($spell->{minrange} eq \"\") {\n                    $range = \"nil\";\n                } elsif ($spell->{minrange} eq \"LOS\") {\n                    $range = \"\\\"LOS\\\"\";\n                } elsif ($spell->{minrange} eq $spell->{maxrange}) {\n                    $range = $spell->{minrange};\n                } else {\n                    $range = \"{$spell->{minrange}, $spell->{maxrange}}\";\n                }\n                print \"m[\\\"$spell->{name}\\\"] = {\\n\";\n                print \"    [\\\"schools\\\"] = $schools, \\n\";\n                print \"    [\\\"flags\\\"] = $flags, \\n\";\n                print \"    [\\\"books\\\"] = { $books }, \\n\";\n                print \"    [\\\"level\\\"] = $spell->{level}, \\n\";\n                print \"    [\\\"cap\\\"] = $spell->{cap}, \\n\";\n                print \"    [\\\"range\\\"] = $range, \\n\";\n                print \"    [\\\"noise\\\"] = $spell->{noisy}, \\n\";\n                print \"}\\n\";\n            }\n        }\n        print \"return m\\n\";\n}\n\nmain;\n\n</nowiki>\n</pre>"}