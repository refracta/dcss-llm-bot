{"title":"List of spells/parse-spl-data","url":"http://crawl.chaosforge.org/List_of_spells/parse-spl-data","type":"markdown","data":"A user has suggested the **deletion of this page**. Reason: No longer used\n\n```\n#! /usr/bin/perl -w\n# parse-spl-data, by http://crawl.chaosforge.org/index.php?title=User:Neil\n# Copyright (C) 2011.  No rights reserved.\n#\n# You may use, distribute, modify, study, fold, spindle, or mutilate this\n# software as you see fit, but know that there is NO WARRANTY, EXPRESS\n# OR IMPLIED (to the extent permitted by law).\n#\n# The latest version of this program may be found at:\n#  http://crawl.chaosforge.org/List_of_spells/parse-spl-data\n\nuse strict;\nuse Getopt::Long qw(:config gnu_getopt);\n\nour ($PROGNAME, $DATE, $CRAWL_VERSION);\nour $VERSION = \"0.1.0\";\n\n\nsub crawl_version {\n        my ($indir) = @_;\n\t# Look for util/release_ver first\n\tif (open VERSION, \"<\", \"${indir}util/release_ver\") {\n\t\tmy $ver = <VERSION>;\n\t\tchomp $ver;\n\t\tclose VERSION;\n\t\treturn $ver;\n\t}\n\t# TODO: maybe try running git\n\treturn \"<unknown>\";\n}\n\n# Translate a range into something friendlier for display.  -1 (no range)\n# becomes the empty string, while \"LOS_RADIUS\" becomes just LOS.\n# TORNADO_RADIUS becomes 5 (its value), but maybe we should use \"Tornado\"\n# instead.\nsub xlate_range {\n\tmy $range = shift;\n\treturn \"LOS\" if $range eq \"LOS_RADIUS\";\n\treturn 6 if $range eq \"TORNADO_RADIUS\";\n\treturn \"\" if $range eq \"-1\";\n\treturn $range;\n}\n\n# Wiki-format a list of spell schools, linking to the corresponding\n# magic skill.\nsub format_schools {\n\tjoin \"/\", map {\n\t\tmy $school = ucfirst(lc $_);\n\n\t\t# Convert school names to skill names for linking\n\t\tmy $skill = $school;\n\t\tif ($school =~ /^(Poison|Air|Fire|Ice|Earth)$/) {\n\t\t\t$skill = \"$school Magic\";\n\t\t} elsif ($school !~ /[ys]$/) {\n\t\t\t# \"Necromancy\" isn't pluralised as a skill,\n\t\t\t# and \"Hexes\" and \"Charms\" are already\n\t\t\t# pluralized as a magic school.  The others\n\t\t\t# are singular as a school, plural as a skill.\n\t\t\t$skill = \"${school}s\";\n\t\t}\n\n\t\t$skill eq $school ? \"[[$school]]\" : \"[[$skill|$school]]\";\n\t} @_;\n}\n\nsub ucfirst_array {\n    my $items = join \",\", map {\n        my $name = ucfirst(lc $_);\n        \"\\\"$name\\\"\";\n    } @_;\n    \"{ $items }\";\n}\n\n# Add a spell if it exists\nsub maybe_add_spell {\n\tmy ($spell, $by_id, $by_key, $sortkey) = @_;\n\treturn undef unless $spell->{name};\n\n\t# Ignore spells that do not occur in any book\n\treturn \"\" unless scalar @{$spell->{books}};\n\t# ..and NO_SPELL, which \"occurs\" in books but not really.\n\treturn \"\" if $spell->{id} eq \"NO_SPELL\";\n\n\t# Sanity checks: abort if we encounter one of these, as it means\n\t# something funny is up with our book-parsing.\n\n\t# Spells that belong to certain monster-only schools.\n\tfor my $school (@{$spell->{schools}}) {\n\t\tdie \"SPTYP_NONE for $spell->{name}\" if $school eq \"NONE\";\n\t}\n\t# Spells that don't belong to a school at all, even SPTYP_NONE.\n\tdie \"No school for $spell->{name}\" unless scalar @{$spell->{schools}};\n\n\t# Monster and testing spells.\n\tfor my $flag (@{$spell->{flags}}) {\n\t\tdie \"Monster spell $spell->{name}\" if $flag eq \"MONSTER\";\n\t\tdie \"Testing spell $spell->{name}\" if $flag eq \"TESTING\";\n\t}\n\n\t# It's worth keeping.\n\t$by_id->{$spell->{id}} = $spell;\n        if ($sortkey eq \"alpha\") {\n                $by_key->{$spell->{name}} = $spell;\n        } elsif ($sortkey eq \"letter\") {\n                my $let = uc(substr $spell->{name}, 0, 1);\n                push @{$by_key->{$let}}, $spell;\n        } elsif ($sortkey eq \"level\") {\n                push @{$by_key->{$spell->{level}}}, $spell;\n        } elsif ($sortkey eq \"school\") {\n                for my $school (@{$spell->{schools}}) {\n                        push @{$by_key->{$school}}, $spell;\n                }\n        } elsif ($sortkey eq \"flag\") {\n                for my $flag (@{$spell->{flags}}) {\n                        push @{$by_key->{$flag}}, $spell;\n                }\n        }\n\treturn 1;\n}\n\n# Sorting functions\nsub sort_by_name {\n\t$a->{name} cmp $b->{name}\n}\n\nsub sort_by_level {\n\t$a->{level} <=> $b->{level} or sort_by_name\n}\n\nsub sort_by_school {\n\t# A Schwartzian transform would be more efficient, but we have\n\t# few enough spells that it's not necessary.\n\tjoin(\"/\", @{$a->{schools}}) cmp join(\"/\", @{$b->{schools}})\n\t\tor sort_by_name\n}\n\n### MAIN\n\n\nsub main {\n        # Input directory.\n        my $indir = \"./\";\n\n        # Map from letter, school, flag, book name, or level to list of spells.\n        my %by_key = ();\n        my %by_letter = ();\n        my %by_school = ();\n        my %by_flag = ();\n        my %by_book = ();\n        my %by_level = ();\n\n        # Map from ID or name to spell\n        my %by_id = ();\n        my %by_name = ();\n\n        # Map from spell name to list of book names.\n        my %book_spells = ();\n\n\n\n        my $sortkey = \"alpha\";\n        my $sortfn = \\&sort_by_name;\n        my $module = \"default\";\n\n        GetOptions(\n                   \"a|alphabetic\" => sub { $sortkey = \"letter\"; $sortfn = \\&sort_by_name; },\n                   \"b|book\" => sub { $sortkey = \"book\"; $sortfn = undef; },\n                   \"f|flag\" => sub { $sortkey = \"flag\"; $sortfn = \\&sort_by_level; },\n                   \"l|level\" => sub { $sortkey = \"level\"; $sortfn = \\&sort_by_school; },\n                   \"s|school\" => sub { $sortkey = \"school\"; $sortfn = \\&sort_by_level; },\n                   \"m|module-book\" => sub { $module = \"book\"; $sortkey = \"book\" ; $sortfn = undef; },\n                   \"k|module-spell\" => sub { $module = \"spell\"; $sortkey = \"letter\"; $sortfn = \\&sort_by_name; },\n                   \"h|help\" => sub {\n                           print <<\"EOF\";\nUsage: $0 [options] [directory]\n\nProduce a wiki table of DCSS spells.  The specified directory should contain\nspl-data.h an book-data.h.  If omitted, the current directory is used.\n\nOptions include:\n  -a, --alphabetic    Arrange alphabetically (default).\n  -b, --book          Arrange by book, then level.\n  -f, --flag          Arrange by flag, then level.\n  -k, --module-spell  Generate a Lua table of spells.\n  -l, --level         Arrange by level, then schools.\n  -m, --module-book   Generate a Lua table of spellbooks.\n  -s, --school        Arrange by school, then level.\n  -h, --help          Display this help.\n\nSpells of the same schools and level are sorted by name.  With the --book,\n--school, and --flag option, spells may appear multiple times.\nEOF\n                           exit 0;\n                   },\n                  );\n\n        if (@ARGV) {\n                $indir = shift @ARGV;\n                $indir .= \"/\" unless $indir eq \"\" or $indir =~ m!/$!;\n        }\n\n        $DATE = gmtime;\n        $CRAWL_VERSION = crawl_version($indir);\n        ($PROGNAME = $0) =~ s!.*/!!;\n\n        parse_book_data($indir, \\%book_spells, \\%by_book);\n        parse_spl_data($indir, \\%book_spells, \\%by_id, \\%by_key, $sortkey);\n        for my $k (keys %by_book) {\n                # Convert the list of spell ids to a list of spells, but\n                # remove those that aren't in %by_id because maybe_add_spell\n                # skipped them.\n                my @spells =  map { $by_id{$_} || () } @{$by_book{$k}};\n                if (@spells) {\n                        $by_book{$k} = \\@spells;\n                } else {\n                        # Remove the book if it has no spells.\n                        delete $by_book{$k};\n                }\n        }\n\n        # Print data\n        if ($module eq \"default\") {\n                if ($sortkey eq \"book\") {\n                        module_default($sortkey, $sortfn, \\%by_book);\n                } else {\n                        module_default($sortkey, $sortfn, \\%by_key);\n                }\n        } elsif ($module eq \"book\") {\n                module_book(\\%by_book);\n        } elsif ($module eq \"spell\") {\n                module_spell($sortfn, \\%by_key);\n        }\n}\n\nsub parse_book_data {\n        my ($indir, $book_spells, $by_book) = @_;\n        # Name of current book.\n        my $book = \"bug\" ;\n        open BOOKS, \"${indir}book-data.h\"\n          or die \"could not open ${indir}book-data.h: $!\";\n        while (<BOOKS>) {\n                # Skip conditional sections.  Really we need to look at\n                # the condition, but that requires the C preprocessor and\n                # I'd rather avoid that.\n\n                #next if /^#if/../^#endif/;\n                next if /^#if TAG_MAJOR_VERSION == 34/../^#endif/;\n\n                # Kind of hackish --- quit at the first rod\n                last if m!// Rod!;\n\n                if (m!^{\\s*// (.*)!) {\n                        # Get the spell name from the comment.\n                        $book = $1;\n                        # Disambiguation for Conjuration\n                        my $extra = \"\";\n\n                        # Remove parenthesized bits\n                        $book =~ s/\\s+\\([^)]*\\)//g;\n\n                        # Remove extra description\n                        if ($book =~ s/ - (.*)//) {\n                                # But remember it for Conjuration\n                                if ($1 =~ /Fire and Earth/) {\n                                        $extra = \" (fire+earth)\";\n                                } elsif ($1 =~ /Air and Ice/) {\n                                        $extra = \" (ice+air)\";\n                                }\n                        }\n\n                        # Remove roman numeral counter\n                        $book =~ s/\\s+[IVX]+$//;\n\n                        # Replace \"Tome of\" with \"Book of\" (special case for Dragon)\n                        $book =~ s/^Tome of/Book of/;\n\n                        # And special-case Minor Magic.\n                        $book =~ s/^Minor/Book of Minor/;\n\n                        # Append disambiguation\n                        $book .= $extra;\n                } else {\n                        while (/SPELL_(\\w+)/g) {\n                                push @{$book_spells->{$1}}, $book;\n                                push @{$by_book->{$book}}, $1;\n                        }\n                }\n        }\n        close BOOKS;\n}\n\nsub parse_spl_data {\n        # Current spell.  Members are\n        #   {name}    : Spell name\n        #   {id}      : SPELL_* identifier (without the SPELL_)\n        #   {schools} : List of SPTYP_* constants (without the SPTYP_)\n        #   {flags}   : List of SPFLAG_* constants (without the SPFLAG_)\n        #   {books}   : List of book names.\n        #   {level}   : Level\n        #   {cap}     : Power cap\n        #   {minrange}: Minimum range, or \"LOS\" or \"\"\n        #   {maxrange}: Maximum range, or \"LOS\" or \"\"\n        #   {noisy}   : Noise modifier\n        #\n        #   {data}    : List of extra data; converted to {level}-{noise} at the end\n        #               of the spell block.\n        my ($indir, $book_spells, $by_id, $by_key, $sortkey) = @_;\n        my $spell = {};\n        open SPELLS, \"${indir}spl-data.h\"\n          or die \"could not open ${indir}spl-data.h: $!\";\n        while (<SPELLS>) {\n                chomp;\n                if (/^{/) {\n                        $spell = {};\n                } elsif (/^}/) {\n                        # Unpack data\n                        my (\n                            $sch, $flag, $lev, $cap, $minr, $maxr, $nm, @rest\n                           ) = @{$spell->{data}};\n\n                        # Parse out schools and flags\n                        $spell->{schools} = [\n                                             map { s/SPTYP_//; $_ } split /\\s*\\|\\s*/, $sch\n                                            ];\n                        $spell->{flags} = [\n                                           map { s/SPFLAG_//; $_ } split /\\s*\\|\\s*/, $flag\n                                          ];\n\n                        # Include the rest of the data\n                        $spell->{level} = $lev;\n                        $spell->{cap} = $cap;\n                        $spell->{minrange} = xlate_range $minr;\n                        $spell->{maxrange} = xlate_range $maxr;\n                        $spell->{noisy} = $nm;\n\n                        maybe_add_spell($spell, $by_id, $by_key, $sortkey);\n                } elsif (/^\\s*SPELL_(\\w+),\\s+\"([^\"]*)\",/) {\n                        $spell->{id} = $1;\n                        $spell->{name} = $2;\n                        if (exists $book_spells->{$1}) {\n                                $spell->{books} = [ @{$book_spells->{$1}} ];\n                        } else {\n                                $spell->{books} = [];\n                        }\n                } else {\n                        # Strip comments first.\n                        s!\\s*//.*!!;\n                        # Get comma-delimited sections\n                        while (/\\s*([^,]+)(,|$)/g) {\n                                if (substr($1, 0, 1) eq \"|\") {\n\t\t\t\t# Continuation line; really we should check\n\t\t\t\t# whether the previous line ended with a\n\t\t\t\t# comma, but this is probably good enough.\n                                        $spell->{data}[-1] .= $1\n                                } else {\n                                        push @{$spell->{data}}, $1;\n                                }\n                        }\n\n                }\n        }\n        close SPELLS;\n}\n\n\nsub module_default {\n        my ($sortkey, $sortfn, $by_key) = @_;\n        # Descriptions of spell flags\n        my %flag_descs = (\n                          ALLOW_SELF => <<\"EOF\",\nThe spell is not helpful, but you will not receive a \"Really target yourself?\"\nprompt.  You may still receive \"That beam is likely to hit you.\" for\n\"[[#Dir or target|dir or target]]\" spells such as Mephitic Cloud.\nEOF\n                          AREA => <<\"EOF\",\nThe spell harms an area.  Pacified fleeing monsters will not use emergency\nspells with this flag.\nEOF\n                          BATTLE => <<\"EOF\",\nThe spell is a non-[[Conjuration]] spell disliked by [[Elyvilon]].  There is no\npiety penalty for using such spells, but a randart spellbook containing one of\nthese spells will never have Elyvilon's name on it.\nEOF\n                          CHAOTIC => <<\"EOF\",\nThe spell is hated by [[Zin]], who will impose penance on any player casting\nit, and reward killing monsters who can cast it.\nEOF\n                          CORPSE_VIOLATING => <<\"EOF\",\nThe spell is hated by [[Fedhas Madash]], who will impose penance on any player\ncasting it.\nEOF\n                          DIR => <<\"EOF\",\nThe spell requires choosing a direction (and not a target).\nEOF\n                          DIR_OR_TARGET => <<\"EOF\",\nThe spell requires choosing a direction or target, and is stopped by\ninterposing creatures.\nEOF\n                          ESCAPE => <<\"EOF\",\nThe spell helps you get out of trouble.  Xom considers such spells boring, and\nwill not gift spellbooks containing them.  Furthermore, the spell is an option\nwhen control-clicking yourself in tiles mode.\nEOF\n                          GRID => <<\"EOF\",\nThe spell targets a grid square, disregarding any creatures in the way.  This\nis a form of smite targeting that does not require a target.\nEOF\n                          HASTY => <<\"EOF\",\nThe spell is hated by [[Cheibriados]], who will impose penance on any player\ncasting it.\nEOF\n                          HELPFUL => <<\"EOF\",\nThe spell helps you or the target; if targeted, the targeting commands\ncycle through friendlies rather than hostiles.  Xom considers such spells\nboring, and will not gift spellbooks containing them.\nEOF\n                          NEUTRAL => <<\"EOF\",\nThe spell is neither harmful nor helpful; if targeted, the targeting\ncommands cycle through all creatures, not just hostiles.  Xom considers\nsuch spells boring, and will not gift spellbooks containing them.\nEOF\n                          NONE => <<\"EOF\",\nThe spell has no special flags.  Such spells are always untargeted.\nEOF\n                          NOT_SELF => <<\"EOF\",\nThe spell may not target you or your square.\nEOF\n                          RECOVERY => <<\"EOF\",\nThe spell helps you recover from ill effects.  Xom considers such spells\nboring, and will not gift spellbooks containing them.  Furthermore, the spell\nis an option when control-clicking yourself in tiles mode.\nEOF\n                          TARGET => <<\"EOF\",\nThe spell targets a creature, disregarding any other creatures in the way.\nThis is a form of smite targeting that requires a target creature.\nEOF\n                          TARG_OBJ => <<\"EOF\",\nThe spell targets an object, disregarding any other creatures in the way.\nThis is a form of smite targeting that requires a target object.\nEOF\n                          UNCLEAN => <<\"EOF\",\nThe spell is hated by [[Zin]], who will impose penance on any player casting\nit, and reward killing monsters who can cast it.\nEOF\n                          UNHOLY => <<\"EOF\",\nThe spell is a non-necromantic unholy spell.  It is hated by [[good]] gods\n([[Elyvilon]], [[The Shining One]], and [[Zin]]), who will impose penance on\nany player casting it.\nEOF\n                         );\n        print <<\"EOF\";\n==Spells== <!-- We *must* have a heading before the table, or the TOC will end up inside the table! -->\n\n<!-- Automatically generated by $PROGNAME $VERSION\n     from Dungeon Crawl Stone Soup version $CRAWL_VERSION\n  -->\n{| class=\"prettytable\"\n!rowspan=2|Image\n!rowspan=2|Name\n!rowspan=2|Schools\n!rowspan=2|Level\n!rowspan=2|Power<br>cap\n! colspan=2 |Range\n!rowspan=2|Flags\n!rowspan=2|Books\n|----\n!min\n!max\nEOF\n\n        # TODO: allow sorting by other criteria\n        for my $key (sort keys %{$by_key}) {\n                my @spells = @{$by_key->{$key}};\n                @spells = sort $sortfn @spells if $sortfn;\n\n                print \"|----\\n! colspan=9 style=\\\"text-align:left\\\"|\\n====\";\n\n                # Format and link the key appropriately\n                if ($sortkey eq \"book\") {\n                        print \"[[$key]]\";\n                } elsif ($sortkey eq \"school\") {\n                        print format_schools $key;\n                } elsif ($sortkey eq \"level\") {\n                        print \"level $key\";\n                } elsif ($sortkey eq \"flag\") {\n                        my $fl = ucfirst lc $key;\n                        $fl =~ s/_/ /g;\n                        print $fl;\n                } else {\n                        print $key;\n                }\n                print \"====\\n\";\n                if ($sortkey eq \"flag\") {\n                        my $desc = $flag_descs{$key};\n                        if ($desc) {\n                                $desc =~ s/\\n/ /g;\n                                print \"|----\\n| colspan=9|$desc\\n\";\n                        }\n                }\n                for my $spell (@spells) {\n                        # Format schools and flags\n                        my $schools = format_schools @{$spell->{schools}};\n\n                        my $flags = join \", \", map {\n                                s/_/ /g; lc $_\n                        } @{$spell->{flags}}, ($spell->{noisy} ? \"noise $spell->{noisy}\" : ());\n                        my $books = join \"<br>\", map { \"[[$_]]\" } @{$spell->{books}};\n\n\n                        print <<\"EOF\";\n|----\n|[[File:{{lc:$spell->{name}.png}}]]\n|style=\"padding-left:1em\"|[[$spell->{name}]]\n|$schools\n|$spell->{level}\n|$spell->{cap}\n|$spell->{minrange}\n|$spell->{maxrange}\n|$flags\n|$books\nEOF\n                }\n        }\n\n        print <<\"EOF\";\n|----\n|}\nEOF\n\n}\n\n\nsub module_book {\n        my ($by_book) = @_;\n    print <<\"EOF\";\n--[=[\n     Table of spellbooks\n ]=]--\n\nlocal m = {}\nEOF\n\n    my @letters = qw(a b c d e f g);\n    my $i = 0;\n    for my $key (sort keys %$by_book) {\n        print \"m[\\\"$key\\\"] = {\\n\";\n        my @spells = @{$by_book->{$key}};\n        $i = 0;\n        for my $spell (@spells) {\n            my $schools = format_schools @{$spell->{schools}};\n            print \"  {\\n\";\n            print \"    [\\\"letter\\\"] = \\\"$letters[$i++]\\\", \\n\";\n            print \"    [\\\"name\\\"] = \\\"$spell->{name}\\\", \\n\";\n\t    my $lc_name = lc($spell->{name});\n            print \"    [\\\"image\\\"] = \\\"[[File:${lc_name}.png]]\\\", \\n\";\n            print \"    [\\\"level\\\"] = \\\"$spell->{level}\\\", \\n\";\n            print \"    [\\\"schools\\\"] = \\\"$schools\\\", \\n\";\n            print \"  },\\n\";\n        }\n        print \"}\\n\"\n    }\n    print \"return m\\n\";\n}\n\nsub module_spell {\n        my ($sortfn, $by_letter) = @_;\n        # Table of spells\n        print <<\"EOF\";\n--[=[\n     Table of spells\n ]=]--\n\nlocal m = {}\nEOF\n\n        for my $key (sort keys %$by_letter) {\n            my @spells = @{$by_letter->{$key}};\n            @spells = sort $sortfn @spells if $sortfn;\n            for my $spell (@spells) {\n                my $schools = ucfirst_array @{$spell->{schools}};\n                my $flags = ucfirst_array @{$spell->{flags}};\n                $flags =~ s/_/ /g;\n                $flags =~ s/Mr check/MR check/; # special case\n                $flags =~ s/^{ \\\"None\\\" }$/nil/; # special case\n                my $books = join \",\", map { \"\\\"$_\\\"\" } @{$spell->{books}};\n                my $range;\n                if ($spell->{minrange} eq \"\") {\n                    $range = \"nil\";\n                } elsif ($spell->{minrange} eq \"LOS\") {\n                    $range = \"\\\"LOS\\\"\";\n                } elsif ($spell->{minrange} eq $spell->{maxrange}) {\n                    $range = $spell->{minrange};\n                } else {\n                    $range = \"{$spell->{minrange}, $spell->{maxrange}}\";\n                }\n                print \"m[\\\"$spell->{name}\\\"] = {\\n\";\n                print \"    [\\\"schools\\\"] = $schools, \\n\";\n                print \"    [\\\"flags\\\"] = $flags, \\n\";\n                print \"    [\\\"books\\\"] = { $books }, \\n\";\n                print \"    [\\\"level\\\"] = $spell->{level}, \\n\";\n                print \"    [\\\"cap\\\"] = $spell->{cap}, \\n\";\n                print \"    [\\\"range\\\"] = $range, \\n\";\n                print \"    [\\\"noise\\\"] = $spell->{noisy}, \\n\";\n                print \"}\\n\";\n            }\n        }\n        print \"return m\\n\";\n}\n\nmain;\n```\n","html":"<!DOCTYPE html>\n<html class=\"client-nojs\" lang=\"en\" dir=\"ltr\">\n<head>\n<meta charset=\"UTF-8\"/>\n<title>List of spells/parse-spl-data - CrawlWiki</title>\n<script>document.documentElement.className = document.documentElement.className.replace( /(^|\\s)client-nojs(\\s|$)/, \"$1client-js$2\" );</script>\n<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({\"wgCanonicalNamespace\":\"\",\"wgCanonicalSpecialPageName\":false,\"wgNamespaceNumber\":0,\"wgPageName\":\"List_of_spells/parse-spl-data\",\"wgTitle\":\"List of spells/parse-spl-data\",\"wgCurRevisionId\":43367,\"wgRevisionId\":43367,\"wgArticleId\":4127,\"wgIsArticle\":true,\"wgIsRedirect\":false,\"wgAction\":\"view\",\"wgUserName\":null,\"wgUserGroups\":[\"*\"],\"wgCategories\":[\"Candidates for Deletion\"],\"wgBreakFrames\":false,\"wgPageContentLanguage\":\"en\",\"wgPageContentModel\":\"wikitext\",\"wgSeparatorTransformTable\":[\"\",\"\"],\"wgDigitTransformTable\":[\"\",\"\"],\"wgDefaultDateFormat\":\"dmy\",\"wgMonthNames\":[\"\",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],\"wgMonthNamesShort\":[\"\",\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],\"wgRelevantPageName\":\"List_of_spells/parse-spl-data\",\"wgRelevantArticleId\":4127,\"wgRequestId\":\"61cac572c5e9dfe4c44dac62\",\"wgIsProbablyEditable\":false,\"wgRelevantPageIsProbablyEditable\":false,\"wgRestrictionEdit\":[],\"wgRestrictionMove\":[]});mw.loader.state({\"site.styles\":\"ready\",\"noscript\":\"ready\",\"user.styles\":\"ready\",\"user\":\"ready\",\"user.options\":\"loading\",\"user.tokens\":\"loading\",\"ext.smw.style\":\"ready\",\"ext.smw.tooltip.styles\":\"ready\",\"mediawiki.legacy.shared\":\"ready\",\"mediawiki.legacy.commonPrint\":\"ready\",\"mediawiki.sectionAnchor\":\"ready\",\"mediawiki.skinning.interface\":\"ready\",\"skins.vector.styles\":\"ready\"});mw.loader.implement(\"user.options@0bhc5ha\",function($,jQuery,require,module){mw.user.options.set([]);});mw.loader.implement(\"user.tokens@014qz08\",function ( $, jQuery, require, module ) {\nmw.user.tokens.set({\"editToken\":\"+\\\\\",\"patrolToken\":\"+\\\\\",\"watchToken\":\"+\\\\\",\"csrfToken\":\"+\\\\\"});/*@nomin*/\n\n});mw.loader.load([\"ext.smw.style\",\"ext.smw.tooltips\",\"site\",\"mediawiki.page.startup\",\"mediawiki.user\",\"mediawiki.hidpi\",\"mediawiki.page.ready\",\"mediawiki.searchSuggest\",\"skins.vector.js\"]);});</script>\n<link rel=\"stylesheet\" href=\"/load.php?debug=false&amp;lang=en&amp;modules=ext.smw.style%7Cext.smw.tooltip.styles&amp;only=styles&amp;skin=vector\"/>\n<link rel=\"stylesheet\" href=\"/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector\"/>\n<script async=\"\" src=\"/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector\"></script>\n<meta name=\"ResourceLoaderDynamicStyles\" content=\"\"/>\n<link rel=\"stylesheet\" href=\"/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector\"/>\n<meta name=\"generator\" content=\"MediaWiki 1.30.0\"/>\n<link rel=\"ExportRDF\" type=\"application/rdf+xml\" title=\"List of spells/parse-spl-data\" href=\"/index.php?title=Special:ExportRDF/List_of_spells/parse-spl-data&amp;xmlmime=rdf\"/>\n<link rel=\"shortcut icon\" href=\"/favicon.ico\"/>\n<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/opensearch_desc.php\" title=\"CrawlWiki (en)\"/>\n<link rel=\"EditURI\" type=\"application/rsd+xml\" href=\"http://crawl.chaosforge.org/api.php?action=rsd\"/>\n<!--[if lt IE 9]><script src=\"/resources/lib/html5shiv/html5shiv.min.js?40bd4\"></script><![endif]-->\n</head>\n<body class=\"mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-List_of_spells_parse-spl-data rootpage-List_of_spells_parse-spl-data skin-vector action-view\">\t\t<div id=\"mw-page-base\" class=\"noprint\"></div>\n\t\t<div id=\"mw-head-base\" class=\"noprint\"></div>\n\t\t<div id=\"content\" class=\"mw-body\" role=\"main\">\n\t\t<script type=\"text/javascript\">\n\t\twindow.google_analytics_uacct = \"UA-3380984-8\";\n</script>\n<div class=\"adsense\">\n\t\t<script type=\"text/javascript\"><!--\n\t\tgoogle_ad_client = \"ca-pub-7088061744296615\";\n\t\t/* CrawlWiki skyscraper */\n\t\tgoogle_ad_slot = \"8196155564\";\n\t\tgoogle_ad_width = 160;\n\t\tgoogle_ad_height = 600;\n-->\n</script>\n<script type=\"text/javascript\"\nsrc=\"http://pagead2.googlesyndication.com/pagead/show_ads.js\">\n</script>\n</div>\n\n\t\t\t<a id=\"top\"></a>\n\n\t\t\t\t\t\t<div class=\"mw-indicators mw-body-content\">\n</div>\n\t\t\t<h1 id=\"firstHeading\" class=\"firstHeading\" lang=\"en\">List of spells/parse-spl-data</h1>\n\t\t\t\t\t\t\t\t\t<div id=\"bodyContent\" class=\"mw-body-content\">\n\t\t\t\t\t\t\t\t\t<div id=\"siteSub\" class=\"noprint\">From CrawlWiki</div>\n\t\t\t\t\t\t\t\t<div id=\"contentSub\"></div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div id=\"jump-to-nav\" class=\"mw-jump\">\n\t\t\t\t\tJump to:\t\t\t\t\t<a href=\"#mw-head\">navigation</a>, \t\t\t\t\t<a href=\"#p-search\">search</a>\n\t\t\t\t</div>\n\t\t\t\t<div id=\"mw-content-text\" lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\"><div class=\"mw-parser-output\"><center><div style=\"width: 90%; border: solid 3px black; background-color: red; text-align: left; padding: 1em;\">\n<p>A user has suggested the <b>deletion of this page</b>. Reason: No longer used\n</p>\n</div></center>\n<pre>\n\n#! /usr/bin/perl -w\n# parse-spl-data, by http://crawl.chaosforge.org/index.php?title=User:Neil\n# Copyright (C) 2011.  No rights reserved.\n#\n# You may use, distribute, modify, study, fold, spindle, or mutilate this\n# software as you see fit, but know that there is NO WARRANTY, EXPRESS\n# OR IMPLIED (to the extent permitted by law).\n#\n# The latest version of this program may be found at:\n#  http://crawl.chaosforge.org/List_of_spells/parse-spl-data\n\nuse strict;\nuse Getopt::Long qw(:config gnu_getopt);\n\nour ($PROGNAME, $DATE, $CRAWL_VERSION);\nour $VERSION = \"0.1.0\";\n\n\nsub crawl_version {\n        my ($indir) = @_;\n\t# Look for util/release_ver first\n\tif (open VERSION, \"&lt;\", \"${indir}util/release_ver\") {\n\t\tmy $ver = &lt;VERSION&gt;;\n\t\tchomp $ver;\n\t\tclose VERSION;\n\t\treturn $ver;\n\t}\n\t# TODO: maybe try running git\n\treturn \"&lt;unknown&gt;\";\n}\n\n# Translate a range into something friendlier for display.  -1 (no range)\n# becomes the empty string, while \"LOS_RADIUS\" becomes just LOS.\n# TORNADO_RADIUS becomes 5 (its value), but maybe we should use \"Tornado\"\n# instead.\nsub xlate_range {\n\tmy $range = shift;\n\treturn \"LOS\" if $range eq \"LOS_RADIUS\";\n\treturn 6 if $range eq \"TORNADO_RADIUS\";\n\treturn \"\" if $range eq \"-1\";\n\treturn $range;\n}\n\n# Wiki-format a list of spell schools, linking to the corresponding\n# magic skill.\nsub format_schools {\n\tjoin \"/\", map {\n\t\tmy $school = ucfirst(lc $_);\n\n\t\t# Convert school names to skill names for linking\n\t\tmy $skill = $school;\n\t\tif ($school =~ /^(Poison|Air|Fire|Ice|Earth)$/) {\n\t\t\t$skill = \"$school Magic\";\n\t\t} elsif ($school&#160;!~ /[ys]$/) {\n\t\t\t# \"Necromancy\" isn't pluralised as a skill,\n\t\t\t# and \"Hexes\" and \"Charms\" are already\n\t\t\t# pluralized as a magic school.  The others\n\t\t\t# are singular as a school, plural as a skill.\n\t\t\t$skill = \"${school}s\";\n\t\t}\n\n\t\t$skill eq $school&#160;? \"[[$school]]\"&#160;: \"[[$skill|$school]]\";\n\t} @_;\n}\n\nsub ucfirst_array {\n    my $items = join \",\", map {\n        my $name = ucfirst(lc $_);\n        \"\\\"$name\\\"\";\n    } @_;\n    \"{ $items }\";\n}\n\n# Add a spell if it exists\nsub maybe_add_spell {\n\tmy ($spell, $by_id, $by_key, $sortkey) = @_;\n\treturn undef unless $spell-&gt;{name};\n\n\t# Ignore spells that do not occur in any book\n\treturn \"\" unless scalar @{$spell-&gt;{books}};\n\t# ..and NO_SPELL, which \"occurs\" in books but not really.\n\treturn \"\" if $spell-&gt;{id} eq \"NO_SPELL\";\n\n\t# Sanity checks: abort if we encounter one of these, as it means\n\t# something funny is up with our book-parsing.\n\n\t# Spells that belong to certain monster-only schools.\n\tfor my $school (@{$spell-&gt;{schools}}) {\n\t\tdie \"SPTYP_NONE for $spell-&gt;{name}\" if $school eq \"NONE\";\n\t}\n\t# Spells that don't belong to a school at all, even SPTYP_NONE.\n\tdie \"No school for $spell-&gt;{name}\" unless scalar @{$spell-&gt;{schools}};\n\n\t# Monster and testing spells.\n\tfor my $flag (@{$spell-&gt;{flags}}) {\n\t\tdie \"Monster spell $spell-&gt;{name}\" if $flag eq \"MONSTER\";\n\t\tdie \"Testing spell $spell-&gt;{name}\" if $flag eq \"TESTING\";\n\t}\n\n\t# It's worth keeping.\n\t$by_id-&gt;{$spell-&gt;{id}} = $spell;\n        if ($sortkey eq \"alpha\") {\n                $by_key-&gt;{$spell-&gt;{name}} = $spell;\n        } elsif ($sortkey eq \"letter\") {\n                my $let = uc(substr $spell-&gt;{name}, 0, 1);\n                push @{$by_key-&gt;{$let}}, $spell;\n        } elsif ($sortkey eq \"level\") {\n                push @{$by_key-&gt;{$spell-&gt;{level}}}, $spell;\n        } elsif ($sortkey eq \"school\") {\n                for my $school (@{$spell-&gt;{schools}}) {\n                        push @{$by_key-&gt;{$school}}, $spell;\n                }\n        } elsif ($sortkey eq \"flag\") {\n                for my $flag (@{$spell-&gt;{flags}}) {\n                        push @{$by_key-&gt;{$flag}}, $spell;\n                }\n        }\n\treturn 1;\n}\n\n# Sorting functions\nsub sort_by_name {\n\t$a-&gt;{name} cmp $b-&gt;{name}\n}\n\nsub sort_by_level {\n\t$a-&gt;{level} &lt;=&gt; $b-&gt;{level} or sort_by_name\n}\n\nsub sort_by_school {\n\t# A Schwartzian transform would be more efficient, but we have\n\t# few enough spells that it's not necessary.\n\tjoin(\"/\", @{$a-&gt;{schools}}) cmp join(\"/\", @{$b-&gt;{schools}})\n\t\tor sort_by_name\n}\n\n### MAIN\n\n\nsub main {\n        # Input directory.\n        my $indir = \"./\";\n\n        # Map from letter, school, flag, book name, or level to list of spells.\n        my&#160;%by_key = ();\n        my&#160;%by_letter = ();\n        my&#160;%by_school = ();\n        my&#160;%by_flag = ();\n        my&#160;%by_book = ();\n        my&#160;%by_level = ();\n\n        # Map from ID or name to spell\n        my&#160;%by_id = ();\n        my&#160;%by_name = ();\n\n        # Map from spell name to list of book names.\n        my&#160;%book_spells = ();\n\n\n\n        my $sortkey = \"alpha\";\n        my $sortfn = \\&amp;sort_by_name;\n        my $module = \"default\";\n\n        GetOptions(\n                   \"a|alphabetic\" =&gt; sub { $sortkey = \"letter\"; $sortfn = \\&amp;sort_by_name; },\n                   \"b|book\" =&gt; sub { $sortkey = \"book\"; $sortfn = undef; },\n                   \"f|flag\" =&gt; sub { $sortkey = \"flag\"; $sortfn = \\&amp;sort_by_level; },\n                   \"l|level\" =&gt; sub { $sortkey = \"level\"; $sortfn = \\&amp;sort_by_school; },\n                   \"s|school\" =&gt; sub { $sortkey = \"school\"; $sortfn = \\&amp;sort_by_level; },\n                   \"m|module-book\" =&gt; sub { $module = \"book\"; $sortkey = \"book\"&#160;; $sortfn = undef; },\n                   \"k|module-spell\" =&gt; sub { $module = \"spell\"; $sortkey = \"letter\"; $sortfn = \\&amp;sort_by_name; },\n                   \"h|help\" =&gt; sub {\n                           print &lt;&lt;\"EOF\";\nUsage: $0 [options] [directory]\n\nProduce a wiki table of DCSS spells.  The specified directory should contain\nspl-data.h an book-data.h.  If omitted, the current directory is used.\n\nOptions include:\n  -a, --alphabetic    Arrange alphabetically (default).\n  -b, --book          Arrange by book, then level.\n  -f, --flag          Arrange by flag, then level.\n  -k, --module-spell  Generate a Lua table of spells.\n  -l, --level         Arrange by level, then schools.\n  -m, --module-book   Generate a Lua table of spellbooks.\n  -s, --school        Arrange by school, then level.\n  -h, --help          Display this help.\n\nSpells of the same schools and level are sorted by name.  With the --book,\n--school, and --flag option, spells may appear multiple times.\nEOF\n                           exit 0;\n                   },\n                  );\n\n        if (@ARGV) {\n                $indir = shift @ARGV;\n                $indir .= \"/\" unless $indir eq \"\" or $indir =~ m!/$!;\n        }\n\n        $DATE = gmtime;\n        $CRAWL_VERSION = crawl_version($indir);\n        ($PROGNAME = $0) =~ s!.*/!!;\n\n        parse_book_data($indir, \\%book_spells, \\%by_book);\n        parse_spl_data($indir, \\%book_spells, \\%by_id, \\%by_key, $sortkey);\n        for my $k (keys&#160;%by_book) {\n                # Convert the list of spell ids to a list of spells, but\n                # remove those that aren't in&#160;%by_id because maybe_add_spell\n                # skipped them.\n                my @spells =  map { $by_id{$_} || () } @{$by_book{$k}};\n                if (@spells) {\n                        $by_book{$k} = \\@spells;\n                } else {\n                        # Remove the book if it has no spells.\n                        delete $by_book{$k};\n                }\n        }\n\n        # Print data\n        if ($module eq \"default\") {\n                if ($sortkey eq \"book\") {\n                        module_default($sortkey, $sortfn, \\%by_book);\n                } else {\n                        module_default($sortkey, $sortfn, \\%by_key);\n                }\n        } elsif ($module eq \"book\") {\n                module_book(\\%by_book);\n        } elsif ($module eq \"spell\") {\n                module_spell($sortfn, \\%by_key);\n        }\n}\n\nsub parse_book_data {\n        my ($indir, $book_spells, $by_book) = @_;\n        # Name of current book.\n        my $book = \"bug\"&#160;;\n        open BOOKS, \"${indir}book-data.h\"\n          or die \"could not open ${indir}book-data.h: $!\";\n        while (&lt;BOOKS&gt;) {\n                # Skip conditional sections.  Really we need to look at\n                # the condition, but that requires the C preprocessor and\n                # I'd rather avoid that.\n\n                #next if /^#if/../^#endif/;\n                next if /^#if TAG_MAJOR_VERSION == 34/../^#endif/;\n\n                # Kind of hackish --- quit at the first rod\n                last if m!// Rod!;\n\n                if (m!^{\\s*// (.*)!) {\n                        # Get the spell name from the comment.\n                        $book = $1;\n                        # Disambiguation for Conjuration\n                        my $extra = \"\";\n\n                        # Remove parenthesized bits\n                        $book =~ s/\\s+\\([^)]*\\)//g;\n\n                        # Remove extra description\n                        if ($book =~ s/ - (.*)//) {\n                                # But remember it for Conjuration\n                                if ($1 =~ /Fire and Earth/) {\n                                        $extra = \" (fire+earth)\";\n                                } elsif ($1 =~ /Air and Ice/) {\n                                        $extra = \" (ice+air)\";\n                                }\n                        }\n\n                        # Remove roman numeral counter\n                        $book =~ s/\\s+[IVX]+$//;\n\n                        # Replace \"Tome of\" with \"Book of\" (special case for Dragon)\n                        $book =~ s/^Tome of/Book of/;\n\n                        # And special-case Minor Magic.\n                        $book =~ s/^Minor/Book of Minor/;\n\n                        # Append disambiguation\n                        $book .= $extra;\n                } else {\n                        while (/SPELL_(\\w+)/g) {\n                                push @{$book_spells-&gt;{$1}}, $book;\n                                push @{$by_book-&gt;{$book}}, $1;\n                        }\n                }\n        }\n        close BOOKS;\n}\n\nsub parse_spl_data {\n        # Current spell.  Members are\n        #   {name}   &#160;: Spell name\n        #   {id}     &#160;: SPELL_* identifier (without the SPELL_)\n        #   {schools}&#160;: List of SPTYP_* constants (without the SPTYP_)\n        #   {flags}  &#160;: List of SPFLAG_* constants (without the SPFLAG_)\n        #   {books}  &#160;: List of book names.\n        #   {level}  &#160;: Level\n        #   {cap}    &#160;: Power cap\n        #   {minrange}: Minimum range, or \"LOS\" or \"\"\n        #   {maxrange}: Maximum range, or \"LOS\" or \"\"\n        #   {noisy}  &#160;: Noise modifier\n        #\n        #   {data}   &#160;: List of extra data; converted to {level}-{noise} at the end\n        #               of the spell block.\n        my ($indir, $book_spells, $by_id, $by_key, $sortkey) = @_;\n        my $spell = {};\n        open SPELLS, \"${indir}spl-data.h\"\n          or die \"could not open ${indir}spl-data.h: $!\";\n        while (&lt;SPELLS&gt;) {\n                chomp;\n                if (/^{/) {\n                        $spell = {};\n                } elsif (/^}/) {\n                        # Unpack data\n                        my (\n                            $sch, $flag, $lev, $cap, $minr, $maxr, $nm, @rest\n                           ) = @{$spell-&gt;{data}};\n\n                        # Parse out schools and flags\n                        $spell-&gt;{schools} = [\n                                             map { s/SPTYP_//; $_ } split /\\s*\\|\\s*/, $sch\n                                            ];\n                        $spell-&gt;{flags} = [\n                                           map { s/SPFLAG_//; $_ } split /\\s*\\|\\s*/, $flag\n                                          ];\n\n                        # Include the rest of the data\n                        $spell-&gt;{level} = $lev;\n                        $spell-&gt;{cap} = $cap;\n                        $spell-&gt;{minrange} = xlate_range $minr;\n                        $spell-&gt;{maxrange} = xlate_range $maxr;\n                        $spell-&gt;{noisy} = $nm;\n\n                        maybe_add_spell($spell, $by_id, $by_key, $sortkey);\n                } elsif (/^\\s*SPELL_(\\w+),\\s+\"([^\"]*)\",/) {\n                        $spell-&gt;{id} = $1;\n                        $spell-&gt;{name} = $2;\n                        if (exists $book_spells-&gt;{$1}) {\n                                $spell-&gt;{books} = [ @{$book_spells-&gt;{$1}} ];\n                        } else {\n                                $spell-&gt;{books} = [];\n                        }\n                } else {\n                        # Strip comments first.\n                        s!\\s*//.*!!;\n                        # Get comma-delimited sections\n                        while (/\\s*([^,]+)(,|$)/g) {\n                                if (substr($1, 0, 1) eq \"|\") {\n\t\t\t\t# Continuation line; really we should check\n\t\t\t\t# whether the previous line ended with a\n\t\t\t\t# comma, but this is probably good enough.\n                                        $spell-&gt;{data}[-1] .= $1\n                                } else {\n                                        push @{$spell-&gt;{data}}, $1;\n                                }\n                        }\n\n                }\n        }\n        close SPELLS;\n}\n\n\nsub module_default {\n        my ($sortkey, $sortfn, $by_key) = @_;\n        # Descriptions of spell flags\n        my&#160;%flag_descs = (\n                          ALLOW_SELF =&gt; &lt;&lt;\"EOF\",\nThe spell is not helpful, but you will not receive a \"Really target yourself?\"\nprompt.  You may still receive \"That beam is likely to hit you.\" for\n\"[[#Dir or target|dir or target]]\" spells such as Mephitic Cloud.\nEOF\n                          AREA =&gt; &lt;&lt;\"EOF\",\nThe spell harms an area.  Pacified fleeing monsters will not use emergency\nspells with this flag.\nEOF\n                          BATTLE =&gt; &lt;&lt;\"EOF\",\nThe spell is a non-[[Conjuration]] spell disliked by [[Elyvilon]].  There is no\npiety penalty for using such spells, but a randart spellbook containing one of\nthese spells will never have Elyvilon's name on it.\nEOF\n                          CHAOTIC =&gt; &lt;&lt;\"EOF\",\nThe spell is hated by [[Zin]], who will impose penance on any player casting\nit, and reward killing monsters who can cast it.\nEOF\n                          CORPSE_VIOLATING =&gt; &lt;&lt;\"EOF\",\nThe spell is hated by [[Fedhas Madash]], who will impose penance on any player\ncasting it.\nEOF\n                          DIR =&gt; &lt;&lt;\"EOF\",\nThe spell requires choosing a direction (and not a target).\nEOF\n                          DIR_OR_TARGET =&gt; &lt;&lt;\"EOF\",\nThe spell requires choosing a direction or target, and is stopped by\ninterposing creatures.\nEOF\n                          ESCAPE =&gt; &lt;&lt;\"EOF\",\nThe spell helps you get out of trouble.  Xom considers such spells boring, and\nwill not gift spellbooks containing them.  Furthermore, the spell is an option\nwhen control-clicking yourself in tiles mode.\nEOF\n                          GRID =&gt; &lt;&lt;\"EOF\",\nThe spell targets a grid square, disregarding any creatures in the way.  This\nis a form of smite targeting that does not require a target.\nEOF\n                          HASTY =&gt; &lt;&lt;\"EOF\",\nThe spell is hated by [[Cheibriados]], who will impose penance on any player\ncasting it.\nEOF\n                          HELPFUL =&gt; &lt;&lt;\"EOF\",\nThe spell helps you or the target; if targeted, the targeting commands\ncycle through friendlies rather than hostiles.  Xom considers such spells\nboring, and will not gift spellbooks containing them.\nEOF\n                          NEUTRAL =&gt; &lt;&lt;\"EOF\",\nThe spell is neither harmful nor helpful; if targeted, the targeting\ncommands cycle through all creatures, not just hostiles.  Xom considers\nsuch spells boring, and will not gift spellbooks containing them.\nEOF\n                          NONE =&gt; &lt;&lt;\"EOF\",\nThe spell has no special flags.  Such spells are always untargeted.\nEOF\n                          NOT_SELF =&gt; &lt;&lt;\"EOF\",\nThe spell may not target you or your square.\nEOF\n                          RECOVERY =&gt; &lt;&lt;\"EOF\",\nThe spell helps you recover from ill effects.  Xom considers such spells\nboring, and will not gift spellbooks containing them.  Furthermore, the spell\nis an option when control-clicking yourself in tiles mode.\nEOF\n                          TARGET =&gt; &lt;&lt;\"EOF\",\nThe spell targets a creature, disregarding any other creatures in the way.\nThis is a form of smite targeting that requires a target creature.\nEOF\n                          TARG_OBJ =&gt; &lt;&lt;\"EOF\",\nThe spell targets an object, disregarding any other creatures in the way.\nThis is a form of smite targeting that requires a target object.\nEOF\n                          UNCLEAN =&gt; &lt;&lt;\"EOF\",\nThe spell is hated by [[Zin]], who will impose penance on any player casting\nit, and reward killing monsters who can cast it.\nEOF\n                          UNHOLY =&gt; &lt;&lt;\"EOF\",\nThe spell is a non-necromantic unholy spell.  It is hated by [[good]] gods\n([[Elyvilon]], [[The Shining One]], and [[Zin]]), who will impose penance on\nany player casting it.\nEOF\n                         );\n        print &lt;&lt;\"EOF\";\n==Spells== &lt;!-- We *must* have a heading before the table, or the TOC will end up inside the table! --&gt;\n\n&lt;!-- Automatically generated by $PROGNAME $VERSION\n     from Dungeon Crawl Stone Soup version $CRAWL_VERSION\n  --&gt;\n{| class=\"prettytable\"\n!rowspan=2|Image\n!rowspan=2|Name\n!rowspan=2|Schools\n!rowspan=2|Level\n!rowspan=2|Power&lt;br&gt;cap\n! colspan=2 |Range\n!rowspan=2|Flags\n!rowspan=2|Books\n|----\n!min\n!max\nEOF\n\n        # TODO: allow sorting by other criteria\n        for my $key (sort keys&#160;%{$by_key}) {\n                my @spells = @{$by_key-&gt;{$key}};\n                @spells = sort $sortfn @spells if $sortfn;\n\n                print \"|----\\n! colspan=9 style=\\\"text-align:left\\\"|\\n====\";\n\n                # Format and link the key appropriately\n                if ($sortkey eq \"book\") {\n                        print \"[[$key]]\";\n                } elsif ($sortkey eq \"school\") {\n                        print format_schools $key;\n                } elsif ($sortkey eq \"level\") {\n                        print \"level $key\";\n                } elsif ($sortkey eq \"flag\") {\n                        my $fl = ucfirst lc $key;\n                        $fl =~ s/_/ /g;\n                        print $fl;\n                } else {\n                        print $key;\n                }\n                print \"====\\n\";\n                if ($sortkey eq \"flag\") {\n                        my $desc = $flag_descs{$key};\n                        if ($desc) {\n                                $desc =~ s/\\n/ /g;\n                                print \"|----\\n| colspan=9|$desc\\n\";\n                        }\n                }\n                for my $spell (@spells) {\n                        # Format schools and flags\n                        my $schools = format_schools @{$spell-&gt;{schools}};\n\n                        my $flags = join \", \", map {\n                                s/_/ /g; lc $_\n                        } @{$spell-&gt;{flags}}, ($spell-&gt;{noisy}&#160;? \"noise $spell-&gt;{noisy}\"&#160;: ());\n                        my $books = join \"&lt;br&gt;\", map { \"[[$_]]\" } @{$spell-&gt;{books}};\n\n\n                        print &lt;&lt;\"EOF\";\n|----\n|[[File:{{lc:$spell-&gt;{name}.png}}]]\n|style=\"padding-left:1em\"|[[$spell-&gt;{name}]]\n|$schools\n|$spell-&gt;{level}\n|$spell-&gt;{cap}\n|$spell-&gt;{minrange}\n|$spell-&gt;{maxrange}\n|$flags\n|$books\nEOF\n                }\n        }\n\n        print &lt;&lt;\"EOF\";\n|----\n|}\nEOF\n\n}\n\n\nsub module_book {\n        my ($by_book) = @_;\n    print &lt;&lt;\"EOF\";\n--[=[\n     Table of spellbooks\n ]=]--\n\nlocal m = {}\nEOF\n\n    my @letters = qw(a b c d e f g);\n    my $i = 0;\n    for my $key (sort keys&#160;%$by_book) {\n        print \"m[\\\"$key\\\"] = {\\n\";\n        my @spells = @{$by_book-&gt;{$key}};\n        $i = 0;\n        for my $spell (@spells) {\n            my $schools = format_schools @{$spell-&gt;{schools}};\n            print \"  {\\n\";\n            print \"    [\\\"letter\\\"] = \\\"$letters[$i++]\\\", \\n\";\n            print \"    [\\\"name\\\"] = \\\"$spell-&gt;{name}\\\", \\n\";\n\t    my $lc_name = lc($spell-&gt;{name});\n            print \"    [\\\"image\\\"] = \\\"[[File:${lc_name}.png]]\\\", \\n\";\n            print \"    [\\\"level\\\"] = \\\"$spell-&gt;{level}\\\", \\n\";\n            print \"    [\\\"schools\\\"] = \\\"$schools\\\", \\n\";\n            print \"  },\\n\";\n        }\n        print \"}\\n\"\n    }\n    print \"return m\\n\";\n}\n\nsub module_spell {\n        my ($sortfn, $by_letter) = @_;\n        # Table of spells\n        print &lt;&lt;\"EOF\";\n--[=[\n     Table of spells\n ]=]--\n\nlocal m = {}\nEOF\n\n        for my $key (sort keys&#160;%$by_letter) {\n            my @spells = @{$by_letter-&gt;{$key}};\n            @spells = sort $sortfn @spells if $sortfn;\n            for my $spell (@spells) {\n                my $schools = ucfirst_array @{$spell-&gt;{schools}};\n                my $flags = ucfirst_array @{$spell-&gt;{flags}};\n                $flags =~ s/_/ /g;\n                $flags =~ s/Mr check/MR check/; # special case\n                $flags =~ s/^{ \\\"None\\\" }$/nil/; # special case\n                my $books = join \",\", map { \"\\\"$_\\\"\" } @{$spell-&gt;{books}};\n                my $range;\n                if ($spell-&gt;{minrange} eq \"\") {\n                    $range = \"nil\";\n                } elsif ($spell-&gt;{minrange} eq \"LOS\") {\n                    $range = \"\\\"LOS\\\"\";\n                } elsif ($spell-&gt;{minrange} eq $spell-&gt;{maxrange}) {\n                    $range = $spell-&gt;{minrange};\n                } else {\n                    $range = \"{$spell-&gt;{minrange}, $spell-&gt;{maxrange}}\";\n                }\n                print \"m[\\\"$spell-&gt;{name}\\\"] = {\\n\";\n                print \"    [\\\"schools\\\"] = $schools, \\n\";\n                print \"    [\\\"flags\\\"] = $flags, \\n\";\n                print \"    [\\\"books\\\"] = { $books }, \\n\";\n                print \"    [\\\"level\\\"] = $spell-&gt;{level}, \\n\";\n                print \"    [\\\"cap\\\"] = $spell-&gt;{cap}, \\n\";\n                print \"    [\\\"range\\\"] = $range, \\n\";\n                print \"    [\\\"noise\\\"] = $spell-&gt;{noisy}, \\n\";\n                print \"}\\n\";\n            }\n        }\n        print \"return m\\n\";\n}\n\nmain;\n\n\n</pre>\n\n<!-- \nNewPP limit report\nCached time: 20240916174210\nCache expiry: 86400\nDynamic content: false\n[SMW] In‐text annotation parser time: 0.001 seconds\nCPU time usage: 0.016 seconds\nReal time usage: 0.018 seconds\nPreprocessor visited node count: 9/1000000\nPreprocessor generated node count: 63/1000000\nPost‐expand include size: 245/2097152 bytes\nTemplate argument size: 14/2097152 bytes\nHighest expansion depth: 2/40\nExpensive parser function count: 0/100\n-->\n<!--\nTransclusion expansion time report (%,ms,calls,template)\n100.00%    2.475      1 -total\n100.00%    2.475      1 Template:Delete\n-->\n</div>\n<!-- Saved in parser cache with key crawl_wiki-crawl_:pcache:idhash:4127-0!canonical and timestamp 20240916174210 and revision id 43367\n -->\n</div>\t\t\t\t\t<div class=\"printfooter\">\n\t\t\t\t\t\tRetrieved from \"<a dir=\"ltr\" href=\"http://crawl.chaosforge.org/index.php?title=List_of_spells/parse-spl-data&amp;oldid=43367\">http://crawl.chaosforge.org/index.php?title=List_of_spells/parse-spl-data&amp;oldid=43367</a>\"\t\t\t\t\t</div>\n\t\t\t\t<div id=\"catlinks\" class=\"catlinks\" data-mw=\"interface\"><div id=\"mw-normal-catlinks\" class=\"mw-normal-catlinks\"><a href=\"/Special:Categories\" title=\"Special:Categories\">Category</a>: <ul><li><a href=\"/Category:Candidates_for_Deletion\" title=\"Category:Candidates for Deletion\">Candidates for Deletion</a></li></ul></div></div>\t\t\t\t<div class=\"visualClear\"></div>\n\t\t\t\t\t\t\t</div>\n\t\t</div>\n\t\t<div id=\"mw-navigation\">\n\t\t\t<h2>Navigation menu</h2>\n\n\t\t\t<div id=\"mw-head\">\n\t\t\t\t\t\t\t\t\t<div id=\"p-personal\" role=\"navigation\" class=\"\" aria-labelledby=\"p-personal-label\">\n\t\t\t\t\t\t<h3 id=\"p-personal-label\">Personal tools</h3>\n\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t<li id=\"pt-login\"><a href=\"/index.php?title=Special:UserLogin&amp;returnto=List+of+spells%2Fparse-spl-data\" title=\"You are encouraged to log in; however, it is not mandatory [o]\" accesskey=\"o\">Log in</a></li>\t\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div id=\"left-navigation\">\n\t\t\t\t\t\t\t\t\t\t<div id=\"p-namespaces\" role=\"navigation\" class=\"vectorTabs\" aria-labelledby=\"p-namespaces-label\">\n\t\t\t\t\t\t<h3 id=\"p-namespaces-label\">Namespaces</h3>\n\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<li id=\"ca-nstab-main\" class=\"selected\"><span><a href=\"/List_of_spells/parse-spl-data\" title=\"View the content page [c]\" accesskey=\"c\">Page</a></span></li>\n\t\t\t\t\t\t\t<li id=\"ca-talk\" class=\"new\"><span><a href=\"/index.php?title=Talk:List_of_spells/parse-spl-data&amp;action=edit&amp;redlink=1\" rel=\"discussion\" title=\"Discussion about the content page [t]\" accesskey=\"t\">Discussion</a></span></li>\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div id=\"p-variants\" role=\"navigation\" class=\"vectorMenu emptyPortlet\" aria-labelledby=\"p-variants-label\">\n\t\t\t\t\t\t\t\t\t\t\t\t<h3 id=\"p-variants-label\">\n\t\t\t\t\t\t\t<span>Variants</span>\n\t\t\t\t\t\t</h3>\n\n\t\t\t\t\t\t<div class=\"menu\">\n\t\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t<div id=\"right-navigation\">\n\t\t\t\t\t\t\t\t\t\t<div id=\"p-views\" role=\"navigation\" class=\"vectorTabs\" aria-labelledby=\"p-views-label\">\n\t\t\t\t\t\t<h3 id=\"p-views-label\">Views</h3>\n\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<li id=\"ca-view\" class=\"selected\"><span><a href=\"/List_of_spells/parse-spl-data\">Read</a></span></li>\n\t\t\t\t\t\t\t<li id=\"ca-viewsource\"><span><a href=\"/index.php?title=List_of_spells/parse-spl-data&amp;action=edit\" title=\"This page is protected.&#10;You can view its source [e]\" accesskey=\"e\">View source</a></span></li>\n\t\t\t\t\t\t\t<li id=\"ca-history\" class=\"collapsible\"><span><a href=\"/index.php?title=List_of_spells/parse-spl-data&amp;action=history\" title=\"Past revisions of this page [h]\" accesskey=\"h\">View history</a></span></li>\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div id=\"p-cactions\" role=\"navigation\" class=\"vectorMenu emptyPortlet\" aria-labelledby=\"p-cactions-label\">\n\t\t\t\t\t\t<h3 id=\"p-cactions-label\"><span>More</span></h3>\n\n\t\t\t\t\t\t<div class=\"menu\">\n\t\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div id=\"p-search\" role=\"search\">\n\t\t\t\t\t\t<h3>\n\t\t\t\t\t\t\t<label for=\"searchInput\">Search</label>\n\t\t\t\t\t\t</h3>\n\n\t\t\t\t\t\t<form action=\"/index.php\" id=\"searchform\">\n\t\t\t\t\t\t\t<div id=\"simpleSearch\">\n\t\t\t\t\t\t\t<input type=\"search\" name=\"search\" placeholder=\"Search CrawlWiki\" title=\"Search CrawlWiki [f]\" accesskey=\"f\" id=\"searchInput\"/><input type=\"hidden\" value=\"Special:Search\" name=\"title\"/><input type=\"submit\" name=\"fulltext\" value=\"Search\" title=\"Search the pages for this text\" id=\"mw-searchButton\" class=\"searchButton mw-fallbackSearchButton\"/><input type=\"submit\" name=\"go\" value=\"Go\" title=\"Go to a page with this exact name if it exists\" id=\"searchButton\" class=\"searchButton\"/>\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</form>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div id=\"mw-panel\">\n\t\t\t\t<div id=\"p-logo\" role=\"banner\"><a class=\"mw-wiki-logo\" href=\"/Crawl_Wiki\"  title=\"Visit the main page\"></a></div>\n\t\t\t\t\t\t<div class=\"portal\" role=\"navigation\" id='p-navigation' aria-labelledby='p-navigation-label'>\n\t\t\t<h3 id='p-navigation-label'>Navigation</h3>\n\n\t\t\t<div class=\"body\">\n\t\t\t\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li id=\"n-mainpage-description\"><a href=\"/Crawl_Wiki\" title=\"Visit the main page [z]\" accesskey=\"z\">Main page</a></li><li id=\"n-recentchanges\"><a href=\"/Special:RecentChanges\" title=\"A list of recent changes in the wiki [r]\" accesskey=\"r\">Recent changes</a></li><li id=\"n-randompage\"><a href=\"/Special:Random\" title=\"Load a random page [x]\" accesskey=\"x\">Random page</a></li><li id=\"n-help\"><a href=\"https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents\" title=\"The place to find out\">Help</a></li>\t\t\t\t\t</ul>\n\t\t\t\t\t\t\t</div>\n\t\t</div>\n\t\t\t<div class=\"portal\" role=\"navigation\" id='p-tb' aria-labelledby='p-tb-label'>\n\t\t\t<h3 id='p-tb-label'>Tools</h3>\n\n\t\t\t<div class=\"body\">\n\t\t\t\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li id=\"t-whatlinkshere\"><a href=\"/Special:WhatLinksHere/List_of_spells/parse-spl-data\" title=\"A list of all wiki pages that link here [j]\" accesskey=\"j\">What links here</a></li><li id=\"t-recentchangeslinked\"><a href=\"/Special:RecentChangesLinked/List_of_spells/parse-spl-data\" rel=\"nofollow\" title=\"Recent changes in pages linked from this page [k]\" accesskey=\"k\">Related changes</a></li><li id=\"t-specialpages\"><a href=\"/Special:SpecialPages\" title=\"A list of all special pages [q]\" accesskey=\"q\">Special pages</a></li><li id=\"t-print\"><a href=\"/index.php?title=List_of_spells/parse-spl-data&amp;printable=yes\" rel=\"alternate\" title=\"Printable version of this page [p]\" accesskey=\"p\">Printable version</a></li><li id=\"t-permalink\"><a href=\"/index.php?title=List_of_spells/parse-spl-data&amp;oldid=43367\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-info\"><a href=\"/index.php?title=List_of_spells/parse-spl-data&amp;action=info\" title=\"More information about this page\">Page information</a></li><li id=\"t-smwbrowselink\"><a href=\"/Special:Browse/:List-5Fof-5Fspells-2Fparse-2Dspl-2Ddata\" rel=\"smw-browse\">Browse properties</a></li>\t\t\t\t\t</ul>\n\t\t\t\t\t\t\t</div>\n\t\t</div>\n\t\t\t\t</div>\n\t\t</div>\n\t\t<div id=\"footer\" role=\"contentinfo\">\n\t\t\t\t\t\t\t<ul id=\"footer-info\">\n\t\t\t\t\t\t\t\t\t\t\t<li id=\"footer-info-lastmod\"> This page was last edited on 3 November 2016, at 12:31.</li>\n\t\t\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t\t<ul id=\"footer-places\">\n\t\t\t\t\t\t\t\t\t\t\t<li id=\"footer-places-privacy\"><a href=\"/CrawlWiki:Privacy_policy\" title=\"CrawlWiki:Privacy policy\">Privacy policy</a></li>\n\t\t\t\t\t\t\t\t\t\t\t<li id=\"footer-places-about\"><a href=\"/CrawlWiki:About\" title=\"CrawlWiki:About\">About CrawlWiki</a></li>\n\t\t\t\t\t\t\t\t\t\t\t<li id=\"footer-places-disclaimer\"><a href=\"/CrawlWiki:General_disclaimer\" title=\"CrawlWiki:General disclaimer\">Disclaimers</a></li>\n\t\t\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t\t\t\t\t<ul id=\"footer-icons\" class=\"noprint\">\n\t\t\t\t\t\t\t\t\t\t\t<li id=\"footer-poweredbyico\">\n\t\t\t\t\t\t\t<a href=\"//www.mediawiki.org/\"><img src=\"/resources/assets/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\" srcset=\"/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x\" width=\"88\" height=\"31\"/></a><a href=\"https://www.semantic-mediawiki.org/wiki/Semantic_MediaWiki\"><img src=\"/extensions/SemanticMediaWiki/includes/../res/images/smw_button.png\" alt=\"Powered by Semantic MediaWiki\" width=\"88\" height=\"31\"/></a>\t\t\t\t\t\t</li>\n\t\t\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t<div style=\"clear:both\"></div>\n\t\t</div>\n\t\t<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({\"wgPageParseReport\":{\"smw\":{\"limitreport-intext-parsertime\":0.001},\"limitreport\":{\"cputime\":\"0.016\",\"walltime\":\"0.018\",\"ppvisitednodes\":{\"value\":9,\"limit\":1000000},\"ppgeneratednodes\":{\"value\":63,\"limit\":1000000},\"postexpandincludesize\":{\"value\":245,\"limit\":2097152},\"templateargumentsize\":{\"value\":14,\"limit\":2097152},\"expansiondepth\":{\"value\":2,\"limit\":40},\"expensivefunctioncount\":{\"value\":0,\"limit\":100},\"timingprofile\":[\"100.00%    2.475      1 -total\",\"100.00%    2.475      1 Template:Delete\"]},\"cachereport\":{\"timestamp\":\"20240916174210\",\"ttl\":86400,\"transientcontent\":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({\"wgBackendResponseTime\":382});});</script>\n\t</body>\n</html>\n","rawPage":"{{delete|No longer used}}\n<pre>\n<nowiki>\n#! /usr/bin/perl -w\n# parse-spl-data, by http://crawl.chaosforge.org/index.php?title=User:Neil\n# Copyright (C) 2011.  No rights reserved.\n#\n# You may use, distribute, modify, study, fold, spindle, or mutilate this\n# software as you see fit, but know that there is NO WARRANTY, EXPRESS\n# OR IMPLIED (to the extent permitted by law).\n#\n# The latest version of this program may be found at:\n#  http://crawl.chaosforge.org/List_of_spells/parse-spl-data\n\nuse strict;\nuse Getopt::Long qw(:config gnu_getopt);\n\nour ($PROGNAME, $DATE, $CRAWL_VERSION);\nour $VERSION = \"0.1.0\";\n\n\nsub crawl_version {\n        my ($indir) = @_;\n\t# Look for util/release_ver first\n\tif (open VERSION, \"<\", \"${indir}util/release_ver\") {\n\t\tmy $ver = <VERSION>;\n\t\tchomp $ver;\n\t\tclose VERSION;\n\t\treturn $ver;\n\t}\n\t# TODO: maybe try running git\n\treturn \"<unknown>\";\n}\n\n# Translate a range into something friendlier for display.  -1 (no range)\n# becomes the empty string, while \"LOS_RADIUS\" becomes just LOS.\n# TORNADO_RADIUS becomes 5 (its value), but maybe we should use \"Tornado\"\n# instead.\nsub xlate_range {\n\tmy $range = shift;\n\treturn \"LOS\" if $range eq \"LOS_RADIUS\";\n\treturn 6 if $range eq \"TORNADO_RADIUS\";\n\treturn \"\" if $range eq \"-1\";\n\treturn $range;\n}\n\n# Wiki-format a list of spell schools, linking to the corresponding\n# magic skill.\nsub format_schools {\n\tjoin \"/\", map {\n\t\tmy $school = ucfirst(lc $_);\n\n\t\t# Convert school names to skill names for linking\n\t\tmy $skill = $school;\n\t\tif ($school =~ /^(Poison|Air|Fire|Ice|Earth)$/) {\n\t\t\t$skill = \"$school Magic\";\n\t\t} elsif ($school !~ /[ys]$/) {\n\t\t\t# \"Necromancy\" isn't pluralised as a skill,\n\t\t\t# and \"Hexes\" and \"Charms\" are already\n\t\t\t# pluralized as a magic school.  The others\n\t\t\t# are singular as a school, plural as a skill.\n\t\t\t$skill = \"${school}s\";\n\t\t}\n\n\t\t$skill eq $school ? \"[[$school]]\" : \"[[$skill|$school]]\";\n\t} @_;\n}\n\nsub ucfirst_array {\n    my $items = join \",\", map {\n        my $name = ucfirst(lc $_);\n        \"\\\"$name\\\"\";\n    } @_;\n    \"{ $items }\";\n}\n\n# Add a spell if it exists\nsub maybe_add_spell {\n\tmy ($spell, $by_id, $by_key, $sortkey) = @_;\n\treturn undef unless $spell->{name};\n\n\t# Ignore spells that do not occur in any book\n\treturn \"\" unless scalar @{$spell->{books}};\n\t# ..and NO_SPELL, which \"occurs\" in books but not really.\n\treturn \"\" if $spell->{id} eq \"NO_SPELL\";\n\n\t# Sanity checks: abort if we encounter one of these, as it means\n\t# something funny is up with our book-parsing.\n\n\t# Spells that belong to certain monster-only schools.\n\tfor my $school (@{$spell->{schools}}) {\n\t\tdie \"SPTYP_NONE for $spell->{name}\" if $school eq \"NONE\";\n\t}\n\t# Spells that don't belong to a school at all, even SPTYP_NONE.\n\tdie \"No school for $spell->{name}\" unless scalar @{$spell->{schools}};\n\n\t# Monster and testing spells.\n\tfor my $flag (@{$spell->{flags}}) {\n\t\tdie \"Monster spell $spell->{name}\" if $flag eq \"MONSTER\";\n\t\tdie \"Testing spell $spell->{name}\" if $flag eq \"TESTING\";\n\t}\n\n\t# It's worth keeping.\n\t$by_id->{$spell->{id}} = $spell;\n        if ($sortkey eq \"alpha\") {\n                $by_key->{$spell->{name}} = $spell;\n        } elsif ($sortkey eq \"letter\") {\n                my $let = uc(substr $spell->{name}, 0, 1);\n                push @{$by_key->{$let}}, $spell;\n        } elsif ($sortkey eq \"level\") {\n                push @{$by_key->{$spell->{level}}}, $spell;\n        } elsif ($sortkey eq \"school\") {\n                for my $school (@{$spell->{schools}}) {\n                        push @{$by_key->{$school}}, $spell;\n                }\n        } elsif ($sortkey eq \"flag\") {\n                for my $flag (@{$spell->{flags}}) {\n                        push @{$by_key->{$flag}}, $spell;\n                }\n        }\n\treturn 1;\n}\n\n# Sorting functions\nsub sort_by_name {\n\t$a->{name} cmp $b->{name}\n}\n\nsub sort_by_level {\n\t$a->{level} <=> $b->{level} or sort_by_name\n}\n\nsub sort_by_school {\n\t# A Schwartzian transform would be more efficient, but we have\n\t# few enough spells that it's not necessary.\n\tjoin(\"/\", @{$a->{schools}}) cmp join(\"/\", @{$b->{schools}})\n\t\tor sort_by_name\n}\n\n### MAIN\n\n\nsub main {\n        # Input directory.\n        my $indir = \"./\";\n\n        # Map from letter, school, flag, book name, or level to list of spells.\n        my %by_key = ();\n        my %by_letter = ();\n        my %by_school = ();\n        my %by_flag = ();\n        my %by_book = ();\n        my %by_level = ();\n\n        # Map from ID or name to spell\n        my %by_id = ();\n        my %by_name = ();\n\n        # Map from spell name to list of book names.\n        my %book_spells = ();\n\n\n\n        my $sortkey = \"alpha\";\n        my $sortfn = \\&sort_by_name;\n        my $module = \"default\";\n\n        GetOptions(\n                   \"a|alphabetic\" => sub { $sortkey = \"letter\"; $sortfn = \\&sort_by_name; },\n                   \"b|book\" => sub { $sortkey = \"book\"; $sortfn = undef; },\n                   \"f|flag\" => sub { $sortkey = \"flag\"; $sortfn = \\&sort_by_level; },\n                   \"l|level\" => sub { $sortkey = \"level\"; $sortfn = \\&sort_by_school; },\n                   \"s|school\" => sub { $sortkey = \"school\"; $sortfn = \\&sort_by_level; },\n                   \"m|module-book\" => sub { $module = \"book\"; $sortkey = \"book\" ; $sortfn = undef; },\n                   \"k|module-spell\" => sub { $module = \"spell\"; $sortkey = \"letter\"; $sortfn = \\&sort_by_name; },\n                   \"h|help\" => sub {\n                           print <<\"EOF\";\nUsage: $0 [options] [directory]\n\nProduce a wiki table of DCSS spells.  The specified directory should contain\nspl-data.h an book-data.h.  If omitted, the current directory is used.\n\nOptions include:\n  -a, --alphabetic    Arrange alphabetically (default).\n  -b, --book          Arrange by book, then level.\n  -f, --flag          Arrange by flag, then level.\n  -k, --module-spell  Generate a Lua table of spells.\n  -l, --level         Arrange by level, then schools.\n  -m, --module-book   Generate a Lua table of spellbooks.\n  -s, --school        Arrange by school, then level.\n  -h, --help          Display this help.\n\nSpells of the same schools and level are sorted by name.  With the --book,\n--school, and --flag option, spells may appear multiple times.\nEOF\n                           exit 0;\n                   },\n                  );\n\n        if (@ARGV) {\n                $indir = shift @ARGV;\n                $indir .= \"/\" unless $indir eq \"\" or $indir =~ m!/$!;\n        }\n\n        $DATE = gmtime;\n        $CRAWL_VERSION = crawl_version($indir);\n        ($PROGNAME = $0) =~ s!.*/!!;\n\n        parse_book_data($indir, \\%book_spells, \\%by_book);\n        parse_spl_data($indir, \\%book_spells, \\%by_id, \\%by_key, $sortkey);\n        for my $k (keys %by_book) {\n                # Convert the list of spell ids to a list of spells, but\n                # remove those that aren't in %by_id because maybe_add_spell\n                # skipped them.\n                my @spells =  map { $by_id{$_} || () } @{$by_book{$k}};\n                if (@spells) {\n                        $by_book{$k} = \\@spells;\n                } else {\n                        # Remove the book if it has no spells.\n                        delete $by_book{$k};\n                }\n        }\n\n        # Print data\n        if ($module eq \"default\") {\n                if ($sortkey eq \"book\") {\n                        module_default($sortkey, $sortfn, \\%by_book);\n                } else {\n                        module_default($sortkey, $sortfn, \\%by_key);\n                }\n        } elsif ($module eq \"book\") {\n                module_book(\\%by_book);\n        } elsif ($module eq \"spell\") {\n                module_spell($sortfn, \\%by_key);\n        }\n}\n\nsub parse_book_data {\n        my ($indir, $book_spells, $by_book) = @_;\n        # Name of current book.\n        my $book = \"bug\" ;\n        open BOOKS, \"${indir}book-data.h\"\n          or die \"could not open ${indir}book-data.h: $!\";\n        while (<BOOKS>) {\n                # Skip conditional sections.  Really we need to look at\n                # the condition, but that requires the C preprocessor and\n                # I'd rather avoid that.\n\n                #next if /^#if/../^#endif/;\n                next if /^#if TAG_MAJOR_VERSION == 34/../^#endif/;\n\n                # Kind of hackish --- quit at the first rod\n                last if m!// Rod!;\n\n                if (m!^{\\s*// (.*)!) {\n                        # Get the spell name from the comment.\n                        $book = $1;\n                        # Disambiguation for Conjuration\n                        my $extra = \"\";\n\n                        # Remove parenthesized bits\n                        $book =~ s/\\s+\\([^)]*\\)//g;\n\n                        # Remove extra description\n                        if ($book =~ s/ - (.*)//) {\n                                # But remember it for Conjuration\n                                if ($1 =~ /Fire and Earth/) {\n                                        $extra = \" (fire+earth)\";\n                                } elsif ($1 =~ /Air and Ice/) {\n                                        $extra = \" (ice+air)\";\n                                }\n                        }\n\n                        # Remove roman numeral counter\n                        $book =~ s/\\s+[IVX]+$//;\n\n                        # Replace \"Tome of\" with \"Book of\" (special case for Dragon)\n                        $book =~ s/^Tome of/Book of/;\n\n                        # And special-case Minor Magic.\n                        $book =~ s/^Minor/Book of Minor/;\n\n                        # Append disambiguation\n                        $book .= $extra;\n                } else {\n                        while (/SPELL_(\\w+)/g) {\n                                push @{$book_spells->{$1}}, $book;\n                                push @{$by_book->{$book}}, $1;\n                        }\n                }\n        }\n        close BOOKS;\n}\n\nsub parse_spl_data {\n        # Current spell.  Members are\n        #   {name}    : Spell name\n        #   {id}      : SPELL_* identifier (without the SPELL_)\n        #   {schools} : List of SPTYP_* constants (without the SPTYP_)\n        #   {flags}   : List of SPFLAG_* constants (without the SPFLAG_)\n        #   {books}   : List of book names.\n        #   {level}   : Level\n        #   {cap}     : Power cap\n        #   {minrange}: Minimum range, or \"LOS\" or \"\"\n        #   {maxrange}: Maximum range, or \"LOS\" or \"\"\n        #   {noisy}   : Noise modifier\n        #\n        #   {data}    : List of extra data; converted to {level}-{noise} at the end\n        #               of the spell block.\n        my ($indir, $book_spells, $by_id, $by_key, $sortkey) = @_;\n        my $spell = {};\n        open SPELLS, \"${indir}spl-data.h\"\n          or die \"could not open ${indir}spl-data.h: $!\";\n        while (<SPELLS>) {\n                chomp;\n                if (/^{/) {\n                        $spell = {};\n                } elsif (/^}/) {\n                        # Unpack data\n                        my (\n                            $sch, $flag, $lev, $cap, $minr, $maxr, $nm, @rest\n                           ) = @{$spell->{data}};\n\n                        # Parse out schools and flags\n                        $spell->{schools} = [\n                                             map { s/SPTYP_//; $_ } split /\\s*\\|\\s*/, $sch\n                                            ];\n                        $spell->{flags} = [\n                                           map { s/SPFLAG_//; $_ } split /\\s*\\|\\s*/, $flag\n                                          ];\n\n                        # Include the rest of the data\n                        $spell->{level} = $lev;\n                        $spell->{cap} = $cap;\n                        $spell->{minrange} = xlate_range $minr;\n                        $spell->{maxrange} = xlate_range $maxr;\n                        $spell->{noisy} = $nm;\n\n                        maybe_add_spell($spell, $by_id, $by_key, $sortkey);\n                } elsif (/^\\s*SPELL_(\\w+),\\s+\"([^\"]*)\",/) {\n                        $spell->{id} = $1;\n                        $spell->{name} = $2;\n                        if (exists $book_spells->{$1}) {\n                                $spell->{books} = [ @{$book_spells->{$1}} ];\n                        } else {\n                                $spell->{books} = [];\n                        }\n                } else {\n                        # Strip comments first.\n                        s!\\s*//.*!!;\n                        # Get comma-delimited sections\n                        while (/\\s*([^,]+)(,|$)/g) {\n                                if (substr($1, 0, 1) eq \"|\") {\n\t\t\t\t# Continuation line; really we should check\n\t\t\t\t# whether the previous line ended with a\n\t\t\t\t# comma, but this is probably good enough.\n                                        $spell->{data}[-1] .= $1\n                                } else {\n                                        push @{$spell->{data}}, $1;\n                                }\n                        }\n\n                }\n        }\n        close SPELLS;\n}\n\n\nsub module_default {\n        my ($sortkey, $sortfn, $by_key) = @_;\n        # Descriptions of spell flags\n        my %flag_descs = (\n                          ALLOW_SELF => <<\"EOF\",\nThe spell is not helpful, but you will not receive a \"Really target yourself?\"\nprompt.  You may still receive \"That beam is likely to hit you.\" for\n\"[[#Dir or target|dir or target]]\" spells such as Mephitic Cloud.\nEOF\n                          AREA => <<\"EOF\",\nThe spell harms an area.  Pacified fleeing monsters will not use emergency\nspells with this flag.\nEOF\n                          BATTLE => <<\"EOF\",\nThe spell is a non-[[Conjuration]] spell disliked by [[Elyvilon]].  There is no\npiety penalty for using such spells, but a randart spellbook containing one of\nthese spells will never have Elyvilon's name on it.\nEOF\n                          CHAOTIC => <<\"EOF\",\nThe spell is hated by [[Zin]], who will impose penance on any player casting\nit, and reward killing monsters who can cast it.\nEOF\n                          CORPSE_VIOLATING => <<\"EOF\",\nThe spell is hated by [[Fedhas Madash]], who will impose penance on any player\ncasting it.\nEOF\n                          DIR => <<\"EOF\",\nThe spell requires choosing a direction (and not a target).\nEOF\n                          DIR_OR_TARGET => <<\"EOF\",\nThe spell requires choosing a direction or target, and is stopped by\ninterposing creatures.\nEOF\n                          ESCAPE => <<\"EOF\",\nThe spell helps you get out of trouble.  Xom considers such spells boring, and\nwill not gift spellbooks containing them.  Furthermore, the spell is an option\nwhen control-clicking yourself in tiles mode.\nEOF\n                          GRID => <<\"EOF\",\nThe spell targets a grid square, disregarding any creatures in the way.  This\nis a form of smite targeting that does not require a target.\nEOF\n                          HASTY => <<\"EOF\",\nThe spell is hated by [[Cheibriados]], who will impose penance on any player\ncasting it.\nEOF\n                          HELPFUL => <<\"EOF\",\nThe spell helps you or the target; if targeted, the targeting commands\ncycle through friendlies rather than hostiles.  Xom considers such spells\nboring, and will not gift spellbooks containing them.\nEOF\n                          NEUTRAL => <<\"EOF\",\nThe spell is neither harmful nor helpful; if targeted, the targeting\ncommands cycle through all creatures, not just hostiles.  Xom considers\nsuch spells boring, and will not gift spellbooks containing them.\nEOF\n                          NONE => <<\"EOF\",\nThe spell has no special flags.  Such spells are always untargeted.\nEOF\n                          NOT_SELF => <<\"EOF\",\nThe spell may not target you or your square.\nEOF\n                          RECOVERY => <<\"EOF\",\nThe spell helps you recover from ill effects.  Xom considers such spells\nboring, and will not gift spellbooks containing them.  Furthermore, the spell\nis an option when control-clicking yourself in tiles mode.\nEOF\n                          TARGET => <<\"EOF\",\nThe spell targets a creature, disregarding any other creatures in the way.\nThis is a form of smite targeting that requires a target creature.\nEOF\n                          TARG_OBJ => <<\"EOF\",\nThe spell targets an object, disregarding any other creatures in the way.\nThis is a form of smite targeting that requires a target object.\nEOF\n                          UNCLEAN => <<\"EOF\",\nThe spell is hated by [[Zin]], who will impose penance on any player casting\nit, and reward killing monsters who can cast it.\nEOF\n                          UNHOLY => <<\"EOF\",\nThe spell is a non-necromantic unholy spell.  It is hated by [[good]] gods\n([[Elyvilon]], [[The Shining One]], and [[Zin]]), who will impose penance on\nany player casting it.\nEOF\n                         );\n        print <<\"EOF\";\n==Spells== <!-- We *must* have a heading before the table, or the TOC will end up inside the table! -->\n\n<!-- Automatically generated by $PROGNAME $VERSION\n     from Dungeon Crawl Stone Soup version $CRAWL_VERSION\n  -->\n{| class=\"prettytable\"\n!rowspan=2|Image\n!rowspan=2|Name\n!rowspan=2|Schools\n!rowspan=2|Level\n!rowspan=2|Power<br>cap\n! colspan=2 |Range\n!rowspan=2|Flags\n!rowspan=2|Books\n|----\n!min\n!max\nEOF\n\n        # TODO: allow sorting by other criteria\n        for my $key (sort keys %{$by_key}) {\n                my @spells = @{$by_key->{$key}};\n                @spells = sort $sortfn @spells if $sortfn;\n\n                print \"|----\\n! colspan=9 style=\\\"text-align:left\\\"|\\n====\";\n\n                # Format and link the key appropriately\n                if ($sortkey eq \"book\") {\n                        print \"[[$key]]\";\n                } elsif ($sortkey eq \"school\") {\n                        print format_schools $key;\n                } elsif ($sortkey eq \"level\") {\n                        print \"level $key\";\n                } elsif ($sortkey eq \"flag\") {\n                        my $fl = ucfirst lc $key;\n                        $fl =~ s/_/ /g;\n                        print $fl;\n                } else {\n                        print $key;\n                }\n                print \"====\\n\";\n                if ($sortkey eq \"flag\") {\n                        my $desc = $flag_descs{$key};\n                        if ($desc) {\n                                $desc =~ s/\\n/ /g;\n                                print \"|----\\n| colspan=9|$desc\\n\";\n                        }\n                }\n                for my $spell (@spells) {\n                        # Format schools and flags\n                        my $schools = format_schools @{$spell->{schools}};\n\n                        my $flags = join \", \", map {\n                                s/_/ /g; lc $_\n                        } @{$spell->{flags}}, ($spell->{noisy} ? \"noise $spell->{noisy}\" : ());\n                        my $books = join \"<br>\", map { \"[[$_]]\" } @{$spell->{books}};\n\n\n                        print <<\"EOF\";\n|----\n|[[File:{{lc:$spell->{name}.png}}]]\n|style=\"padding-left:1em\"|[[$spell->{name}]]\n|$schools\n|$spell->{level}\n|$spell->{cap}\n|$spell->{minrange}\n|$spell->{maxrange}\n|$flags\n|$books\nEOF\n                }\n        }\n\n        print <<\"EOF\";\n|----\n|}\nEOF\n\n}\n\n\nsub module_book {\n        my ($by_book) = @_;\n    print <<\"EOF\";\n--[=[\n     Table of spellbooks\n ]=]--\n\nlocal m = {}\nEOF\n\n    my @letters = qw(a b c d e f g);\n    my $i = 0;\n    for my $key (sort keys %$by_book) {\n        print \"m[\\\"$key\\\"] = {\\n\";\n        my @spells = @{$by_book->{$key}};\n        $i = 0;\n        for my $spell (@spells) {\n            my $schools = format_schools @{$spell->{schools}};\n            print \"  {\\n\";\n            print \"    [\\\"letter\\\"] = \\\"$letters[$i++]\\\", \\n\";\n            print \"    [\\\"name\\\"] = \\\"$spell->{name}\\\", \\n\";\n\t    my $lc_name = lc($spell->{name});\n            print \"    [\\\"image\\\"] = \\\"[[File:${lc_name}.png]]\\\", \\n\";\n            print \"    [\\\"level\\\"] = \\\"$spell->{level}\\\", \\n\";\n            print \"    [\\\"schools\\\"] = \\\"$schools\\\", \\n\";\n            print \"  },\\n\";\n        }\n        print \"}\\n\"\n    }\n    print \"return m\\n\";\n}\n\nsub module_spell {\n        my ($sortfn, $by_letter) = @_;\n        # Table of spells\n        print <<\"EOF\";\n--[=[\n     Table of spells\n ]=]--\n\nlocal m = {}\nEOF\n\n        for my $key (sort keys %$by_letter) {\n            my @spells = @{$by_letter->{$key}};\n            @spells = sort $sortfn @spells if $sortfn;\n            for my $spell (@spells) {\n                my $schools = ucfirst_array @{$spell->{schools}};\n                my $flags = ucfirst_array @{$spell->{flags}};\n                $flags =~ s/_/ /g;\n                $flags =~ s/Mr check/MR check/; # special case\n                $flags =~ s/^{ \\\"None\\\" }$/nil/; # special case\n                my $books = join \",\", map { \"\\\"$_\\\"\" } @{$spell->{books}};\n                my $range;\n                if ($spell->{minrange} eq \"\") {\n                    $range = \"nil\";\n                } elsif ($spell->{minrange} eq \"LOS\") {\n                    $range = \"\\\"LOS\\\"\";\n                } elsif ($spell->{minrange} eq $spell->{maxrange}) {\n                    $range = $spell->{minrange};\n                } else {\n                    $range = \"{$spell->{minrange}, $spell->{maxrange}}\";\n                }\n                print \"m[\\\"$spell->{name}\\\"] = {\\n\";\n                print \"    [\\\"schools\\\"] = $schools, \\n\";\n                print \"    [\\\"flags\\\"] = $flags, \\n\";\n                print \"    [\\\"books\\\"] = { $books }, \\n\";\n                print \"    [\\\"level\\\"] = $spell->{level}, \\n\";\n                print \"    [\\\"cap\\\"] = $spell->{cap}, \\n\";\n                print \"    [\\\"range\\\"] = $range, \\n\";\n                print \"    [\\\"noise\\\"] = $spell->{noisy}, \\n\";\n                print \"}\\n\";\n            }\n        }\n        print \"return m\\n\";\n}\n\nmain;\n\n</nowiki>\n</pre>"}