{"title":"Beginner's guide to NetHack sources","url":"https://nethackwiki.com/wiki/Beginner%27s_guide_to_NetHack_sources","type":"markdown","data":"This is a classic text [spoiler](/wiki/Spoiler \"Spoiler\"), reproduced on NetHackWiki for reference and archival purposes. You should link to this page when you copy or excerpt it, but please do not modify the content.\n\n**Caution:** As this is not an ordinary wiki page edited by the community, this spoiler may contain outdated or otherwise inaccurate information.\n\n```\n\t BEGINNER'S GUIDE TO NETHACK SOURCES\n        ---------------------- by German Martin --\n                                        german@spain.hp.com\n\n                  \t\t   version 1.0  March '95\n\nContents\n--------\n\n   1. About this document.\n   2. Hey, I want to modify the game!\n   3. Starting point.\n   4. The wizard mode.\n   5. Creating a new level.\n   6. Creating a new monster.\n   7. Refining your monster.\n\t   7.0. The 'monst' struct.\n\t   7.1. Adding a new attack type.\n\t   7.2. Adding new monster's abilities.\n\t   7.3. Adding a 'mextra' struct.\n   8. Creating a new object.\n\t   8.0. The 'objects' array.\n\t   8.1. Adding a tool.\n\t   8.2. Adding a wand.\n\t   8.3. Adding a potion.\n\t   8.4. Adding armor/weapon.\n\t   8.5. Adding a ring.\n\t   8.6. Adding an amulet.\n\t   8.7. Adding a spellbook.\n\t   8.8. Adding food.\n   9. Creating a new room type.\n  10. Creating a new shop type.\n  11. Goodbye.\n  Apendix A. Reference Function listing\n\n\n1. About this document\n----------------------\n\n   Have you played - and enjoyed - nethack for several [ months | years ] ?\n  Do you have some cool new ideas for the game but nobody seems to hear you?\n  Do you have access to a machine with a C compiler? Have you ever programmed\n  before?\n\n   If you answered yes to the above questions then this paper can be of your\n  interest.\n\n   Around middle '94 I started to look around in the nethack sources; loving\n  the game I really wanted to add some new monsters & features, but the task\n  was quite painful. I'm not a C newbie, but 100 (actually more) source\n  files was more than I could manage: even trying to find the main() entry\n  to the code proved to be difficult. The help provided by the inlined \n  comments is useless for the newcomer. Now, nine months later, I've learned\n  a lot about the main structures in the code: I've been able to add new\n  monsters, objects, rooms, levels and behaviours. I - not being a member of\n  the Dev Team, in case you were wondered - don't pretend to have a full\n  knowledge of the huge beast, but my objective here is to help new ideas\n  to be added to the game, not being a complete guide to the code.\n\n   So, it is quite possible that you found many things incorrect here; more\n  than possible - that is, sure - that you found many things incomplete.\n  OK, send the bug/comment/addition to me and I'd modify/add it.\n\n   Please, USE THIS AT YOUR OWN RISK. If you get nothing but frustration don't\n  flame me: I was only trying to help.\n\n   All the documentation here refers to Nethack 3.1.3 (the current official\n  version at the date this is written).\n\n\n2. Hey, I want to modify the game!\n----------------------------------\n\n   OK. You have started to play nethack last week; got an account in a Unix\n  machine and thought \"Hey, I have a great idea! I'll learn C while modifying\n  this game! All I have to do is follow this cookbook!\". Forget it. Unless you\n  are a reincarnation of Leonardo da Vinci you'll get nothing but a headache.\n\n   In other words, to use this info you need at last:\n\n     - Few knowledge about the OS you are running in. That is, how to edit,\n      move, create and remove files basically.\n\n     - Good knowledge of the C programming language. That is, more than the\n      printf(\"Hello world\\n\") program. This includes the C preprocessor.\n\n     - A C compiler and feel comfortable with it.\n\n     - A blessed potion of gain ability.\n\n\n3. Starting point\n-----------------\n\n   The first thing you have to do is compile the sources by yourself. You\n   don't have to understand the whole process, but surely you need to be\n   able to compile the official code and get it running before you add any-\n   thing to the game. Refer to the README file in the top directory and to\n   the Install.XXX  (XXX depending of your operating system) in /sys/XXX\n   directory.\n\n   Once you have compiled the sources suddenly you are now aware of what\n   to expect.\n\n\n4. The wizard mode\n------------------\n   As you probably know, the wizard mode is a way to start nethack with a\n   few extra commands:\n\n\t\t^E  ==  detect secret doors and traps.\n\t\t^F  ==  do magic mapping.\n\t\t^G  ==  create monster.\n\t\t^I  ==  identify items in pack.\n\t\t^O  ==  tell locations of special levels.\n\t\t^T  ==  do intra-level teleport.\n\t\t^V  ==  do trans-level teleport.\n\t\t^W  ==  make wish.\n\t\t^X  ==  show intrinsic attributes.\n\n     plus some changes for known actions: i.e. read a scroll of create\n   monster allows to specify the type of monster.\n\n   That allows you to quickly try out the new feature/change you just added.\n   To start it, just type:\n\n                nethack -u wizard -D\n\n   It should work, but take present:\n\n   - If in a unix machine you should be the correct user-id.\n   - have a look in include/config.h and search for the #define WIZARD lines;\n    maybe you need to put another name after the -u.\n\n   Throughout your process of modifying nethack you should make extensible\n   usage of this mode so better make sure it works. (As an alternative you\n   can always play a complete game to try out your new monster in the astral\n   level :-) )\n\n\n\n5. Creating a new level\n-----------------------\n\n   To create a new level is easy. In fact, it doesn't require any knowledge\n   of C: the dev team prepared it for us.\n\n   Under the \"util\" directory the process of creating a nethack executable\n   should have left a program called 'lev_comp' (lev_comp.exe if in MS-DOS).\n   That binary is capable of create a new special level for nethack: give it\n   a description file (named <something>.des) and it gives you a level file\n   (named <something>.lev) suitable for the nethack binary:\n\n\n            mylevel.des -----------\n                                   |\n                                __ | __\n                                \\  V  /\n                              ___\\___/___\n                              |         | _\n                              |lev_comp |/\n                              |         |  -----> mylevel.lev\n                              -------------\n\n   The lev_comp compiler has a manual page (have a look in the \"doc\" directory)\n   called 'lev_comp.6'. If you are in a unix machine a command like \n                          nroff -man lev_comp.6 | more\n   should give you a standard formatted man page. If not... well, you should\n   have to get used to the .SH .PP etc... garbage in the file. This man page\n   shows (quite obtusely) how to create a .des file; but better than starting\n   from scratch is starting trying to understand a predefined file.\n   For example, let's view the begining of \"dat/castle.des\" file:\n\n\tMAZE:\"castle\",random\n\tFLAGS: noteleport\n\tGEOMETRY:center,center\n\tMAP\n\t}}}}}}}}}.............................................}}}}}}}}}\n\t}-------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}\n\t}|.....|-----------------------------------------------|.....|}\n\t}|.....+...............................................+.....|}\n\t}-------------------------------+-----------------------------}\n\t}}}}}}|........|..........+...........|.......S.S.......|}}}}}}\n\t.....}|........|..........|...........|.......|.|.......|}.....\n\t.....}|........------------...........---------S---------}.....\n\t.....}|...{....+..........+.........\\.S.................+......\n\t.....}|........------------...........---------S---------}.....\n\t.....}|........|..........|...........|.......|.|.......|}.....\n\t}}}}}}|........|..........+...........|.......S.S.......|}}}}}}\n\t}-------------------------------+-----------------------------}\n\t}|.....+...............................................+.....|}\n\t}|.....|-----------------------------------------------|.....|}\n\t}-------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}\n\t}}}}}}}}}.............................................}}}}}}}}}\n\tENDMAP\n\n   Sounds familiar? This file is the description from where the castle\n   level is created. The part showed here just sets the level aspect: a\n   drawed castle centered between mazes (note the MAZE line). \n\n   The rest of the file puts doors, traps, objects and monsters in a random\n   or specific position (with coordinates relative to the previous map).\n\n   The man page describes the exact syntax, so if you dare you can now start\n   modifying the whole file; but let's make a very easy change and see how it\n   works: suppose you feel the soldiers at the castle are too wimpy and think\n   changing them to more difficult monsters, say minotaurs for example. So,\n   just change the lines:\n\n   MONSTER:'@',\"soldier\",(08,06) and subsequents\n\n   with\n\n   MONSTER:'H',\"minotaur\",(08,06) etc...\n\n   (Note that with this change we are chosing a specific monster. We could have\n   chosen to create monsters of a certain class, like\n\n   MONSTER:'D',RANDOM,(08,06)   # Create a random type dragon )\n\n   Save the new castle.des file and run: (from the dat directory)\n\n      ../util/lev_comp castle.des      (change the /'s with \\'s if in MS-DOS)\n\n   That creates a new 'castle.lev' file in the 'dat' directory. To try it,\n   copy it to the playing directory (something like games/nethack) and start\n   a game in wizard mode. Teleport to the castle, wish for a floating eye\n   corpse and a blindfold and have a look: you should have lots of brown H's!\n\n\n   But now it is time to deal with the original subject: we wanted to added\n   a NEW level to nethack, not just modifying one. Let the castle.des alone\n   and create a newlevel.des!\n\n   For that, we have to introduce a new compiler: dgn_comp, the dungeon\n   compiler. As the lev_comp it has a manual page: dgn_comp.6. Its purpose\n   is a step ahead: it takes a file describing the complete dungeon (as a\n   collection of levels) and creates a \"dungeon\" file suitable for the\n   nethack binary.\n\n   The description file in question is called \"dungeon.def\":\n\n\tDUNGEON:        \"The Dungeons of Doom\" \"D\" (25, 5)\n\tALIGNMENT:      unaligned\n\t%MULDGN BRANCH: \"The Gnomish Mines\" @ (2, 3)\n\t%REINCARNATION LEVEL:           \"rogue\" \"R\" @ (15, 4)\n\tLEVEL:          \"oracle\" \"O\" @ (5, 5)\n\tLEVALIGN:       neutral\n\tLEVEL:          \"bigroom\" \"B\" @ (10, 3) 15\n\t%MULDGN CHAINBRANCH:    \"The Quest\" \"oracle\" + (6, 2) portal\n\t%MULDGN BRANCH:         \"Fort Ludios\" @ (18, 4) portal\n\tRNDLEVEL:       \"medusa\" \"none\" @ (-5, 4) 2\n\tLEVALIGN:       chaotic\n\tLEVEL:          \"castle\" \"none\" @ (-1, 0)\n\tCHAINBRANCH:    \"Gehennom\" \"castle\" + (0, 0) no_down\n\tBRANCH:         \"The Elemental Planes\" @ (1, 0) no_down up\n\n   As you probably knew, there are 'levels' and branches of the main dungeon,\n   being composed of levels. The easiest thing is to add a simple level inside\n   the main dungeon: \n\n   Suppose you created a new mylevel.des file where you define a 'mylevel' \n   level:\n\n   MAZE:\"mylevel\",' '\n\n   (IMPORTANT note here: usually the file is named the same as the MAZE it\n   defines, as in castle.des, but the name for the .lev file is taken from\n   the MAZE line !!)\n\n   To add it to the main dungeon we can add a line after the bigroom one:\n\n   LEVEL:\t\"mylevel\" \"none\" @ (15,2)\n\n   That is, create the 'mylevel' level randomly at 15 +-2 level deep. The \n   level won't left bones files (the 'none' part).\n\n   And run ../util/dgn_comp dungeon.def  to get the 'dungeon' file. Copy it\n   to the game directory and try it out (wizard mode command Ctrl-O is quite\n   useful here).\n\n   If there is any error loading the new level, nethack will create a random\n   maze instead.\n\n   Finally, if we wanted to add a whole new branch to the dungeon, we will\n   put a line like:\n\n   %MULDGN BRANCH: \"newbranch\" @ (18, 1)\n   \n   and later on, the lines defining the levels in this new branch:\n\n   DUNGEON:        \"newbranch\" \"S\" (4,0)\n   DESCRIPTION:    mazelike\n   LEVEL:          \"mylevel1\" \"none\" @ (1, 0)\n   LEVEL:          \"mylevel2\" \"none\" @ (2, 0)\n   LEVEL:          \"mylevel3\" \"none\" @ (3, 0)\n   LEVEL:          \"mylevel4\" \"none\" @ (4, 0)\n\n\n   Now you should take a while and play around with the existing .des files\n   and become familiar with the syntax. Creating new levels and dungeon wasn't\n   difficult, was it?\n\n   Maybe this chapter covers all your needs; but if you really want \n   exciting new emotions, read on.\n\n\n6. Creating a new monster\n-------------------------\n\n      \"Beware, there will be no return! Still read? (y/n)\"\n      \n   Welcome to Darkness of Mordor... This is going to be painful but the\n   reward is great: some modification could be blessed by the dev team and\n   you will reach inmortality! And anyway, modifying nethack will give you\n   even happier hours than playing it.\n\n   So, let's cope with it:\n\n   For start, you should know that there are two HUGE arrays: one defining the\n   possible monsters and the other defining the possible objects. The first\n   one is called 'mons': it's an array of 'permonst' structs defined in the\n   file monst.c, under the src directory (by the way, after this point, I'll\n   stop saying where the files are located: you should be familiar with the\n   directory structure by now). The 'permonst' struct is defined in the\n   file permonst.h, and giving it a look should give you an idea of what \n   element of the struct is for, but, for your convenience here is an expla-\n   nation of what to put in a new entry for the mons array, i.e:\n\n\n        {\"myself\", S_HUMAN, 1, 10, 10, 0, 0, G_GENO | G_NOGEN,\n        { { AT_WEAP, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK,\n          NO_ATTK, NO_ATTK, NO_ATTK },\n        WT_HUMAN, 400, PL_NSIZ, MS_HUMANOID, MZ_HUMAN, 0, 0,\n        M1_NEEDPICK | M1_HUMANOID | M1_OMNIVORE,\n        M2_HUMAN | M2_STRONG | M2_COLLECT, 0, C(HI_DOMESTIC)}\n\n   -name: (\"myself\") is the name for the monster.\n\n   -symbol: (S_HUMAN) is the letter used for it. The complete list is defined\n\t  in the file monsym.h\n\n   -level: (1). The monster is initially created with this level.\n\n   -move rate: (10). Ranges from 0 -don't move- to 30 -really fast-.\n\n   -AC: (10). Come on! you now quite well what this is.\n\n   -magic resistance: (0). Ranges from 0 -none- to 127 -full-.\n\n   -alignment: (0). negative value means chaotic, positive lawful.\n\n   -creation/geno flags: (G_GENO | G_NOGEN) \n\tthese are flags or'ded, with this meaning:\n\n        G_UNIQ          /* generated only once */\n        G_NOHELL        /* not generated in \"hell\" */\n        G_HELL          /* generated only in \"hell\" */\n        G_NOGEN         /* generated only specially */\n        G_NOCORPSE      /* no corpse left ever */\n        G_SGROUP        /* appear in small groups normally */\n        G_LGROUP        /* appear in large groups normally */\n        G_GENO          /* can be genocided */\n        G_GENOD         /* have been genocided */\n        G_EXTINCT       /* have been extinguished as\n                           population control */\n        G_FREQ          /* creation frequency mask */\n\n                 (from monsym.h)\n\n   -attack: ({ { AT_WEAP, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK,\n           NO_ATTK, NO_ATTK, NO_ATTK },)\n      This defines how the monster attacks. This element is composed of six \n      'attack' struct, each one being the form:\n\n\t  ( attack_type, damage_type, # of dice, # of sides of each )\n\n      where attack_type is one of:\n\n        AT_NONE         /* passive monster (ex. acid blob) */\n        AT_CLAW         /* claw (punch, hit, etc.) */\n        AT_BITE         /* bite */\n        AT_KICK         /* kick */\n        AT_BUTT         /* head butt (ex. a unicorn) */\n        AT_TUCH         /* touches */\n        AT_STNG         /* sting */\n        AT_HUGS         /* crushing bearhug */\n        AT_SPIT         /* spits substance - ranged */\n        AT_ENGL         /* engulf (swallow or by a butt) */\n        AT_BREA         /* breath - ranged */\n        AT_EXPL         /* explodes - proximity */\n        AT_GAZE         /* gaze - ranged */\n        AT_TENT         /* tentacles */\n        AT_WEAP         /* uses weapon */\n        AT_MAGC         /* uses magic spell(s) */\n\n      damage_type is one of:\n\n        AD_PHYS         /* ordinary physical */\n        AD_MAGM         /* magic missiles */\n        AD_FIRE         /* fire damage */\n        AD_COLD         /* frost damage */\n        AD_SLEE         /* sleep ray */\n        AD_DISN         /* disintegration (death ray) */\n        AD_ELEC         /* shock damage */\n        AD_DRST         /* drains str (poison) */\n        AD_ACID         /* acid damage */\n        AD_SPC1         /* for extension of buzz() */\n        AD_SPC2         /* for extension of buzz() */\n        AD_BLND         /* blinds (glowing eye) */\n        AD_STUN         /* stuns */\n        AD_SLOW         /* slows */\n        AD_PLYS         /* paralyses */\n        AD_DRLI         /* drains life levels (Vampire) */\n        AD_DREN         /* drains magic energy */\n        AD_LEGS         /* damages legs (xan) */\n        AD_STON         /* petrifies (Medusa, Cockatrice) */\n        AD_STCK         /* sticks to you (Mimic) */\n        AD_SGLD         /* steals gold (Leppie) */\n        AD_SITM         /* steals item (Nymphs) */\n        AD_SEDU         /* seduces & steals multiple items */\n        AD_TLPT         /* teleports you (Quantum Mech.) */\n        AD_RUST         /* rusts armour (Rust Monster)*/\n        AD_CONF         /* confuses (Umber Hulk) */\n        AD_DGST         /* digests opponent (trapper, etc.) */\n        AD_HEAL         /* heals opponent's wounds (nurse) */\n        AD_WRAP         /* special \"stick\" for eels */\n        AD_WERE         /* confers lycanthropy */\n        AD_DRDX         /* drains dexterity (Quasit) */\n        AD_DRCO         /* drains constitution */\n        AD_DRIN         /* drains intelligence (mind flayer) */\n        AD_DISE         /* confers diseases */\n        AD_DCAY         /* decays organics (Brown pudding) */\n        AD_SSEX         /* Succubus seduction (extended) */\n        AD_DETH         /* for Death only */\n        AD_PEST         /* for Pestilence only */\n        AD_FAMN         /* for Famine only */\n        AD_CLRC         /* random clerical spell */\n        AD_SPEL         /* random magic spell */\n        AD_RBRE         /* random breath weapon */\n        AD_SAMU         /* hits, may steal Amulet (Wizard) */\n        AD_CURS         /* random curse (ex. gremlin) */\n\n      and the # dice/faces sets a range of damage:\n\n           i.e:   1,6     means a possible damage between 1 and 6,\n              but 3,7     means a possible damage between 3 and 21.\n\n      So, a monster can attack six times per turn at maximum. To attack less\n      times use the 'NO_ATTACK' entry.\n\n   -weight: (WT_HUMAN). Can be one of several defines like WT_DRAGON, WT_HUMAN,\n      WT_ELF, but also a direct number can be used.\n\n   -nutritional value: (400). The title says it all.\n\n   -extension length: (PL_NSIZ). Here comes a problem...This is the size of an\n      extra struct added to the normal permonst if the monster has any. For\n      example, shopkeepers have an extra struct used to manage the shop\n      code, dogs an extra to manage taming levels, etc... For the moment\n      forget about this part.\n\n   -sounds made: (MS_HUMAN). It is one of: (from monflag.h)\n\n        MS_SILENT       /* makes no sound */\n        MS_BARK         /* if full moon, may howl */\n        MS_MEW          /* mews or hisses */\n        MS_ROAR         /* roars */\n        MS_GROWL        /* growls */\n        MS_SQEEK        /* squeaks, as a rodent */\n        MS_SQAWK        /* squawks, as a bird */\n        MS_HISS         /* hisses */\n        MS_BUZZ         /* buzzes (killer bee) */\n        MS_GRUNT        /* grunts (or speaks own language) */\n        MS_NEIGH        /* neighs, as an equine */\n        MS_WAIL         /* wails, as a tortured soul */\n        MS_GURGLE       /* gurgles, as liquid or through saliva */\n        MS_BURBLE       /* burbles (jabberwock) */\n        MS_ANIMAL       /* up to here are animal noises */\n        MS_SHRIEK       /* wakes up others */\n        MS_BONES        /* rattles bones (skeleton) */\n        MS_LAUGH        /* grins, smiles, giggles, and laughs */\n        MS_MUMBLE       /* says something or other */\n        MS_IMITATE      /* imitates others (leocrotta) */\n        MS_ORC          /* intelligent brutes */\n        MS_HUMANOID     /* generic traveling companion */\n        MS_ARREST       /* \"Stop in the name of the law!\" (Kops) */\n        MS_SOLDIER      /* army and watchmen expressions */\n        MS_GUARD        /* \"Please drop that gold and follow me.\" */\n        MS_DJINNI       /* \"Thank you for freeing me!\" */\n        MS_NURSE        /* \"Take off your shirt, please.\" */\n        MS_SEDUCE       /* \"Hello, sailor.\" (Nymphs) */\n        MS_VAMPIRE      /* vampiric seduction, Vlad's exclamations */\n        MS_BRIBE        /* asks for money, or berates you */\n        MS_CUSS         /* berates (demons) or intimidates (Wiz) */\n        MS_RIDER        /* astral level special monsters */\n        MS_LEADER       /* your class leader */\n        MS_NEMESIS      /* your nemesis */\n        MS_GUARDIAN     /* your leader's guards */\n        MS_SELL         /* demand payment, complain about shoplifters */\n        MS_ORACLE       /* do a consultation */\n        MS_PRIEST       /* ask for contribution; do cleansing */\n\n\n   -physical size: (MZ_HUMAN). Is one of:\n\n        MZ_TINY         0               /* < 2' */\n        MZ_SMALL        1               /* 2-4' */\n        MZ_MEDIUM       2               /* 4-7' */\n        MZ_HUMAN        MZ_MEDIUM       /* human-sized */\n        MZ_LARGE        3               /* 7-12' */\n        MZ_HUGE         4               /* 12-25' */\n        MZ_GIGANTIC     7               /* off the scale */\n\n   -resistance conferred (randomly) when eaten: (0)\n\n        MR_FIRE         /* resists fire */\n        MR_COLD         /* resists cold */\n        MR_SLEEP        /* resists sleep */\n        MR_DISINT       /* resists disintegration */\n        MR_ELEC         /* resists atomicity */\n        MR_POISON       /* resists poison */\n        MR_ACID         /* resists acid */\n        MR_STONE        /* resists petrification */\n\n   -First group of flags: (specify the monster behaviour)\n          (M1_NEEDPICK | M1_HUMANOID | M1_OMNIVORE)\n\n        M1_FLY          /* can fly or float */\n        M1_SWIM         /* can traverse water */\n        M1_AMORPHOUS    /* can flow under doors */\n        M1_WALLWALK     /* can phase thru rock */\n        M1_CLING        /* can cling to ceiling */\n        M1_TUNNEL       /* can tunnel thru rock */\n        M1_NEEDPICK     /* needs pick to tunnel */\n        M1_CONCEAL      /* hides under objects */\n        M1_HIDE         /* mimics, blends in with ceiling */\n        M1_AMPHIBIOUS   /* can survive underwater */\n        M1_BREATHLESS   /* doesn't need to breathe */\n        M1_NOEYES       /* no eyes to gaze into or blind */\n        M1_NOHANDS      /* no hands to handle things */\n        M1_NOLIMBS      /* no arms/legs to kick/wear on */\n        M1_NOHEAD       /* no head to behead */\n        M1_MINDLESS     /* has no mind--golem, zombie, mold */\n        M1_HUMANOID     /* has humanoid head/arms/torso */\n        M1_ANIMAL       /* has animal body */\n        M1_SLITHY       /* has serpent body */\n        M1_UNSOLID      /* has no solid or liquid body */\n        M1_THICK_HIDE   /* has thick hide or scales */\n        M1_OVIPAROUS    /* can lay eggs */\n        M1_REGEN        /* regenerates hit points */\n        M1_SEE_INVIS    /* can see invisible creatures */\n        M1_TPORT        /* can teleport */\n        M1_TPORT_CNTRL  /* controls where it teleports to */\n        M1_ACID         /* acidic to eat */\n        M1_POIS         /* poisonous to eat */\n        M1_CARNIVORE    /* eats corpses */\n        M1_HERBIVORE    /* eats fruits */\n        M1_OMNIVORE     /* eats both */\n        M1_METALLIVORE  /* eats metal */\n\n\n   -Second group of flags: (specify more monster behaviour)\n        (M2_HUMAN | M2_STRONG | M2_COLLECT)\n\n        M2_NOPOLY       /* players mayn't poly into one */\n        M2_UNDEAD       /* is walking dead */\n        M2_WERE         /* is a lycanthrope */\n        M2_ELF          /* is an elf */\n        M2_DWARF        /* is a dwarf */\n        M2_GIANT        /* is a giant */\n        M2_ORC          /* is an orc */\n        M2_HUMAN        /* is a human */\n        M2_DEMON        /* is a demon */\n        M2_MERC         /* is a guard or soldier */\n        M2_LORD         /* is a lord to its kind */\n        M2_PRINCE       /* is an overlord to its kind */\n        M2_MINION       /* is a minion of a deity */\n        M2_MALE         /* always male */\n        M2_FEMALE       /* always female */\n        M2_NEUTER       /* neither male nor female */\n        M2_PNAME        /* monster name is a proper name */\n        M2_HOSTILE      /* always starts hostile */\n        M2_PEACEFUL     /* always starts peaceful */\n        M2_DOMESTIC     /* can be tamed by feeding */\n        M2_WANDER       /* wanders randomly */\n        M2_STALK        /* follows you to other levels */\n        M2_NASTY        /* extra-nasty monster (more xp) */\n        M2_STRONG       /* strong (or big) monster */\n        M2_ROCKTHROW    /* throws boulders */\n        M2_GREEDY       /* likes gold */\n        M2_JEWELS       /* likes gems */\n        M2_COLLECT      /* picks up weapons and food */\n        M2_MAGIC        /* picks up magic items */\n\n   -Third group of flags: (0) (specify even more monster behaviour)\n\n        M3_WANTSAMUL    /* would like to steal the amulet */\n        M3_WANTSBELL    /* wants the bell */\n        M3_WANTSBOOK    /* wants the book */\n        M3_WANTSCAND    /* wants the candelabrum */\n        M3_WANTSARTI    /* wants the quest artifact */\n        M3_WANTSALL     /* wants any major artifact */\n        M3_WANTSALL     /* wants any major artifact */\n        M3_WAITFORU     /* waits to see you or get attacked */\n        M3_CLOSE        /* lets you close unless attacked */\n        M3_COVETOUS     /* wants something */\n        M3_WAITMASK     /* waiting... */\n\n   -symbol color: (C(HI_DOMESTIC))\n\n        C(RED), C(BROWN), C(HI_DOMESTIC), etc...\n\n            (HI_DOMESTIC is the color for a peaceful monster).\n\n   You should also follow this rules, as the glorious dev team says:\n\n  \n        Rule #1:        monsters of a given class are contiguous in the\n                        mons[] array.\n  \n        Rule #2:        monsters of a given class are presented in ascending\n                        order of strength.\n  \n        Rule #3:        monster frequency is included in the geno mask;\n                        the frequency can be from 0 to 7.  0's will also\n                        be skipped during generation.\n  \n        Rule #4:        monster subclasses (e.g. giants) should be kept\n                        together, unless it violates Rule 2.  NOGEN monsters\n                        won't violate Rule 2.\n  \n  \n\n   And that's all. As usual it is easier to begin copying an existing monster.\n   For example if you want to create a stronger centaur, get the plain one\n   and change the AC and attack part.\n\n   Now you need to recompile the whole code. Yes, you read right: the WHOLE\n   CODE. The reason is this: the mons array sets a unique number for each\n   monster used later for reference it in the array. Did you saw a 'makedefs'\n   command while compiling? It is a vital part: generates #define for each\n   monster & object. So if you look at the pm.h file:\n\n\t/* This source file is generated by 'makedefs'.  Do not edit. */\n\t#ifndef PM_H\n\t#define PM_H\n\n\t#define PM_GIANT_ANT    0\n\t#define PM_KILLER_BEE   1\n\t#define PM_SOLDIER_ANT  2\n\t#define PM_FIRE_ANT     3\n\n   you understand now how it works: the sources can use the PM_SOMETHING\n   define to access the permonst struct of a 'something' monster without\n   knowing previously its location.\n\n   If you did set up make or ndmake correctly, make itself will take care of\n   the process of recompiling the code. Note that the *.des files are also\n   recompiled.\n\n   Now, to try out the new monster start nethack in wizard mode and wish for\n   a scroll of create monster. Read it and answer to create a 'your monster'\n   one. Voila! You now have your own monster.\n\n   IMPORTANT NOTE:\n      It is quite important to separate your own code with the appropriate\n   #ifdef, #ifndef statements. Just add the necessary #define SOMETHING \n   line at the end of include/config.h file.\n\n\n7. Refining your monster\n-------------------------\n\n   7.0. The 'monst' struct.\n\n   From the chapter 5 you now have a monster of your own wandering through\n   the dungeons. But surely you want more action: specific objects, armor\n   or weapon for him; concrete chatting sentences, etc... How can you\n   accomplish this? read on.\n\n   Now is the moment to introduce the 'monst' structure. This struct is what\n   defines a 'concrete' monster: hps, taming status, etc... very different\n   from the 'permonst' structure, where the capabilities of all monsters of\n   a type are defined. The elements in 'monst' are defined in monst.h:\n\n   -nmon: All monsters in current level are organized in a chained list. \n   Starting with a first monster descriptor ('fmon') you can navigate through\n   all of them, thanks to this pointer to the next monster:\n\n                    --------    --------   --------   --------\n            fmon -> | nmon ---> | nmon --->| nmon --->| nmon ---> NULL\n                    |      |    |      |   |      |   |      |\n                    | MONST|    | MONST|   | MONST|   | MONST|\n                    |  #1  |    |  #2  |   |  #3  |   |  #4  |\n                    --------    --------   --------   --------\n\n   -data: Is a pointer to the permonst structure for this monster. Obviously,\n   as the weight of a newt is permanent it doesn't make sense to keep it for\n   each concrete newt.\n\n   -m_id: unique number for a monster, asigned at creation time.\n\n   -mnum: Permanent monster index number. Number asigned by makedefs. That is,\n    the PM_NAME_OF_MONSTER #define in include file pm.h.  It is unique to this\n    type of monster.\n\n   -m_lev: Adjusted difficulty level of monster; that is, the level of a \n   monster can have changed from the default one (experience, potions,etc...)\n\n   -malign: Alignment of this monster, relative to the player. A positive\n   number means is good to kill it.\n\n   -mx, my: Position of the monster in the level map (x,y coordinates).\n\n   -mux,muy: Position in the map where the monster thinks player is. May be\n   different from actual one due to cloack of displacement, invisibility, etc.\n\n   -mtrack: Monster track???. Used in the movement routines, but I've no clear\n    idea of what it is.\n\n   -mappearance: For mimics & the wizard. How it looks to the player.\n\n   -m_ap_type: What mappearance is describing. Is one of:\n\tM_AP_NOTHING    0/*mappearance is unused --monster appears as itself */\n\tM_AP_FURNITURE  1/* stairs, a door, an altar, etc. */\n\tM_AP_OBJECT     2/* an object */\n\tM_AP_MONSTER    3/* a monster */\n\n   -mtame: Level of tameness. If greater than 0 monster is tamed, and also\n    implies peacefulness (as it doesn't make sense a tamed monster aggresive\n    to the player).\n\n   -mspec_used: Monster's special ability attack timeout. That is, monster \n   won't use its special ability -like dragon's breath- until this counter \n   reaches 0.\n\n   -female: 1 = yes, 0 = no.\n   -minvis: Monster is invisible. 1 = yes, 0 = no.\n   -cham: Monster is actually a chamaleon. 1 = yes, 0 = no.\n   -mundetected: Monster is hidden (as snakes) and hasn't been detected by\n   the player. 1 = yes, 0 = no.\n   -mcan: Monster has been zapped by a wand of cancellation (or spell).\n   -mspeed: Monster extra speed. 2 bits allow 4 possibilities.\n   -mflee: Monster is currently fleeing.\n   -mfleetim: (7 bits) timeout for that fleeing.\n   -mcansee/mblinded: monster can see / timeout for blinded.\n   -mcanmove/mfrozen: monster can move / timeout for frozen.\n   -msleep: monster is sleeping.\n   -mstun: monster is stunned.\n   -mconf: monster is confused.\n   -mpeaceful: monster is peaceful.\n   -mtrapped: monster is now trapped.\n   -mleashed: leashed is applied to it.\n   -isshk: This monster is a shopkeeper. \n   -isminion: Is a minion.\n   -isgd: is a guard.\n   -ispriest: is a priest.\n   -iswiz: is the wizard of Yendor.\n   -wormno: If a worm, this sets the number this one makes. (there can't be\n    more than 31 per level).\n   -mstrategy: Strategy to follow. (just applies to very special monsters).\n   -mtrapseen: bitmap of traps we've been trapped in.\n   -mlstmv: flag to prevent two moves at once (?). \n   -mgold: How rich this monster is.\n   -minvent: It points to a 'obj' struct. The objects a monster has are \n    organized in a chained list, the same as the 'monst' struct. This is\n    the beginning of that list. (obviously NULL if nothing being carried).\n   -mw: If the monster is wielding a weapon, here it is.\n   -misc_worn_check: Some obscure value for the worms code (?).\n   -weapon_check: Flag to check if monster has to get a weapon.\n   -mnamelth: Length of this monster PROPER name.\n   -mxlth: Length of the 'extra' part of the struct. It differs from monster\n    to monster. Most have any.\n   -meating: Monster is eating timeout.\n   -mextra: Allows access to the 'extra' part of the struct. Profusely used\n    with shopkeepers, for example.\n\n   \n   Uffff! I'm sure you're impressed with this big struct. Don't worry, you\n   don't have to deal with all the fields, at least at the beginning.\n\n   First thing you should have to do is answer this question: Does this monster\n   need any object or special ability not reflected in the M-FLAGS? If the \n   answer is yes, edit the file makemon.c and look for the 'm_initweap' \n   function.\n\n   (NOTE to UNIX users:\n\n   A few tools become invaluable in the process of looking for functions:\n\n     The 'ctags' command allows to create an index for objects; run the line\n\n\t\tctags *.c          (in the src directory)\n\n     this will create a 'tags' file. After that the command 'vi -t m_initweap'\n     will take you directly to the implementation of m_initweap function.\n\n     Also, the 'grep' command allows searching for a string. I.e. Wants to\n     have a look in the chamaleon code? Start looking the output for\n    \t\t grep -i chamaleon | more\n\n   End of NOTE)\n\n\n   The m_initweap function is where the monster gets the objects it needs. A\n   huge switch statement  (switch (mtmp->data->mlet) ) specify what it gets\n   according to its type. This is done with the 'mongets' function. (See\n   Apendix A for a complete listing of nearly 100 useful functions). \n\n   The easiest thing to do is search for a monster similar than ours and\n   copy the code. That way shouldn't be difficult to add a known object to\n   our monster. Note the usage of rn2() function to randomize the monsters\n   armors & weapon.\n\n   Really interesting monsters will have its own armor/weapon/object or type\n   of attack (if not, you will just get variations of standard monsters:\n   tougher newts, wimpy dragons, etc...). For adding a new object have a look\n   in the next section; Now we will see how to add new attacks or behaviours:\n\n\n   7.1. Adding a new attack type.\n\n   Edit the monattk.h file. Go after AT_TENT definition (in standard 3.1.3)\n   and add a line with something like:\n\n       #define AT_HELLO    16    /* Tries to kill you saying Hello */\n\n   This will be your new attack type. Now you have to define a new damage:\n   Put this line after the AD_FAMN definition:\n\n       #define AD_HELLO\t   39    /* You're saluted */\n\n\n   Now go to the src directory and edit the mhitu.c (monster-hits-user) file.\n   Inside the hitmsg() function you should add the code for your AT_HELLO\n   attack type. I.e: just add a line after \n\n                case AT_EXPL:\n                        pline(\"%s explodes!\", Monnam(mtmp));\n                        break;\n\n   like:\n\n                case AT_HELLO:\n                        pline(\"%s says hello to you!\", Monnam(mtmp));\n                        break;\n\n   Here we are introducing one of the most used function: pline() to show a\n   message to the screen (see apendix A for more information).\n\n   Later on look for the mattacku() function. You will have to add more code\n   for your AT_HELLO attack inside the 'switch(mattk->aatyp)'. Easiest is to\n   add a case to the 'hand to hand' attacks.\n\n   Now look for hitmu() function. There we have to add the code for AD_HELLO.\n   I.e., after \n\n            case AD_FAMN:\n                pline(\"%s reaches out, and your body shrivels.\",\n                        Monnam(mtmp));\n                exercise(A_CON, FALSE);\n                morehungry(rn1(40,40));\n                /* plus the normal damage */\n                break;\n\n   add\n\n            case AD_HELLO:\n                hitmsg(mtmp, mattk);\n\t\tmake_confused(2,FALSE);\n\t\tbreak;\n\n   so this new attack confuses you, a la umber hulk gaze.\n\n   That finished the editing for the mhitu.c file. Now do the same with mhitm.c\n   (monster- hits-monster), so a monster can attack another one with AT_HELLO.\n\n\n   7.2. Adding new monster's abilities\n\n   Within this chapter the method to add an action for a monster it is \n   explained. For example, let's add the code so a monster can read a\n   remove curse scroll.\n\n   Edit the muse.c file and look for the #define MUSE_WAN_SPEED_MONSTER 7\n   line. Add a new posibility:\n\n\t#define MUSE_SCR_SCARE_MONSTER 8\n\n   After that, inside the find_misc function look for:\n\n                if(obj->otyp == WAN_POLYMORPH && !mtmp->cham\n                                && monstr[(monsndx(mtmp->data))] < 6) {\n                        m.misc = obj;\n                        m.has_misc = MUSE_WAN_POLYMORPH;\n                }\n\n   and add:\n                if(obj->otyp == SCR_REMOVE_CURSE) {\n                        m.misc =obj;\n                        m.has_misc = MUSE_SCR_REMOVE_CURSE;\n                        }  \n\n   Now a monster is able to detect a remove curse scroll as a potential action.\n   Inside use_misc() we'll add the code to execute that action:\n\n   After the lines\n\n        case MUSE_WAN_POLYMORPH:\n                mzapmsg(mtmp, otmp, TRUE);\n                otmp->spe--;\n                (void) newcham(mtmp, rndmonst());\n                if (oseen) makeknown(WAN_POLYMORPH);\n                return 2;\n\n   Add\n\n        case MUSE_SCR_REMOVE_CURSE:\n                {\n                register struct obj *obj;\n                mreadmsg(mtmp,otmp);\n                pline(\"%s feels than someone is helping %s.\",Monnam(mtmp),\n                                 mtmp->female?\"her\":\"him\");\n                if (!otmp->cursed) {\n                   for(obj=mtmp->minvent;obj;obj=obj->nobj)\n                      if (otmp->blessed || obj->owornmask ||\n                         (obj->otyp == LOADSTONE)) {\n                            if (mtmp->mconf) blessorcurse(obj,2);\n                            else uncurse(obj);\n                            }\n                }\n                if (oseen && !objects[SCR_REMOVE_CURSE].oc_name_known\n                     && !objects[SCR_REMOVE_CURSE].oc_uname)\n                     docall(otmp); /* not makeknown() */\n                m_useup(mtmp, otmp);\n                return 2;\n                }\n\n\n   7.3. Adding a 'mextra' struct.\n\n   Real interesting monster behaviour needs the definition of new variables\n   in the monst struct. For example, suppose you want to add the possibility\n   to pray to god to your new monster; good idea would be to have a timeout\n   so the monster cannot pray every two turns. So, we could just add a new\n   element to the 'struct monst' in monst.h:\n\n\t\tlong praytime;\n\n   but that way EVERY MONSTER will have that variable defined, allocating\n   four bytes although only our new monster will use it.\n\n   Instead of that define a new struct - best in your own new include file-:\n\n\tstruct onlymymonster {\n\t\tlong praytime;\n\t};\n\n   and in the monster's definition in monst.c put 'sizeof(struct onlymymonster)'\n   as the extension length field. To refer to your new variable use this\n   contruction:\n\n\t\t((struct onlymymonster *)&(mon)->mextra[0])->praytime\n\n\t\t     (where mon is a pointer to a monst struct)\n\n   To abbreviate such a beast, use a #define:\n\n\t#define MYMONSTER(mon)   ((struct onlymymonster *)&(mon)->mextra[0])\n\n   so we can use \n\n\tMYMONSTER(mon)->praytime\n\n   Refer to the eshk.h file for an example of using a mextra part. (the\n   code for the shopkeepers).\n\n\n8. Adding a new object\n----------------------\n\n   8.1 The 'objects' array.\n\n   In chapter 6 I introduced you the mons[] array. Now it's the turn of the\n   'objects' array. It is a collection of structs objclass, being composed\n   of these elements: (from objclass.h)\n\n   oc_name_idx: actual name of the object.\n   oc_descr_idx: How the object is described when unknown (not identified).\n   oc_uname: Description given by the user (via the Call command).\n   oc_name_known: If 1, means the actual name is always showed.\n   oc_merge: If 1, merge otherwise equal objects.\n   oc_uses_known: Full description should be given.\n   oc_magic: It is a magical object.\n   oc_charged: This object may have charges.\n   oc_unique: This object is unique (amulet of Yendor, etc...)\n   oc_nowish: The player cannot wish for it.\n   oc_big: Big object.\n   oc_dir: Is it directional? Can be:\n\t\t\t\t\t   NODIR\n\t\t\t\t\t   IMMEDIATE\n\t\t\t\t\t   RAY\n   oc_material: What is it made of? Can be one of:\n\n\t   LIQUID\tWAX\t\tVEGGY\tFLESH\tPAPER\n\t   CLOTH\tLEATHER\t\tWOOD\tBONE\tDRAGON_HIDE\n\t   IRON\t\tMETAL\t\tCOPPER\tSILVER\tGOLD\n\t   PLATINUM\tMITHRIL\t\tPLASTIC\tGLASS\tGEMSTONE\n\t   MINERAL\n\n   oc_oprop: Properties conveyed by this object, i.e.: FIRE_RES, ANTIMAGIC,\n     etc...\n\n   oc_class: object class, i.e. WEAPON_CLASS, FOOD_CLASS, etc...\n   oc_delay: Delay when using such an object.\n   oc_color: Color of the object: Can be \n           BLACK\tRED\t\tGREEN\t\tBROWN\n\t   BLUE\t\tMAGENTA\t\tCYAN\t\tGRAY\n\t   NO_COLOR\tORANGE_COLORED\tBRIGHT_GREEN\tYELLOW\n\t   BRIGHT_BLUE\tBRIGHT_MAGENTA\tBRIGHT_CYAN\tWHITE\n\n       but also take note of this (from color.h):\n\n\t\t#define HI_OBJ          MAGENTA\n\t\t#define HI_METAL        CYAN\n\t\t#define HI_COPPER       YELLOW\n\t\t#define HI_SILVER       GRAY\n\t\t#define HI_GOLD         YELLOW\n\t\t#define HI_LEATHER      BROWN\n\t\t#define HI_CLOTH        BROWN\n\t\t#define HI_ORGANIC      BROWN\n\t\t#define HI_WOOD         BROWN\n\t\t#define HI_PAPER        WHITE\n\t\t#define HI_GLASS        BRIGHT_CYAN\n\t\t#define HI_MINERAL      GRAY\n\t\t#define HI_ZAP          BRIGHT_BLUE\n\n   oc_prob: probability of the object. The total sum of same class objects \n     should be 100.\n   oc_weight: its weight.\n   oc_cost: Base cost in shops. Actual price depends on charisma & hawaiian \n     shirts.\n   oc_wsdam:\n   oc_wldam: max small/large monster damage.\n   oc_oc1:\n   oc_oc2: Flags setting the +- something to the object. Its behaviour depends\n     on the class: for a weapon oc1 is the 'to hit' bonus while oc2 is a\n     negative value; for an armor, oc1 is the enchantment level & oc2 is the\n     - (rusting, etc...); for a spellbook oc2 is the spell level.\n   oc_nutrition: food value.\n\n   But for convenience, several \"#defines\" have been made so adding a certain\n   class of object is more direct. i.e:\n\n#define WEAPON(name,app,kn,mg,bi,prob,wt,cost,sdam,ldam,hitbon,metal,color) OBJE\nCT( \\\n                OBJ(name,app), BITS(kn,mg,1,0,0,1,0,0,bi,0,metal), 0, \\\n                WEAPON_CLASS, prob, 0, \\\n                wt, cost, sdam, ldam, hitbon, 0, wt, color )\n\n   allows to add a new weapon with the WEAPON macro, that sets several default\n   values common for all weapons.\n\n   There are macros for almost everything: WEAPON, FOOD, ARMOR, RING, etc...\n   Just use the one adequate in your case, keeping in mind:\n\n      - Put all common class objects together.\n      - Check the probabilities for the class.\n      - Easiest way is -as usual- copy an existing object and modify it.\n\n   Here there are some examples of entries:\n\n      ARMOR(\"Merlin's helm\", \"sharp-pointed cap\", 0, 1, 0, POLYMORPH_CONTROL,\n         0, 1, 10, 50,10, 0, CLOTH, BRIGHT_BLUE)\n\n      ARMOR(\"sport t-shirt\", NULL, 1, 0, 0, 0, 0, 0, 5, 3,10, 0, CLOTH, BLUE)\n\n      TOOL(\"self-compatible personal computer\",NULL,1, 0, 0, 0, 0,80,  200,\n         PLASTIC, GR AY)\n\n      FOOD(\"hamburger\",            0, 1,  8, 0, VEGGY, 300, BROWN)\n\n\n   That's all for the objects[] array. Now, depending of the class some files\n   should be touched; but first, some general recomendations:\n\n   a) Don't put your object as the first or last of its class: there are TONS\n   of code in the form:\n\n\t\tif ( (object > FIRST_OF_CLASS_X )\n\t\t   && (object < LAST_OF_CLASS_X ) )  \n\t\t   {   \n\t\t\t/* Assume object is of class x */\n\t\t   }\n\t\t   else \n\t\t        /* Print some strange fatal error */\n\n   b) Start with easy objects. Even better: add the object and put no effect\n   for it ---> the warning/error messages will inform you of the correct place\n   to edit.\n    Later put all the complicated things you have in mind, but start it simple.\n\n   c) There are some general functions that can be applied to all classes.\n   i.e: special effects when eating an object, cancelling it, dipping it, etc.\n   Here is a few hints for adding that:\n\n   - cancel_item() function, in zap.c, specifies what to do when cancelling.\n   - dodip() in potion.c, for special effects when dipping an object.\n   - eatspecial() in eat.c.\n   - dropy() in do.c, when dropping an object (i.e: a crysknife).\n\n   \n   8.1. Adding a tool\n\n   Your new added tool should have an effect when a)pplying it. That's defined\n   in the doapply() function, inside the apply.c file.\n   There is a huge switch depending on the object type (switch(obj->otyp));\n   note that different objects are referenced with its name in upper case; that\n   constant is generated by the makedefs command (remember?) in the onames.h\n   file. \n\n   What a tool does when applying is defined in its 'case'; if simple the\n   code is directly put there, if not a 'use_<tool-name>' function is defined\n   above. Studying such functions is a very good exercise, as they provide\n   lots of useful functions.\n\n\n   8.2. Adding a wand\n\n   A wand must have extra code in two ocasions: engraving with it and \n   -obviously- zapping it.\n\n   In engrave.c file we found the doengrave() function. There you should add\n   the appropiate 'case' entry and the message or code for anything you want.\n   Note the differences between directional & no directional wands.\n\n   In zap.c you should edit different functions depending also in the direc-\n   tional capability of your wand:\n\n      non-directional     --------- >  function zapnodir()\n\n      directional         --------- >  function bhitm() (wand hits monster).\n                              |---- >  function bhito() (wand hits object).\n                              |---- >  function zapyourself() (you, silly).\n\n\n   In general adding a wand it is more difficult than any other object.\n   Better start with something else.\n\n\n   8.3. Adding a potion\n\n   In this case look in file potion.c, for this functions:\n\n   peffects():  Describes what happens when potion is quaffed.\n\n   potionhit(): Describes what happens when potion hits a monster.\n\n   potionbreathe(): Potion vapors effect.\n\n   Also you'd like to edit the dodip() function where some special effects\n   can be added for dipping cases.\n\n\n   8.4. Adding armor/weapon\n\n   Unless you want some special feature, there is nothing to do.\n\n   Good place for adding code is function dmgval() in weapon.c: it adds\n   special damage bonuses for a certain weapon hitting a certain monster.\n\n\n   8.5. Adding a ring\n\n   Functions to look for in this case:\n\n   - dosinkring() in do.c. That describes the effects when dropping a ring\n    in a sink.\n\n   - Ring_on() in do_wear.c  What happens when a ring is put on.\n\n   - Ring_off_or_gone() in do_wear.c  The opposite way.\n\n   - eatring() in eat.c  Polymorphed player eats a ring.\n\n\n   8.6. Adding an amulet \n   \n   Quite similar to rings. Edit the functions Amulet_on() & Amulet_off in\n   do_wear.c\n\n\n   8.7. Adding a spellbook \n\n   First, in spell.c edit two functions:\n\n   study_book(): for learning a spell.\n   spelleffects(): for casting a spell.\n\n   As many spells behave like wands you may also have to edit the functions\n   bhitm(), bhito() & zapyourself() in zap.c, a la wand class.\n\n\n   8.8. Adding food\n\n   Just two functions here, both in eat.c\n\n   fprefx(): called when first bite of food.\n   fpostfx(): called when consumed food.\n\n   You should at least add the 'case' lines for the default behaviour.\n\n\n9. Creating a new room type\n---------------------------\n\n   To explain how to create a new room type, I will use an example: a clinic,\n   that is, a room full of nurses.\n\n   First of all, go to the include directory and edit the mkroom.h file. After\n   the line\n\t\t#define TEMPLE 10\n   add\n\t\t#define CLINIC 11\n\n   Look than then you'll have to increment the SHOPBASE & subsequents defines\n   to reflect the change, so MAXRTYPE becomes 22.\n\n   Now edit the rm.h file and after\n\t\tBitfield(is_cavernous_lev,1);\n\n   add\n\t\tBitfield(has_clinic,1);\n\n   so we can add a special message (for example an ambulance like sound) when\n   being in a level that has a clinic.\n\n   That's all for the include files. Go to the src directory and edit mkroom.c\n   Look for the mkroom() function and after the line\n\t\tcase BARRACKS:  mkzoo(BARRACKS); break;\n\n   add\n\t\tcase CLINIC:     mkzoo(CLINIC); break;\n\n   Take note that we are just adding a new non-shop room type, because the\n   previous mkshop() call if (roomtype >= SHOPBASE). We could define a \n   complete 'mkclinic()' function (see for example mktemple) but it is quite\n   simpler to use the mkzoo() code. That function will create a room and \n   fill it -function fill_zoo- with the appropiate monsters.\n\n   After that, we should edit the mkshop() function. Why? because in wizard\n   mode we could specify a room type to be created using the environment\n   variable SHOPTYPE. For example, if SHOPTYPE='G' starting nethack will\n   create a general shop in first level, 'Z' will create a zoo, etc... It is\n   not necessary, but certainly a good idea to add a new SHOPTYPE for our\n   new room, so we can test it quickly.\n\n   So, after \n\t\t\tif(*ep == 't' || *ep == 'T' || *ep == '\\\\'){\n                                mkzoo(COURT);\n                                return;\n                        }\n\n   put the following:\n\n                        if(*ep == 'c' || *ep == 'C'){\n                                mkzoo(CLINIC);\n                                return;\n                        }\n\n   Now go for the fill_zoo() itself. After\n\n\t        case ZOO:\n\t            goldlim = 500 * level_difficulty();\n\t\t    break;\n\n   just add\n\t\tcase CLINIC\n\t\t    break;\n\n   Now we have to select the monster to be created in our room. After\n\n  \t#ifdef ARMY\n                    \t(type == BARRACKS) ? squadmon() :\n\t#endif \n\n   Add\n\t\t\t(type == CLINIC) ? &mons[PM_NURSE]:\n\n   That is, if room type is CLINIC, monster to be created is a nurse. Several\n   things to note here: you can add a more complex function -see for example,\n   the courtmon() function- to select several monsters; also look how the\n   central point of the room is selected in other cases to create a special\n   monster -for example a queen bee in a beehive-.\n\n   If you want to add objects to the room, several lines after, you'll see:\n\n                    case BARRACKS:\n                        if(!rn2(20))    /* the payroll and some loot */\n                            (void) mksobj_at((rn2(3)) ? LARGE_BOX : CHEST,\n                                             sx, sy, TRUE);\n                        break;\n\n   That is, 1 in 20 make a large box or a chest. We could put something like:\n\n\t\t    case CLINIC:\n\t\t\tif(!rn2(10))\n\t\t\t    (void) mksobj_at(ICE_BOX,sx,sy,TRUE);\n\t\t\tbreak;\n\n   To create random ice boxes. It doesn't have to be a container, can be any\n   object you like.\n\n   Finally add a flag indicating that the level has a clinic:\n\n              case CLINIC:\n                  level.flags.has_clinic = 1;\n                  break;\n\n   You could now recompile and try out your new room using the SHOPTYPE \n   variable, but it will never generated in a normal dungeon. For that, we\n   have to edit mklev.c\n\n   First, at the beginning of the clear_level_structures() function add the\n   line:\n\t\tlevel.flags.has_clinic = 0;\n\n   so the flag is reset.\n\n   Later, look for the code:\n\n        if(depth(&u.uz) > 1 &&\n           depth(&u.uz) < depth(&medusa_level) &&\n           rn2(depth(&u.uz)) < 3) mkroom(SHOPBASE);\n        else if(depth(&u.uz) > 4 && !rn2(6)) mkroom(COURT);\n        else if(depth(&u.uz) > 6 && !rn2(7)) mkroom(ZOO);\n        else if(depth(&u.uz) > 8 && !rn2(5)) mkroom(TEMPLE);\n        else if(depth(&u.uz) > 9 && !rn2(5) &&\n           !(mons[PM_KILLER_BEE].geno & (G_GENOD | G_EXTINCT))) mkroom(BEEHIVE);\n        else if(depth(&u.uz) > 11 && !rn2(6)) mkroom(MORGUE);\n        else\n\n   As you can see, here is where is defined when a certain room can be genera-\n   ted: i.e. zoo's after level 6 one in 7 times, etc... So adding a line like\n   \n        if (depth(&u.uz) > 10 && !rn2(4)) mkroom(CLINIC)\n\n   will generate a clinic quite frecuently over dungeon level 10.\n\n\n   Next, edit the sounds.c file. Look for dosounds() and after\n\n\t#ifdef ARMY\n\t    if (level.flags.has_barracks && !rn2(200)) {\n\t\tstatic const char *barracks_msg[4] = {\n\t\t\t\"hear blades being honed.\",\n\t\t\t\"hear loud snoring.\",\n\t\t\t\"hear dice being thrown.\",\n\t\t\t\"hear General MacArthur!\",\n\t\t};\n\t\tYou(barracks_msg[rn2(3)+hallu]);\n\t\treturn;\n\t    }\n\t#endif /* ARMY */\n\n   add\n\t#ifdef CLINIC\n\t    if (level.flags.has_hospital && !rn2(200)) {\n\t\tstatic const char *hospital_msg[4] = {\n\t\t\t\"hear something about streptococus.\",\n\t\t\t\"smell chloroform nearby.\",\n\t\t\t\"hear someone cursing viruses.\",\n\t\t\t\"seem to hear Doctor Frankenstein.\",\n\t\t};\n\t\tYou(hospital_msg[rn2(3)+hallu]);\n\t\treturn;\n\t    }\n\t#endif /* CLINIC */\n\n   so we get a funny message randomly when having a clinic in level.\n\n   Last, edit hack.c and see check_special_room(), to add a salute to the\n   player entering a clinic:\n\n\t        case CLINIC:\n                    You(\"enter a modern hospital.\");\n                    break;\n\n   Also after\n\t#ifdef ARMY\n                            case BARRACKS:\n                                level.flags.has_barracks = 0;\n                                break;\n\t#endif\n\n   add\n\t#ifdef CLINIC\n                            case CLINIC:\n                                level.flags.has_clinic = 0;\n                                break;\n\t#endif\n\n   Last of all, edit sp_lev.c and after\n\t#ifdef ARMY\n\t\t    case BARRACKS:\n\t\t\tlevel.flags.has_barracks = TRUE;\n\t\t\tbreak;\n\t#endif\n   add\n\t#ifdef CLINIC\n\t\t    case CLINIC:\n\t\t\tlevel.flags.has_clinic = TRUE;\n\t\t\tbreak;\n\t#endif\n\n   inside the fill_room() function.\n\n   Recompile your code. Congratulations. You just added a new room.\n\n\n10. Creating a new shop type\n----------------------------\n\n   Along this chapter we will work to add a 'pet shop' as an example.\n\n   Adding a new shop is similar to adding a new room: we have to start with\n   the mkroom.h file. After the\n\t\n\t\t#define BOOKSHOP 20\n\n   line add \n\t\t#define PETSHOP 21\n\n   and increase the numbers for UNIQUESHOP, CANDLESHOP & MAXRTYPE. (of course\n   if you already added other rooms in chapter 9 put the correct number\n   accordingly).\n\n   Now edit the file shknam.c, where most of the shop code is located. First\n   thing you'll note is several 'static const char *shksomething[]' arrays;\n   those are the shopkeeper names for each type of shop. So, after the \n   definition of shkgeneral[], add a new array with the names for our petshops:\n\n   static const char *shkpetshop[] = {\n\t   \"Valoo\",\"Tisney\",\"Jakuna\",\n\t   \"\"\n\t   };\n\n   Note the array ends with a \"\" string. Also you should put more than 3 names,\n   but for our example is enough.\n\n   Later on the 'const struct shclass shtypes[]' array is defined. It sets\n   the shop types, with these fields:\n\n   - Name of the shop (i.e:\"general store\").\n   \n   - Letter that identifies this type of shop. (i.e: SCROLL_CLASS). It is\n    later used for the SHOPTYPE environment variable in wizard mode.\n\n   - % probability. Note that the total of all types should be 100, so for\n   adding a new one you'll have to low the probability of other(s).\n\n   - Object placement type:\n\t\tD_SCATTER = normal placement.\n\t\tD_SHOP    = shop-like placement.\n\t\tD_TEMPLE  = temple-like placement.\n\n   - Objects sold there, prefixed with the probability of each. i.e:\n\t {{85, RING_CLASS}, {10, GEM_CLASS}, {5, AMULET_CLASS}, {0, 0}}\n\n      means: rings (85% stock), gems(10%), amulets(5%). Note the NULL pair\n      at the end.\n      Also if defining a concrete object (instead of a class) a minus sign\n      is needed, as in:\n\t {{90, WAND_CLASS}, {5, -LEATHER_GLOVES}, {5, -ELVEN_CLOAK}, {0, 0}}\n\n      Note also that the array is defined (in mkroom.h) as 5 elements long,\n      so a shop cannot stock more than 5 classes/concrete objects. (You can\n      always increase that value as an alternative, of course).\n\n   - Names array -the shksomething array-.\n\n   So, in our case put something like:\n\n   {\"pet shop\", VENOM_CLASS, 5, D_SHOP,\n\t{{70, -FIGURINE},{20,-TRIPE_RATION},{10,-LEASH}}, shkpetshop}\n\n   meaning: create FIGURINES 70% of the time, 20% tripe rations & 10% leash.\n   Also this shop will be created if setting SHOPTYPE=\".\" or 5% of the time\n   a shop is created. The probability of the general store should be changed\n   from 44 to 39.\n\n   And that's all. Easy, isn't it?.\n\n   Just recompile the code and check it out setting:\n\n   export SHOPTYPE=.   (or set SHOPTYPE=. depending in your OS, or unix SHELL).\n   nethack -u wizard -D\n\n\n11. Goodbye\n-----------\n\n   Hundreds of other things can be added to the game, but this is the end;\n   from here you're on your own. I hope you found this reading useful. Just \n   some last recommendations:\n\n      1. Put lots of comments in your code. From experience, in a week or two\n        you'll forget why something was that way or the other.\n\n      2. Interchange information about new ideas in rec.games.roguelike.nethack\n        newsgroup. They can help you to refine your ideas or coming up with\n        new ones.\n\n      3. Send your modifications to the dev team (at the mail address \n        nethack-bugs@linc.cis.upenn.edu). You can possible win inmortality.\n\n      4. Play nethack a lot.\n\n\n   Good luck and happy hacking!!\n\n\n\n\t\t-------------------------------------\n\t\tApendix A. REFERENCE FUNCTION LISTING\n\t\t-------------------------------------\n\n   For your convenience here go some interesting functions: \n\nMonster naming functions\n------------------------\n\t\tThey all take a pointer to a monst structure as parameter and \n\t\treturn a string:\n\nchar *mon_nam(struct monst *)\n                the rust monster  it  the invisible orc  Fido\nchar *l_monnam(struct monst *)\n\t\trust monster    it  invisible orc      dog called fido\nchar *Monnam(struct monst *)\n\t\tThe rust monster    It  The invisible orc  Fido\nchar *Adjmonnam(struct monst *)\n\t\tThe poor rust monster  It  The poor invisible orc The poor Fido\nchar *Amonnam(struct monst *)\n\t\tA rust monster      It  An invisible orc   Fido\nchar *a_monnam(struct monst *)\n\t\ta rust monster      it  an invisible orc   Fido\n\n\nObject naming functions\n-----------------------\n\nchar *xname(struct obj *)\n\t\t\"poisoned arrow\"\nchar *doname(struct obj *)\n\t\t\"poisoned +0 arrow\"\nchar *an(struct obj *)\n\t\t\"a poisoned arrow\"\nchar *An(struct obj *)\n\t\t\"A poisoned arrow\"\nchar *The(struct obj *)\n\t\t\"The poisoned arrow\"\nchar *the(struct obj *)\n\t\t\"the poisoned arrow\"\nchar *makeplural(char *) \n\t\tTakes a string an pluralizes it. It is quite smart, \n\t\tso the \"homunculus\" plural becomes \"humunculi\", etc...\nchar *makesingular(char *) \n\t\tJust the opposite.\n\n\nDisplay functions\n-----------------\n\t\t(Please refer to the doc/window.doc file for more information).\n\npline(char *, ...)\n\t\tTakes the same arguments as the standard printf() function,\n\t\tand displays the result in the screen. It is massively used\n\t\tthroughout the code.\nYou(char *, ...)\n\t\tA shorter way to display the \"You do something\" messages.\n\t\tpline(\"You sit\") is equivalent to You(\"sit\").\nYour(char *, ...)\n\t\tA shorter way to display the \"Your something\" messages.\n\t\tpline(\"Your hands glow\") is equivalent to Your(\"hands glow\").\nverbalize(char *, ...)\n\t\tIt also behaves as printf(), but displays the resulting string\n\t\tbetween \"\". It is used for sounds made by other monsters.\nimpossible(char *, ...)\n\t\tDisplay an error message with the \"impossible:\" before it.\n\n\nSeveral object related functions\n--------------------------------\n\nstruct obj *readobjnam(char *)\n\t\tIt creates an object from a string. Mainly used in the\n\t\twishing routines.\nint weight(obj)\n\t\tReturns the weight of an object. (not obvious: it can be\n\t\ta container).\nvoid docall(struct obj *)\n\t\tAsk the player to call an object.\nmakeknown(obj->otyp)\n\t\tIt's not a real function, just a macro. Marks an object type\n\t\tas identified.\nvoid curse(struct obj *)\n\t\tCurses an object.\nvoid uncurse(struct obj *)\n\t\tUncurses an object.\nvoid bless(struct obj *)\n\t\tBlesses an object.\nvoid unbless(struct obj *)\n\t\tUnblesses an object.\nvoid move_object(struct obj *,int,int)\n\t\tMove object to x,y position.\nvoid remove_object(struct obj *)\n\t\tRemove object.\nvoid place_object(struct obj *,int,int)\n\t\tPut object in x,y position.\nint bhito(struct obj *, struct obj *)\n\t\tObject was hit by the effect of wand indicated in second \n\t\tparameter.\nvoid cancel_item(struct obj *)\n\t\tObject has been hit by cancellation ray.\n\n\nSeveral monster related functions\n---------------------------------\nstruct monst *newmonst(struct permonst *)\n\t\tAllocs a new 'monst' struct. It doesn't add it to the chained\n\t\tlist of monsters. Tipically the process will be:\n\t\t\tmtmp = newmonst(ptr->pxlth);\n\t\t\t*mtmp = zeromonst; /* clear all entries in structure */\n\t\t\tmtmp->nmon = fmon;\n\t\t\tfmon = mtmp;\n\t\tShouldn't be used directly. Better use makemon().\nstruct monst *makemon(struct permonst, int, int)\n\t\tCreates a new monster in the position determined by the two\n\t\tother parameters (x,y). It returns the newly created monst\n\t\tstruct if success, NULL otherwise.\n\t\tThe first parameter can be null; in that case a random monster\n\t\twill be created.\n\t\tThe (x,y) position can also be 0 to indicate a random location.\nvoid relmon(struct monst *mon)\n\t\tRelease monster from display and monster list.\nboolean mnearto(struct monst *,xchar, xchar, boolean)\n\t\tPut monster near (or at) location if possible. The boolean\n\t\tparameter is for forcing another one to move. Returns \n\t\t1 - if a monster was moved from x, y to put mtmp at x, y\n\t\t0 - in most cases.\nstruct permonst *grow_up(struct monst *, struct monst *)\n\t\tMonster grows up to a bigger version. The last monst struct\n\t\tparameter is the victim, if any. If there is none it implies\n\t\ta gain level potion.\nvoid mongone(struct monst *)\n\t\tMonster dissapears. The struct is released.\nvoid setmangry(struct monst *)\n\t\tMonster gets angry. If already was it, does nothing.\nboolean angry_guards(register boolean)\n\t\tFunction used to angry guards in town. The parameter just indi-\n\t\tcate to display messages if true. Returns TRUE if any guard\n\t\twas there.\nvoid pacify_guards()\n\t\tThe name says it all.\nvoid wake_up(struct monst *)\n\t\tWake up -and angry- a monster.\nvoid wake_nearby()\n\t\tWake up nearby monsters.\nvoid mon_to_stone(struct monst *)\n\t\tChanges the monster into a stone monster of the same type.\nboolean monnear(struct monst *, x, y)\n\t\tIs the square close enough for the monster to move or \n\t\tattack into?\nint minwater(struct monst *)\n\t\tCheck monster and water for compatibility, 0 (survived), \n\t\t1 (drowned)\nint rndmonnum()\n\t\tSelect a random, common monster type.\nSounds functions\n----------------\n\nvoid dosounds()\n\t\tMake a sound, depending of what is in current level (shop,\n\t\tthrones, etc...)\nvoid growl(struct monst *)\n\t\tMonster is happy.\nvoid yelp(struct monst *)\n\t\tMonster is not so happy.\nvoid whimper(struct monst *)\n\t\tMonster is about to die.\nvoid beg(struct monst *)\n\t\tMonster begs for food.\nint domonnoise(struct monst *)\n\t\tDo whatever sound a monster does.\nint dotalk()\n\t\tThe #chat command.\n\n\t\t\nMonsters<->objects functions\n----------------------------\n\nint mongets(struct monst *, int)\n\t\tIt creates an object and gives it to a monster. The int is\n\t\tthe identifier of the object as defined in onames.h (created\n\t\tby makedefs). i.e. BLUE_DRAGON_SCALE_MAIL\nvoid m_useup(struct monst *, struct obj *)\n\t\tAn object is consumed by a monster. The obj struct is freed.\nvoid mpickobj(struct monst *, struct obj *)\n\t\tAn object is picked by a monster.\nvoid mpickgems(struct monst *)\n\t\tA monster picks up the gems under him.\nvoid mpickgold(struct monst *)\n\t\tA monster picks up the gold under him.\nvoid mpickstuff(struct monst *)\n\t\tA monster picks up things under him. What it takes it depend\n\t\ton the M-FLAGS defined for this type of monster.\nvoid meatobj(struct monst *)\n\t\tMonster eats whatever in his position. Used for gelatinous\n\t\tcubes.\nvoid meatgold(struct monst *)\n\t\tA expensive meal :-)\nboolean can_carry(struct monst *, struct obj *)\n\t\tReturns TRUE if the monster can carry that object\nstruct obj *make_corpse(struct monst *)\n\t\tCreates a monster corpse, a \"special\" corpse, or nothing \n\t\tif it doesn't leave corpses.\n\nShop related functions\n----------------------\n\nstruct monst *shop_keeper(char rmno)\n\t\tReturns the shopkeeper given the room number. Example of usage:\n\t\t\tstruct monst *shkp;\n\t\t\tshkp=shop_keeper(*in_rooms(u.ux,u.uy,SHOPBASE));\nint inhishop(struct monst *)\n\t\tReturns true if shopkeeper is in his shop.\nvoid mkshobj_at(const struct shclass *,int,int)\n\t\tMake an object of the appropriate type in a shop square.\nint shkinit(const struct shclass *,struct mkroom *sroom)\n\t\tCreate a new shopkeeper in the given room.\nboolean saleable(int,struct obj *)\n\t\tReturns TRUE if the shop -indicated by the index - stocks that\n\t\ttype of objects.\n\nOther interesting functions\n---------------------------\n\nint rn2(int x)\n\t\tReturns a random number between 0 & x.\n\t\t( 0 <= rn2(x) < x )\nint rnl(int x)\n\t\tReturns a random number between 0 & x, just as rn2(), but\n\t\tthis time the player's luck affects the result: good luck\n\t\tapproaches 0, bad luck approaches x-1.\nchar *getrumor(int)\n\t\tReturns a \"rumor\" string. if int = 1 rumor is always true,\n\t\t-1 means false and 0 is random.\nvoid exercise(int, boolean)\n\t\tExercise an attribute (A_INT,A_CHA,A_WIS,A_STR,A_DEX). If\n\t\tTRUE increases, FALSE decreases.\nfind_misc() \nuse_misc()\n\t\tBoth functions are used in muse.c to detect an object/action\n\t\tthat a monster can do and execute it.\nvoid mkroom(int)\n\t\tMake and stock a room of a given type.\nboolean has_dnstairs(struct mkroom *)\n\t\tReturns true if room has downstairs.\nboolean has_upstairs(struct mkroom *)\n\t\tReturns true if room has upstairs.\nschar depth(d_level)\n\t\tReturns the depth of a level, in floors below the surface.\n\t\t(note levels in different dungeons can have the same depth).\ndoengrave()\n\t\tUser engraves.\nint bhitm(struct monst *, struct obj *)\n\t\tMonster was hit by the effect of wand or spell indicated\n\t\tin second parameter.\nint zapyourself(struct obj *)\n\t\tThe name says it all: player zapped himself with wand or spell.\nvoid zapnodir(struct obj *)\n\t\tZapping a non-directional wand.\nint breaks(struct obj *, boolean)\n\t\tObject breaks. The boolean flag indicates if object is or not\n\t\tin the fobj chain.\nint peffects(struct obj *)\n\t\tFunction for potion quaffing effects.\nvoid potionhit(struct monst *, struct obj *)\n\t\tPotion hits monster.\nvoid potionbreathe(struct obj *)\n\t\tVapors effects.\nvoid dosinkring(struct obj *)\n\t\tRing is dropped in a sink.\nvoid eatring(struct obj *)\n\t\tPolymorphed player eats a ring.\nvoid Ring_on(struct obj *)\n\t\tRing effects when on.\nvoid Ring_off_or_gone(struct obj *,boolean)\n\t\tRing is removed. The boolean flag indicates if gone (stolen).\nvoid Amulet_on()\nvoid Amulet_off()\n\t\tSimilar idea, but for amulets.\nvoid fprefx(struct obj *)\n\t\tCalled at first bite on food.\nvoid fpostfx(struct obj *)\n\t\tCalled after last bite on food.\nint study_book(struct obj *)\n\t\tStudy a spellbook.\nint spelleffects(struct obj *, boolean)\n\t\tCast a spell. boolean flag indicates if at player himself.\n```\n\n*This page is based on a spoiler by German Martin, available at <http://web.archive.org/web/20160802031704/http://members.shaw.ca/rob.ellwood/sources.txt>*\n\n[![This article is unlikely to require revision for the next version of NetHack. Click here for more information.](/images/5/58/Noversion.png)](/wiki/NetHackWiki:Next_version \"This article is unlikely to require revision for the next version of NetHack. Click here for more information.\")\n","html":"<!DOCTYPE html>\n<html class=\"client-nojs\" lang=\"en\" dir=\"ltr\">\n<head>\n<meta charset=\"UTF-8\"/>\n<title>Beginner's guide to NetHack sources - NetHack Wiki</title>\n<script>document.documentElement.className = document.documentElement.className.replace( /(^|\\s)client-nojs(\\s|$)/, \"$1client-js$2\" );</script>\n<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({\"wgCanonicalNamespace\":\"\",\"wgCanonicalSpecialPageName\":false,\"wgNamespaceNumber\":0,\"wgPageName\":\"Beginner's_guide_to_NetHack_sources\",\"wgTitle\":\"Beginner's guide to NetHack sources\",\"wgCurRevisionId\":105385,\"wgRevisionId\":105385,\"wgArticleId\":25421,\"wgIsArticle\":true,\"wgIsRedirect\":false,\"wgAction\":\"view\",\"wgUserName\":null,\"wgUserGroups\":[\"*\"],\"wgCategories\":[\"Spoiler files\"],\"wgBreakFrames\":false,\"wgPageContentLanguage\":\"en\",\"wgPageContentModel\":\"wikitext\",\"wgSeparatorTransformTable\":[\"\",\"\"],\"wgDigitTransformTable\":[\"\",\"\"],\"wgDefaultDateFormat\":\"dmy\",\"wgMonthNames\":[\"\",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],\"wgMonthNamesShort\":[\"\",\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],\"wgRelevantPageName\":\"Beginner's_guide_to_NetHack_sources\",\"wgRelevantArticleId\":25421,\"wgRequestId\":\"7bc3fcbd1ef5b33d3cd631af\",\"wgCSPNonce\":false,\"wgIsProbablyEditable\":false,\"wgRelevantPageIsProbablyEditable\":false,\"wgRestrictionEdit\":[\"sysop\"],\"wgRestrictionMove\":[\"sysop\"],\"wgWikiEditorEnabledModules\":[],\"wgCategoryTreePageCategoryOptions\":\"{\\\"mode\\\":0,\\\"hideprefix\\\":20,\\\"showcount\\\":true,\\\"namespaces\\\":false}\"});mw.loader.state({\"site.styles\":\"ready\",\"noscript\":\"ready\",\"user.styles\":\"ready\",\"user\":\"ready\",\"user.options\":\"ready\",\"user.tokens\":\"loading\",\"mediawiki.legacy.shared\":\"ready\",\"mediawiki.legacy.commonPrint\":\"ready\",\"mediawiki.skinning.interface\":\"ready\",\"skins.vector.styles\":\"ready\"});mw.loader.implement(\"user.tokens@0tffind\",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({\"editToken\":\"+\\\\\",\"patrolToken\":\"+\\\\\",\"watchToken\":\"+\\\\\",\"csrfToken\":\"+\\\\\"});\n});RLPAGEMODULES=[\"site\",\"mediawiki.page.startup\",\"mediawiki.user\",\"mediawiki.page.ready\",\"mediawiki.searchSuggest\",\"skins.vector.js\"];mw.loader.load(RLPAGEMODULES);});</script>\n<link rel=\"stylesheet\" href=\"/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector\"/>\n<script async=\"\" src=\"/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector\"></script>\n<meta name=\"ResourceLoaderDynamicStyles\" content=\"\"/>\n<link rel=\"stylesheet\" href=\"/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector\"/>\n<meta name=\"generator\" content=\"MediaWiki 1.32.5\"/>\n<link rel=\"image_src\" href=\"/images/6/65/Nethackwiki-logo.png\"/>\n<link rel=\"shortcut icon\" href=\"/images/6/64/Favicon.ico\"/>\n<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/opensearch_desc.php\" title=\"NetHackWiki\"/>\n<link rel=\"EditURI\" type=\"application/rsd+xml\" href=\"https://nethackwiki.com/api.php?action=rsd\"/>\n<link rel=\"canonical\" href=\"/wiki/Beginner%27s_guide_to_NetHack_sources\"/>\n<!--[if lt IE 9]><script src=\"/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=vector&amp;sync=1\"></script><![endif]-->\n</head>\n<body class=\"mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Beginner_s_guide_to_NetHack_sources rootpage-Beginner_s_guide_to_NetHack_sources skin-vector action-view\">\t\t<div id=\"mw-page-base\" class=\"noprint\"></div>\n\t\t<div id=\"mw-head-base\" class=\"noprint\"></div>\n\t\t<div id=\"content\" class=\"mw-body\" role=\"main\">\n\t\t\t<a id=\"top\"></a>\n\t\t\t<div class=\"mw-indicators mw-body-content\">\n</div>\n<h1 id=\"firstHeading\" class=\"firstHeading\" lang=\"en\">Beginner's guide to NetHack sources</h1>\t\t\t<div id=\"bodyContent\" class=\"mw-body-content\">\n\t\t\t\t<div id=\"siteSub\" class=\"noprint\">From NetHackWiki</div>\t\t\t\t<div id=\"contentSub\"></div>\n\t\t\t\t<div id=\"jump-to-nav\"></div>\t\t\t\t<a class=\"mw-jump-link\" href=\"#mw-head\">Jump to navigation</a>\n\t\t\t\t<a class=\"mw-jump-link\" href=\"#p-search\">Jump to search</a>\n\t\t\t\t<div id=\"mw-content-text\" lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\"><div class=\"mw-parser-output\"><p>This is a classic text <a href=\"/wiki/Spoiler\" title=\"Spoiler\">spoiler</a>, reproduced on NetHackWiki for reference and archival purposes. You should link to this page when you copy or excerpt it, but please do not modify the content.\n</p><p><b>Caution:</b> As this is not an ordinary wiki page edited by the community, this spoiler may contain outdated or otherwise inaccurate information.\n</p>\n<pre>\t BEGINNER'S GUIDE TO NETHACK SOURCES\n        ---------------------- by German Martin --\n                                        german@spain.hp.com\n\n                  \t\t   version 1.0  March '95\n\nContents\n--------\n\n   1. About this document.\n   2. Hey, I want to modify the game!\n   3. Starting point.\n   4. The wizard mode.\n   5. Creating a new level.\n   6. Creating a new monster.\n   7. Refining your monster.\n\t   7.0. The 'monst' struct.\n\t   7.1. Adding a new attack type.\n\t   7.2. Adding new monster's abilities.\n\t   7.3. Adding a 'mextra' struct.\n   8. Creating a new object.\n\t   8.0. The 'objects' array.\n\t   8.1. Adding a tool.\n\t   8.2. Adding a wand.\n\t   8.3. Adding a potion.\n\t   8.4. Adding armor/weapon.\n\t   8.5. Adding a ring.\n\t   8.6. Adding an amulet.\n\t   8.7. Adding a spellbook.\n\t   8.8. Adding food.\n   9. Creating a new room type.\n  10. Creating a new shop type.\n  11. Goodbye.\n  Apendix A. Reference Function listing\n\n\n1. About this document\n----------------------\n\n   Have you played - and enjoyed - nethack for several [ months | years ]&#160;?\n  Do you have some cool new ideas for the game but nobody seems to hear you?\n  Do you have access to a machine with a C compiler? Have you ever programmed\n  before?\n\n   If you answered yes to the above questions then this paper can be of your\n  interest.\n\n   Around middle '94 I started to look around in the nethack sources; loving\n  the game I really wanted to add some new monsters &amp; features, but the task\n  was quite painful. I'm not a C newbie, but 100 (actually more) source\n  files was more than I could manage: even trying to find the main() entry\n  to the code proved to be difficult. The help provided by the inlined \n  comments is useless for the newcomer. Now, nine months later, I've learned\n  a lot about the main structures in the code: I've been able to add new\n  monsters, objects, rooms, levels and behaviours. I - not being a member of\n  the Dev Team, in case you were wondered - don't pretend to have a full\n  knowledge of the huge beast, but my objective here is to help new ideas\n  to be added to the game, not being a complete guide to the code.\n\n   So, it is quite possible that you found many things incorrect here; more\n  than possible - that is, sure - that you found many things incomplete.\n  OK, send the bug/comment/addition to me and I'd modify/add it.\n\n   Please, USE THIS AT YOUR OWN RISK. If you get nothing but frustration don't\n  flame me: I was only trying to help.\n\n   All the documentation here refers to Nethack 3.1.3 (the current official\n  version at the date this is written).\n\n\n2. Hey, I want to modify the game!\n----------------------------------\n\n   OK. You have started to play nethack last week; got an account in a Unix\n  machine and thought \"Hey, I have a great idea! I'll learn C while modifying\n  this game! All I have to do is follow this cookbook!\". Forget it. Unless you\n  are a reincarnation of Leonardo da Vinci you'll get nothing but a headache.\n\n   In other words, to use this info you need at last:\n\n     - Few knowledge about the OS you are running in. That is, how to edit,\n      move, create and remove files basically.\n\n     - Good knowledge of the C programming language. That is, more than the\n      printf(\"Hello world\\n\") program. This includes the C preprocessor.\n\n     - A C compiler and feel comfortable with it.\n\n     - A blessed potion of gain ability.\n\n\n3. Starting point\n-----------------\n\n   The first thing you have to do is compile the sources by yourself. You\n   don't have to understand the whole process, but surely you need to be\n   able to compile the official code and get it running before you add any-\n   thing to the game. Refer to the README file in the top directory and to\n   the Install.XXX  (XXX depending of your operating system) in /sys/XXX\n   directory.\n\n   Once you have compiled the sources suddenly you are now aware of what\n   to expect.\n\n\n4. The wizard mode\n------------------\n   As you probably know, the wizard mode is a way to start nethack with a\n   few extra commands:\n\n\t\t^E  ==  detect secret doors and traps.\n\t\t^F  ==  do magic mapping.\n\t\t^G  ==  create monster.\n\t\t^I  ==  identify items in pack.\n\t\t^O  ==  tell locations of special levels.\n\t\t^T  ==  do intra-level teleport.\n\t\t^V  ==  do trans-level teleport.\n\t\t^W  ==  make wish.\n\t\t^X  ==  show intrinsic attributes.\n\n     plus some changes for known actions: i.e. read a scroll of create\n   monster allows to specify the type of monster.\n\n   That allows you to quickly try out the new feature/change you just added.\n   To start it, just type:\n\n                nethack -u wizard -D\n\n   It should work, but take present:\n\n   - If in a unix machine you should be the correct user-id.\n   - have a look in include/config.h and search for the #define WIZARD lines;\n    maybe you need to put another name after the -u.\n\n   Throughout your process of modifying nethack you should make extensible\n   usage of this mode so better make sure it works. (As an alternative you\n   can always play a complete game to try out your new monster in the astral\n   level&#160;:-) )\n\n\n\n5. Creating a new level\n-----------------------\n\n   To create a new level is easy. In fact, it doesn't require any knowledge\n   of C: the dev team prepared it for us.\n\n   Under the \"util\" directory the process of creating a nethack executable\n   should have left a program called 'lev_comp' (lev_comp.exe if in MS-DOS).\n   That binary is capable of create a new special level for nethack: give it\n   a description file (named &lt;something&gt;.des) and it gives you a level file\n   (named &lt;something&gt;.lev) suitable for the nethack binary:\n\n\n            mylevel.des -----------\n                                   |\n                                __ | __\n                                \\  V  /\n                              ___\\___/___\n                              |         | _\n                              |lev_comp |/\n                              |         |  -----&gt; mylevel.lev\n                              -------------\n\n   The lev_comp compiler has a manual page (have a look in the \"doc\" directory)\n   called 'lev_comp.6'. If you are in a unix machine a command like \n                          nroff -man lev_comp.6 | more\n   should give you a standard formatted man page. If not... well, you should\n   have to get used to the .SH .PP etc... garbage in the file. This man page\n   shows (quite obtusely) how to create a .des file; but better than starting\n   from scratch is starting trying to understand a predefined file.\n   For example, let's view the begining of \"dat/castle.des\" file:\n\n\tMAZE:\"castle\",random\n\tFLAGS: noteleport\n\tGEOMETRY:center,center\n\tMAP\n\t}}}}}}}}}.............................................}}}}}}}}}\n\t}-------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}\n\t}|.....|-----------------------------------------------|.....|}\n\t}|.....+...............................................+.....|}\n\t}-------------------------------+-----------------------------}\n\t}}}}}}|........|..........+...........|.......S.S.......|}}}}}}\n\t.....}|........|..........|...........|.......|.|.......|}.....\n\t.....}|........------------...........---------S---------}.....\n\t.....}|...{....+..........+.........\\.S.................+......\n\t.....}|........------------...........---------S---------}.....\n\t.....}|........|..........|...........|.......|.|.......|}.....\n\t}}}}}}|........|..........+...........|.......S.S.......|}}}}}}\n\t}-------------------------------+-----------------------------}\n\t}|.....+...............................................+.....|}\n\t}|.....|-----------------------------------------------|.....|}\n\t}-------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}\n\t}}}}}}}}}.............................................}}}}}}}}}\n\tENDMAP\n\n   Sounds familiar? This file is the description from where the castle\n   level is created. The part showed here just sets the level aspect: a\n   drawed castle centered between mazes (note the MAZE line). \n\n   The rest of the file puts doors, traps, objects and monsters in a random\n   or specific position (with coordinates relative to the previous map).\n\n   The man page describes the exact syntax, so if you dare you can now start\n   modifying the whole file; but let's make a very easy change and see how it\n   works: suppose you feel the soldiers at the castle are too wimpy and think\n   changing them to more difficult monsters, say minotaurs for example. So,\n   just change the lines:\n\n   MONSTER:'@',\"soldier\",(08,06) and subsequents\n\n   with\n\n   MONSTER:'H',\"minotaur\",(08,06) etc...\n\n   (Note that with this change we are chosing a specific monster. We could have\n   chosen to create monsters of a certain class, like\n\n   MONSTER:'D',RANDOM,(08,06)   # Create a random type dragon )\n\n   Save the new castle.des file and run: (from the dat directory)\n\n      ../util/lev_comp castle.des      (change the /'s with \\'s if in MS-DOS)\n\n   That creates a new 'castle.lev' file in the 'dat' directory. To try it,\n   copy it to the playing directory (something like games/nethack) and start\n   a game in wizard mode. Teleport to the castle, wish for a floating eye\n   corpse and a blindfold and have a look: you should have lots of brown H's!\n\n\n   But now it is time to deal with the original subject: we wanted to added\n   a NEW level to nethack, not just modifying one. Let the castle.des alone\n   and create a newlevel.des!\n\n   For that, we have to introduce a new compiler: dgn_comp, the dungeon\n   compiler. As the lev_comp it has a manual page: dgn_comp.6. Its purpose\n   is a step ahead: it takes a file describing the complete dungeon (as a\n   collection of levels) and creates a \"dungeon\" file suitable for the\n   nethack binary.\n\n   The description file in question is called \"dungeon.def\":\n\n\tDUNGEON:        \"The Dungeons of Doom\" \"D\" (25, 5)\n\tALIGNMENT:      unaligned\n\t%MULDGN BRANCH: \"The Gnomish Mines\" @ (2, 3)\n\t%REINCARNATION LEVEL:           \"rogue\" \"R\" @ (15, 4)\n\tLEVEL:          \"oracle\" \"O\" @ (5, 5)\n\tLEVALIGN:       neutral\n\tLEVEL:          \"bigroom\" \"B\" @ (10, 3) 15\n\t%MULDGN CHAINBRANCH:    \"The Quest\" \"oracle\" + (6, 2) portal\n\t%MULDGN BRANCH:         \"Fort Ludios\" @ (18, 4) portal\n\tRNDLEVEL:       \"medusa\" \"none\" @ (-5, 4) 2\n\tLEVALIGN:       chaotic\n\tLEVEL:          \"castle\" \"none\" @ (-1, 0)\n\tCHAINBRANCH:    \"Gehennom\" \"castle\" + (0, 0) no_down\n\tBRANCH:         \"The Elemental Planes\" @ (1, 0) no_down up\n\n   As you probably knew, there are 'levels' and branches of the main dungeon,\n   being composed of levels. The easiest thing is to add a simple level inside\n   the main dungeon: \n\n   Suppose you created a new mylevel.des file where you define a 'mylevel' \n   level:\n\n   MAZE:\"mylevel\",' '\n\n   (IMPORTANT note here: usually the file is named the same as the MAZE it\n   defines, as in castle.des, but the name for the .lev file is taken from\n   the MAZE line&#160;!!)\n\n   To add it to the main dungeon we can add a line after the bigroom one:\n\n   LEVEL:\t\"mylevel\" \"none\" @ (15,2)\n\n   That is, create the 'mylevel' level randomly at 15 +-2 level deep. The \n   level won't left bones files (the 'none' part).\n\n   And run ../util/dgn_comp dungeon.def  to get the 'dungeon' file. Copy it\n   to the game directory and try it out (wizard mode command Ctrl-O is quite\n   useful here).\n\n   If there is any error loading the new level, nethack will create a random\n   maze instead.\n\n   Finally, if we wanted to add a whole new branch to the dungeon, we will\n   put a line like:\n\n   %MULDGN BRANCH: \"newbranch\" @ (18, 1)\n   \n   and later on, the lines defining the levels in this new branch:\n\n   DUNGEON:        \"newbranch\" \"S\" (4,0)\n   DESCRIPTION:    mazelike\n   LEVEL:          \"mylevel1\" \"none\" @ (1, 0)\n   LEVEL:          \"mylevel2\" \"none\" @ (2, 0)\n   LEVEL:          \"mylevel3\" \"none\" @ (3, 0)\n   LEVEL:          \"mylevel4\" \"none\" @ (4, 0)\n\n\n   Now you should take a while and play around with the existing .des files\n   and become familiar with the syntax. Creating new levels and dungeon wasn't\n   difficult, was it?\n\n   Maybe this chapter covers all your needs; but if you really want \n   exciting new emotions, read on.\n\n\n6. Creating a new monster\n-------------------------\n\n      \"Beware, there will be no return! Still read? (y/n)\"\n      \n   Welcome to Darkness of Mordor... This is going to be painful but the\n   reward is great: some modification could be blessed by the dev team and\n   you will reach inmortality! And anyway, modifying nethack will give you\n   even happier hours than playing it.\n\n   So, let's cope with it:\n\n   For start, you should know that there are two HUGE arrays: one defining the\n   possible monsters and the other defining the possible objects. The first\n   one is called 'mons': it's an array of 'permonst' structs defined in the\n   file monst.c, under the src directory (by the way, after this point, I'll\n   stop saying where the files are located: you should be familiar with the\n   directory structure by now). The 'permonst' struct is defined in the\n   file permonst.h, and giving it a look should give you an idea of what \n   element of the struct is for, but, for your convenience here is an expla-\n   nation of what to put in a new entry for the mons array, i.e:\n\n\n        {\"myself\", S_HUMAN, 1, 10, 10, 0, 0, G_GENO | G_NOGEN,\n        { { AT_WEAP, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK,\n          NO_ATTK, NO_ATTK, NO_ATTK },\n        WT_HUMAN, 400, PL_NSIZ, MS_HUMANOID, MZ_HUMAN, 0, 0,\n        M1_NEEDPICK | M1_HUMANOID | M1_OMNIVORE,\n        M2_HUMAN | M2_STRONG | M2_COLLECT, 0, C(HI_DOMESTIC)}\n\n   -name: (\"myself\") is the name for the monster.\n\n   -symbol: (S_HUMAN) is the letter used for it. The complete list is defined\n\t  in the file monsym.h\n\n   -level: (1). The monster is initially created with this level.\n\n   -move rate: (10). Ranges from 0 -don't move- to 30 -really fast-.\n\n   -AC: (10). Come on! you now quite well what this is.\n\n   -magic resistance: (0). Ranges from 0 -none- to 127 -full-.\n\n   -alignment: (0). negative value means chaotic, positive lawful.\n\n   -creation/geno flags: (G_GENO | G_NOGEN) \n\tthese are flags or'ded, with this meaning:\n\n        G_UNIQ          /* generated only once */\n        G_NOHELL        /* not generated in \"hell\" */\n        G_HELL          /* generated only in \"hell\" */\n        G_NOGEN         /* generated only specially */\n        G_NOCORPSE      /* no corpse left ever */\n        G_SGROUP        /* appear in small groups normally */\n        G_LGROUP        /* appear in large groups normally */\n        G_GENO          /* can be genocided */\n        G_GENOD         /* have been genocided */\n        G_EXTINCT       /* have been extinguished as\n                           population control */\n        G_FREQ          /* creation frequency mask */\n\n                 (from monsym.h)\n\n   -attack: ({ { AT_WEAP, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK,\n           NO_ATTK, NO_ATTK, NO_ATTK },)\n      This defines how the monster attacks. This element is composed of six \n      'attack' struct, each one being the form:\n\n\t  ( attack_type, damage_type, # of dice, # of sides of each )\n\n      where attack_type is one of:\n\n        AT_NONE         /* passive monster (ex. acid blob) */\n        AT_CLAW         /* claw (punch, hit, etc.) */\n        AT_BITE         /* bite */\n        AT_KICK         /* kick */\n        AT_BUTT         /* head butt (ex. a unicorn) */\n        AT_TUCH         /* touches */\n        AT_STNG         /* sting */\n        AT_HUGS         /* crushing bearhug */\n        AT_SPIT         /* spits substance - ranged */\n        AT_ENGL         /* engulf (swallow or by a butt) */\n        AT_BREA         /* breath - ranged */\n        AT_EXPL         /* explodes - proximity */\n        AT_GAZE         /* gaze - ranged */\n        AT_TENT         /* tentacles */\n        AT_WEAP         /* uses weapon */\n        AT_MAGC         /* uses magic spell(s) */\n\n      damage_type is one of:\n\n        AD_PHYS         /* ordinary physical */\n        AD_MAGM         /* magic missiles */\n        AD_FIRE         /* fire damage */\n        AD_COLD         /* frost damage */\n        AD_SLEE         /* sleep ray */\n        AD_DISN         /* disintegration (death ray) */\n        AD_ELEC         /* shock damage */\n        AD_DRST         /* drains str (poison) */\n        AD_ACID         /* acid damage */\n        AD_SPC1         /* for extension of buzz() */\n        AD_SPC2         /* for extension of buzz() */\n        AD_BLND         /* blinds (glowing eye) */\n        AD_STUN         /* stuns */\n        AD_SLOW         /* slows */\n        AD_PLYS         /* paralyses */\n        AD_DRLI         /* drains life levels (Vampire) */\n        AD_DREN         /* drains magic energy */\n        AD_LEGS         /* damages legs (xan) */\n        AD_STON         /* petrifies (Medusa, Cockatrice) */\n        AD_STCK         /* sticks to you (Mimic) */\n        AD_SGLD         /* steals gold (Leppie) */\n        AD_SITM         /* steals item (Nymphs) */\n        AD_SEDU         /* seduces &amp; steals multiple items */\n        AD_TLPT         /* teleports you (Quantum Mech.) */\n        AD_RUST         /* rusts armour (Rust Monster)*/\n        AD_CONF         /* confuses (Umber Hulk) */\n        AD_DGST         /* digests opponent (trapper, etc.) */\n        AD_HEAL         /* heals opponent's wounds (nurse) */\n        AD_WRAP         /* special \"stick\" for eels */\n        AD_WERE         /* confers lycanthropy */\n        AD_DRDX         /* drains dexterity (Quasit) */\n        AD_DRCO         /* drains constitution */\n        AD_DRIN         /* drains intelligence (mind flayer) */\n        AD_DISE         /* confers diseases */\n        AD_DCAY         /* decays organics (Brown pudding) */\n        AD_SSEX         /* Succubus seduction (extended) */\n        AD_DETH         /* for Death only */\n        AD_PEST         /* for Pestilence only */\n        AD_FAMN         /* for Famine only */\n        AD_CLRC         /* random clerical spell */\n        AD_SPEL         /* random magic spell */\n        AD_RBRE         /* random breath weapon */\n        AD_SAMU         /* hits, may steal Amulet (Wizard) */\n        AD_CURS         /* random curse (ex. gremlin) */\n\n      and the # dice/faces sets a range of damage:\n\n           i.e:   1,6     means a possible damage between 1 and 6,\n              but 3,7     means a possible damage between 3 and 21.\n\n      So, a monster can attack six times per turn at maximum. To attack less\n      times use the 'NO_ATTACK' entry.\n\n   -weight: (WT_HUMAN). Can be one of several defines like WT_DRAGON, WT_HUMAN,\n      WT_ELF, but also a direct number can be used.\n\n   -nutritional value: (400). The title says it all.\n\n   -extension length: (PL_NSIZ). Here comes a problem...This is the size of an\n      extra struct added to the normal permonst if the monster has any. For\n      example, shopkeepers have an extra struct used to manage the shop\n      code, dogs an extra to manage taming levels, etc... For the moment\n      forget about this part.\n\n   -sounds made: (MS_HUMAN). It is one of: (from monflag.h)\n\n        MS_SILENT       /* makes no sound */\n        MS_BARK         /* if full moon, may howl */\n        MS_MEW          /* mews or hisses */\n        MS_ROAR         /* roars */\n        MS_GROWL        /* growls */\n        MS_SQEEK        /* squeaks, as a rodent */\n        MS_SQAWK        /* squawks, as a bird */\n        MS_HISS         /* hisses */\n        MS_BUZZ         /* buzzes (killer bee) */\n        MS_GRUNT        /* grunts (or speaks own language) */\n        MS_NEIGH        /* neighs, as an equine */\n        MS_WAIL         /* wails, as a tortured soul */\n        MS_GURGLE       /* gurgles, as liquid or through saliva */\n        MS_BURBLE       /* burbles (jabberwock) */\n        MS_ANIMAL       /* up to here are animal noises */\n        MS_SHRIEK       /* wakes up others */\n        MS_BONES        /* rattles bones (skeleton) */\n        MS_LAUGH        /* grins, smiles, giggles, and laughs */\n        MS_MUMBLE       /* says something or other */\n        MS_IMITATE      /* imitates others (leocrotta) */\n        MS_ORC          /* intelligent brutes */\n        MS_HUMANOID     /* generic traveling companion */\n        MS_ARREST       /* \"Stop in the name of the law!\" (Kops) */\n        MS_SOLDIER      /* army and watchmen expressions */\n        MS_GUARD        /* \"Please drop that gold and follow me.\" */\n        MS_DJINNI       /* \"Thank you for freeing me!\" */\n        MS_NURSE        /* \"Take off your shirt, please.\" */\n        MS_SEDUCE       /* \"Hello, sailor.\" (Nymphs) */\n        MS_VAMPIRE      /* vampiric seduction, Vlad's exclamations */\n        MS_BRIBE        /* asks for money, or berates you */\n        MS_CUSS         /* berates (demons) or intimidates (Wiz) */\n        MS_RIDER        /* astral level special monsters */\n        MS_LEADER       /* your class leader */\n        MS_NEMESIS      /* your nemesis */\n        MS_GUARDIAN     /* your leader's guards */\n        MS_SELL         /* demand payment, complain about shoplifters */\n        MS_ORACLE       /* do a consultation */\n        MS_PRIEST       /* ask for contribution; do cleansing */\n\n\n   -physical size: (MZ_HUMAN). Is one of:\n\n        MZ_TINY         0               /* &lt; 2' */\n        MZ_SMALL        1               /* 2-4' */\n        MZ_MEDIUM       2               /* 4-7' */\n        MZ_HUMAN        MZ_MEDIUM       /* human-sized */\n        MZ_LARGE        3               /* 7-12' */\n        MZ_HUGE         4               /* 12-25' */\n        MZ_GIGANTIC     7               /* off the scale */\n\n   -resistance conferred (randomly) when eaten: (0)\n\n        MR_FIRE         /* resists fire */\n        MR_COLD         /* resists cold */\n        MR_SLEEP        /* resists sleep */\n        MR_DISINT       /* resists disintegration */\n        MR_ELEC         /* resists atomicity */\n        MR_POISON       /* resists poison */\n        MR_ACID         /* resists acid */\n        MR_STONE        /* resists petrification */\n\n   -First group of flags: (specify the monster behaviour)\n          (M1_NEEDPICK | M1_HUMANOID | M1_OMNIVORE)\n\n        M1_FLY          /* can fly or float */\n        M1_SWIM         /* can traverse water */\n        M1_AMORPHOUS    /* can flow under doors */\n        M1_WALLWALK     /* can phase thru rock */\n        M1_CLING        /* can cling to ceiling */\n        M1_TUNNEL       /* can tunnel thru rock */\n        M1_NEEDPICK     /* needs pick to tunnel */\n        M1_CONCEAL      /* hides under objects */\n        M1_HIDE         /* mimics, blends in with ceiling */\n        M1_AMPHIBIOUS   /* can survive underwater */\n        M1_BREATHLESS   /* doesn't need to breathe */\n        M1_NOEYES       /* no eyes to gaze into or blind */\n        M1_NOHANDS      /* no hands to handle things */\n        M1_NOLIMBS      /* no arms/legs to kick/wear on */\n        M1_NOHEAD       /* no head to behead */\n        M1_MINDLESS     /* has no mind--golem, zombie, mold */\n        M1_HUMANOID     /* has humanoid head/arms/torso */\n        M1_ANIMAL       /* has animal body */\n        M1_SLITHY       /* has serpent body */\n        M1_UNSOLID      /* has no solid or liquid body */\n        M1_THICK_HIDE   /* has thick hide or scales */\n        M1_OVIPAROUS    /* can lay eggs */\n        M1_REGEN        /* regenerates hit points */\n        M1_SEE_INVIS    /* can see invisible creatures */\n        M1_TPORT        /* can teleport */\n        M1_TPORT_CNTRL  /* controls where it teleports to */\n        M1_ACID         /* acidic to eat */\n        M1_POIS         /* poisonous to eat */\n        M1_CARNIVORE    /* eats corpses */\n        M1_HERBIVORE    /* eats fruits */\n        M1_OMNIVORE     /* eats both */\n        M1_METALLIVORE  /* eats metal */\n\n\n   -Second group of flags: (specify more monster behaviour)\n        (M2_HUMAN | M2_STRONG | M2_COLLECT)\n\n        M2_NOPOLY       /* players mayn't poly into one */\n        M2_UNDEAD       /* is walking dead */\n        M2_WERE         /* is a lycanthrope */\n        M2_ELF          /* is an elf */\n        M2_DWARF        /* is a dwarf */\n        M2_GIANT        /* is a giant */\n        M2_ORC          /* is an orc */\n        M2_HUMAN        /* is a human */\n        M2_DEMON        /* is a demon */\n        M2_MERC         /* is a guard or soldier */\n        M2_LORD         /* is a lord to its kind */\n        M2_PRINCE       /* is an overlord to its kind */\n        M2_MINION       /* is a minion of a deity */\n        M2_MALE         /* always male */\n        M2_FEMALE       /* always female */\n        M2_NEUTER       /* neither male nor female */\n        M2_PNAME        /* monster name is a proper name */\n        M2_HOSTILE      /* always starts hostile */\n        M2_PEACEFUL     /* always starts peaceful */\n        M2_DOMESTIC     /* can be tamed by feeding */\n        M2_WANDER       /* wanders randomly */\n        M2_STALK        /* follows you to other levels */\n        M2_NASTY        /* extra-nasty monster (more xp) */\n        M2_STRONG       /* strong (or big) monster */\n        M2_ROCKTHROW    /* throws boulders */\n        M2_GREEDY       /* likes gold */\n        M2_JEWELS       /* likes gems */\n        M2_COLLECT      /* picks up weapons and food */\n        M2_MAGIC        /* picks up magic items */\n\n   -Third group of flags: (0) (specify even more monster behaviour)\n\n        M3_WANTSAMUL    /* would like to steal the amulet */\n        M3_WANTSBELL    /* wants the bell */\n        M3_WANTSBOOK    /* wants the book */\n        M3_WANTSCAND    /* wants the candelabrum */\n        M3_WANTSARTI    /* wants the quest artifact */\n        M3_WANTSALL     /* wants any major artifact */\n        M3_WANTSALL     /* wants any major artifact */\n        M3_WAITFORU     /* waits to see you or get attacked */\n        M3_CLOSE        /* lets you close unless attacked */\n        M3_COVETOUS     /* wants something */\n        M3_WAITMASK     /* waiting... */\n\n   -symbol color: (C(HI_DOMESTIC))\n\n        C(RED), C(BROWN), C(HI_DOMESTIC), etc...\n\n            (HI_DOMESTIC is the color for a peaceful monster).\n\n   You should also follow this rules, as the glorious dev team says:\n\n  \n        Rule #1:        monsters of a given class are contiguous in the\n                        mons[] array.\n  \n        Rule #2:        monsters of a given class are presented in ascending\n                        order of strength.\n  \n        Rule #3:        monster frequency is included in the geno mask;\n                        the frequency can be from 0 to 7.  0's will also\n                        be skipped during generation.\n  \n        Rule #4:        monster subclasses (e.g. giants) should be kept\n                        together, unless it violates Rule 2.  NOGEN monsters\n                        won't violate Rule 2.\n  \n  \n\n   And that's all. As usual it is easier to begin copying an existing monster.\n   For example if you want to create a stronger centaur, get the plain one\n   and change the AC and attack part.\n\n   Now you need to recompile the whole code. Yes, you read right: the WHOLE\n   CODE. The reason is this: the mons array sets a unique number for each\n   monster used later for reference it in the array. Did you saw a 'makedefs'\n   command while compiling? It is a vital part: generates #define for each\n   monster &amp; object. So if you look at the pm.h file:\n\n\t/* This source file is generated by 'makedefs'.  Do not edit. */\n\t#ifndef PM_H\n\t#define PM_H\n\n\t#define PM_GIANT_ANT    0\n\t#define PM_KILLER_BEE   1\n\t#define PM_SOLDIER_ANT  2\n\t#define PM_FIRE_ANT     3\n\n   you understand now how it works: the sources can use the PM_SOMETHING\n   define to access the permonst struct of a 'something' monster without\n   knowing previously its location.\n\n   If you did set up make or ndmake correctly, make itself will take care of\n   the process of recompiling the code. Note that the *.des files are also\n   recompiled.\n\n   Now, to try out the new monster start nethack in wizard mode and wish for\n   a scroll of create monster. Read it and answer to create a 'your monster'\n   one. Voila! You now have your own monster.\n\n   IMPORTANT NOTE:\n      It is quite important to separate your own code with the appropriate\n   #ifdef, #ifndef statements. Just add the necessary #define SOMETHING \n   line at the end of include/config.h file.\n\n\n7. Refining your monster\n-------------------------\n\n   7.0. The 'monst' struct.\n\n   From the chapter 5 you now have a monster of your own wandering through\n   the dungeons. But surely you want more action: specific objects, armor\n   or weapon for him; concrete chatting sentences, etc... How can you\n   accomplish this? read on.\n\n   Now is the moment to introduce the 'monst' structure. This struct is what\n   defines a 'concrete' monster: hps, taming status, etc... very different\n   from the 'permonst' structure, where the capabilities of all monsters of\n   a type are defined. The elements in 'monst' are defined in monst.h:\n\n   -nmon: All monsters in current level are organized in a chained list. \n   Starting with a first monster descriptor ('fmon') you can navigate through\n   all of them, thanks to this pointer to the next monster:\n\n                    --------    --------   --------   --------\n            fmon -&gt; | nmon ---&gt; | nmon ---&gt;| nmon ---&gt;| nmon ---&gt; NULL\n                    |      |    |      |   |      |   |      |\n                    | MONST|    | MONST|   | MONST|   | MONST|\n                    |  #1  |    |  #2  |   |  #3  |   |  #4  |\n                    --------    --------   --------   --------\n\n   -data: Is a pointer to the permonst structure for this monster. Obviously,\n   as the weight of a newt is permanent it doesn't make sense to keep it for\n   each concrete newt.\n\n   -m_id: unique number for a monster, asigned at creation time.\n\n   -mnum: Permanent monster index number. Number asigned by makedefs. That is,\n    the PM_NAME_OF_MONSTER #define in include file pm.h.  It is unique to this\n    type of monster.\n\n   -m_lev: Adjusted difficulty level of monster; that is, the level of a \n   monster can have changed from the default one (experience, potions,etc...)\n\n   -malign: Alignment of this monster, relative to the player. A positive\n   number means is good to kill it.\n\n   -mx, my: Position of the monster in the level map (x,y coordinates).\n\n   -mux,muy: Position in the map where the monster thinks player is. May be\n   different from actual one due to cloack of displacement, invisibility, etc.\n\n   -mtrack: Monster track???. Used in the movement routines, but I've no clear\n    idea of what it is.\n\n   -mappearance: For mimics &amp; the wizard. How it looks to the player.\n\n   -m_ap_type: What mappearance is describing. Is one of:\n\tM_AP_NOTHING    0/*mappearance is unused --monster appears as itself */\n\tM_AP_FURNITURE  1/* stairs, a door, an altar, etc. */\n\tM_AP_OBJECT     2/* an object */\n\tM_AP_MONSTER    3/* a monster */\n\n   -mtame: Level of tameness. If greater than 0 monster is tamed, and also\n    implies peacefulness (as it doesn't make sense a tamed monster aggresive\n    to the player).\n\n   -mspec_used: Monster's special ability attack timeout. That is, monster \n   won't use its special ability -like dragon's breath- until this counter \n   reaches 0.\n\n   -female: 1 = yes, 0 = no.\n   -minvis: Monster is invisible. 1 = yes, 0 = no.\n   -cham: Monster is actually a chamaleon. 1 = yes, 0 = no.\n   -mundetected: Monster is hidden (as snakes) and hasn't been detected by\n   the player. 1 = yes, 0 = no.\n   -mcan: Monster has been zapped by a wand of cancellation (or spell).\n   -mspeed: Monster extra speed. 2 bits allow 4 possibilities.\n   -mflee: Monster is currently fleeing.\n   -mfleetim: (7 bits) timeout for that fleeing.\n   -mcansee/mblinded: monster can see / timeout for blinded.\n   -mcanmove/mfrozen: monster can move / timeout for frozen.\n   -msleep: monster is sleeping.\n   -mstun: monster is stunned.\n   -mconf: monster is confused.\n   -mpeaceful: monster is peaceful.\n   -mtrapped: monster is now trapped.\n   -mleashed: leashed is applied to it.\n   -isshk: This monster is a shopkeeper. \n   -isminion: Is a minion.\n   -isgd: is a guard.\n   -ispriest: is a priest.\n   -iswiz: is the wizard of Yendor.\n   -wormno: If a worm, this sets the number this one makes. (there can't be\n    more than 31 per level).\n   -mstrategy: Strategy to follow. (just applies to very special monsters).\n   -mtrapseen: bitmap of traps we've been trapped in.\n   -mlstmv: flag to prevent two moves at once (?). \n   -mgold: How rich this monster is.\n   -minvent: It points to a 'obj' struct. The objects a monster has are \n    organized in a chained list, the same as the 'monst' struct. This is\n    the beginning of that list. (obviously NULL if nothing being carried).\n   -mw: If the monster is wielding a weapon, here it is.\n   -misc_worn_check: Some obscure value for the worms code (?).\n   -weapon_check: Flag to check if monster has to get a weapon.\n   -mnamelth: Length of this monster PROPER name.\n   -mxlth: Length of the 'extra' part of the struct. It differs from monster\n    to monster. Most have any.\n   -meating: Monster is eating timeout.\n   -mextra: Allows access to the 'extra' part of the struct. Profusely used\n    with shopkeepers, for example.\n\n   \n   Uffff! I'm sure you're impressed with this big struct. Don't worry, you\n   don't have to deal with all the fields, at least at the beginning.\n\n   First thing you should have to do is answer this question: Does this monster\n   need any object or special ability not reflected in the M-FLAGS? If the \n   answer is yes, edit the file makemon.c and look for the 'm_initweap' \n   function.\n\n   (NOTE to UNIX users:\n\n   A few tools become invaluable in the process of looking for functions:\n\n     The 'ctags' command allows to create an index for objects; run the line\n\n\t\tctags *.c          (in the src directory)\n\n     this will create a 'tags' file. After that the command 'vi -t m_initweap'\n     will take you directly to the implementation of m_initweap function.\n\n     Also, the 'grep' command allows searching for a string. I.e. Wants to\n     have a look in the chamaleon code? Start looking the output for\n    \t\t grep -i chamaleon | more\n\n   End of NOTE)\n\n\n   The m_initweap function is where the monster gets the objects it needs. A\n   huge switch statement  (switch (mtmp-&gt;data-&gt;mlet) ) specify what it gets\n   according to its type. This is done with the 'mongets' function. (See\n   Apendix A for a complete listing of nearly 100 useful functions). \n\n   The easiest thing to do is search for a monster similar than ours and\n   copy the code. That way shouldn't be difficult to add a known object to\n   our monster. Note the usage of rn2() function to randomize the monsters\n   armors &amp; weapon.\n\n   Really interesting monsters will have its own armor/weapon/object or type\n   of attack (if not, you will just get variations of standard monsters:\n   tougher newts, wimpy dragons, etc...). For adding a new object have a look\n   in the next section; Now we will see how to add new attacks or behaviours:\n\n\n   7.1. Adding a new attack type.\n\n   Edit the monattk.h file. Go after AT_TENT definition (in standard 3.1.3)\n   and add a line with something like:\n\n       #define AT_HELLO    16    /* Tries to kill you saying Hello */\n\n   This will be your new attack type. Now you have to define a new damage:\n   Put this line after the AD_FAMN definition:\n\n       #define AD_HELLO\t   39    /* You're saluted */\n\n\n   Now go to the src directory and edit the mhitu.c (monster-hits-user) file.\n   Inside the hitmsg() function you should add the code for your AT_HELLO\n   attack type. I.e: just add a line after \n\n                case AT_EXPL:\n                        pline(\"%s explodes!\", Monnam(mtmp));\n                        break;\n\n   like:\n\n                case AT_HELLO:\n                        pline(\"%s says hello to you!\", Monnam(mtmp));\n                        break;\n\n   Here we are introducing one of the most used function: pline() to show a\n   message to the screen (see apendix A for more information).\n\n   Later on look for the mattacku() function. You will have to add more code\n   for your AT_HELLO attack inside the 'switch(mattk-&gt;aatyp)'. Easiest is to\n   add a case to the 'hand to hand' attacks.\n\n   Now look for hitmu() function. There we have to add the code for AD_HELLO.\n   I.e., after \n\n            case AD_FAMN:\n                pline(\"%s reaches out, and your body shrivels.\",\n                        Monnam(mtmp));\n                exercise(A_CON, FALSE);\n                morehungry(rn1(40,40));\n                /* plus the normal damage */\n                break;\n\n   add\n\n            case AD_HELLO:\n                hitmsg(mtmp, mattk);\n\t\tmake_confused(2,FALSE);\n\t\tbreak;\n\n   so this new attack confuses you, a la umber hulk gaze.\n\n   That finished the editing for the mhitu.c file. Now do the same with mhitm.c\n   (monster- hits-monster), so a monster can attack another one with AT_HELLO.\n\n\n   7.2. Adding new monster's abilities\n\n   Within this chapter the method to add an action for a monster it is \n   explained. For example, let's add the code so a monster can read a\n   remove curse scroll.\n\n   Edit the muse.c file and look for the #define MUSE_WAN_SPEED_MONSTER 7\n   line. Add a new posibility:\n\n\t#define MUSE_SCR_SCARE_MONSTER 8\n\n   After that, inside the find_misc function look for:\n\n                if(obj-&gt;otyp == WAN_POLYMORPH &amp;&amp; !mtmp-&gt;cham\n                                &amp;&amp; monstr[(monsndx(mtmp-&gt;data))] &lt; 6) {\n                        m.misc = obj;\n                        m.has_misc = MUSE_WAN_POLYMORPH;\n                }\n\n   and add:\n                if(obj-&gt;otyp == SCR_REMOVE_CURSE) {\n                        m.misc =obj;\n                        m.has_misc = MUSE_SCR_REMOVE_CURSE;\n                        }  \n\n   Now a monster is able to detect a remove curse scroll as a potential action.\n   Inside use_misc() we'll add the code to execute that action:\n\n   After the lines\n\n        case MUSE_WAN_POLYMORPH:\n                mzapmsg(mtmp, otmp, TRUE);\n                otmp-&gt;spe--;\n                (void) newcham(mtmp, rndmonst());\n                if (oseen) makeknown(WAN_POLYMORPH);\n                return 2;\n\n   Add\n\n        case MUSE_SCR_REMOVE_CURSE:\n                {\n                register struct obj *obj;\n                mreadmsg(mtmp,otmp);\n                pline(\"%s feels than someone is helping %s.\",Monnam(mtmp),\n                                 mtmp-&gt;female?\"her\":\"him\");\n                if (!otmp-&gt;cursed) {\n                   for(obj=mtmp-&gt;minvent;obj;obj=obj-&gt;nobj)\n                      if (otmp-&gt;blessed || obj-&gt;owornmask ||\n                         (obj-&gt;otyp == LOADSTONE)) {\n                            if (mtmp-&gt;mconf) blessorcurse(obj,2);\n                            else uncurse(obj);\n                            }\n                }\n                if (oseen &amp;&amp; !objects[SCR_REMOVE_CURSE].oc_name_known\n                     &amp;&amp; !objects[SCR_REMOVE_CURSE].oc_uname)\n                     docall(otmp); /* not makeknown() */\n                m_useup(mtmp, otmp);\n                return 2;\n                }\n\n\n   7.3. Adding a 'mextra' struct.\n\n   Real interesting monster behaviour needs the definition of new variables\n   in the monst struct. For example, suppose you want to add the possibility\n   to pray to god to your new monster; good idea would be to have a timeout\n   so the monster cannot pray every two turns. So, we could just add a new\n   element to the 'struct monst' in monst.h:\n\n\t\tlong praytime;\n\n   but that way EVERY MONSTER will have that variable defined, allocating\n   four bytes although only our new monster will use it.\n\n   Instead of that define a new struct - best in your own new include file-:\n\n\tstruct onlymymonster {\n\t\tlong praytime;\n\t};\n\n   and in the monster's definition in monst.c put 'sizeof(struct onlymymonster)'\n   as the extension length field. To refer to your new variable use this\n   contruction:\n\n\t\t((struct onlymymonster *)&amp;(mon)-&gt;mextra[0])-&gt;praytime\n\n\t\t     (where mon is a pointer to a monst struct)\n\n   To abbreviate such a beast, use a #define:\n\n\t#define MYMONSTER(mon)   ((struct onlymymonster *)&amp;(mon)-&gt;mextra[0])\n\n   so we can use \n\n\tMYMONSTER(mon)-&gt;praytime\n\n   Refer to the eshk.h file for an example of using a mextra part. (the\n   code for the shopkeepers).\n\n\n8. Adding a new object\n----------------------\n\n   8.1 The 'objects' array.\n\n   In chapter 6 I introduced you the mons[] array. Now it's the turn of the\n   'objects' array. It is a collection of structs objclass, being composed\n   of these elements: (from objclass.h)\n\n   oc_name_idx: actual name of the object.\n   oc_descr_idx: How the object is described when unknown (not identified).\n   oc_uname: Description given by the user (via the Call command).\n   oc_name_known: If 1, means the actual name is always showed.\n   oc_merge: If 1, merge otherwise equal objects.\n   oc_uses_known: Full description should be given.\n   oc_magic: It is a magical object.\n   oc_charged: This object may have charges.\n   oc_unique: This object is unique (amulet of Yendor, etc...)\n   oc_nowish: The player cannot wish for it.\n   oc_big: Big object.\n   oc_dir: Is it directional? Can be:\n\t\t\t\t\t   NODIR\n\t\t\t\t\t   IMMEDIATE\n\t\t\t\t\t   RAY\n   oc_material: What is it made of? Can be one of:\n\n\t   LIQUID\tWAX\t\tVEGGY\tFLESH\tPAPER\n\t   CLOTH\tLEATHER\t\tWOOD\tBONE\tDRAGON_HIDE\n\t   IRON\t\tMETAL\t\tCOPPER\tSILVER\tGOLD\n\t   PLATINUM\tMITHRIL\t\tPLASTIC\tGLASS\tGEMSTONE\n\t   MINERAL\n\n   oc_oprop: Properties conveyed by this object, i.e.: FIRE_RES, ANTIMAGIC,\n     etc...\n\n   oc_class: object class, i.e. WEAPON_CLASS, FOOD_CLASS, etc...\n   oc_delay: Delay when using such an object.\n   oc_color: Color of the object: Can be \n           BLACK\tRED\t\tGREEN\t\tBROWN\n\t   BLUE\t\tMAGENTA\t\tCYAN\t\tGRAY\n\t   NO_COLOR\tORANGE_COLORED\tBRIGHT_GREEN\tYELLOW\n\t   BRIGHT_BLUE\tBRIGHT_MAGENTA\tBRIGHT_CYAN\tWHITE\n\n       but also take note of this (from color.h):\n\n\t\t#define HI_OBJ          MAGENTA\n\t\t#define HI_METAL        CYAN\n\t\t#define HI_COPPER       YELLOW\n\t\t#define HI_SILVER       GRAY\n\t\t#define HI_GOLD         YELLOW\n\t\t#define HI_LEATHER      BROWN\n\t\t#define HI_CLOTH        BROWN\n\t\t#define HI_ORGANIC      BROWN\n\t\t#define HI_WOOD         BROWN\n\t\t#define HI_PAPER        WHITE\n\t\t#define HI_GLASS        BRIGHT_CYAN\n\t\t#define HI_MINERAL      GRAY\n\t\t#define HI_ZAP          BRIGHT_BLUE\n\n   oc_prob: probability of the object. The total sum of same class objects \n     should be 100.\n   oc_weight: its weight.\n   oc_cost: Base cost in shops. Actual price depends on charisma &amp; hawaiian \n     shirts.\n   oc_wsdam:\n   oc_wldam: max small/large monster damage.\n   oc_oc1:\n   oc_oc2: Flags setting the +- something to the object. Its behaviour depends\n     on the class: for a weapon oc1 is the 'to hit' bonus while oc2 is a\n     negative value; for an armor, oc1 is the enchantment level &amp; oc2 is the\n     - (rusting, etc...); for a spellbook oc2 is the spell level.\n   oc_nutrition: food value.\n\n   But for convenience, several \"#defines\" have been made so adding a certain\n   class of object is more direct. i.e:\n\n#define WEAPON(name,app,kn,mg,bi,prob,wt,cost,sdam,ldam,hitbon,metal,color) OBJE\nCT( \\\n                OBJ(name,app), BITS(kn,mg,1,0,0,1,0,0,bi,0,metal), 0, \\\n                WEAPON_CLASS, prob, 0, \\\n                wt, cost, sdam, ldam, hitbon, 0, wt, color )\n\n   allows to add a new weapon with the WEAPON macro, that sets several default\n   values common for all weapons.\n\n   There are macros for almost everything: WEAPON, FOOD, ARMOR, RING, etc...\n   Just use the one adequate in your case, keeping in mind:\n\n      - Put all common class objects together.\n      - Check the probabilities for the class.\n      - Easiest way is -as usual- copy an existing object and modify it.\n\n   Here there are some examples of entries:\n\n      ARMOR(\"Merlin's helm\", \"sharp-pointed cap\", 0, 1, 0, POLYMORPH_CONTROL,\n         0, 1, 10, 50,10, 0, CLOTH, BRIGHT_BLUE)\n\n      ARMOR(\"sport t-shirt\", NULL, 1, 0, 0, 0, 0, 0, 5, 3,10, 0, CLOTH, BLUE)\n\n      TOOL(\"self-compatible personal computer\",NULL,1, 0, 0, 0, 0,80,  200,\n         PLASTIC, GR AY)\n\n      FOOD(\"hamburger\",            0, 1,  8, 0, VEGGY, 300, BROWN)\n\n\n   That's all for the objects[] array. Now, depending of the class some files\n   should be touched; but first, some general recomendations:\n\n   a) Don't put your object as the first or last of its class: there are TONS\n   of code in the form:\n\n\t\tif ( (object &gt; FIRST_OF_CLASS_X )\n\t\t   &amp;&amp; (object &lt; LAST_OF_CLASS_X ) )  \n\t\t   {   \n\t\t\t/* Assume object is of class x */\n\t\t   }\n\t\t   else \n\t\t        /* Print some strange fatal error */\n\n   b) Start with easy objects. Even better: add the object and put no effect\n   for it ---&gt; the warning/error messages will inform you of the correct place\n   to edit.\n    Later put all the complicated things you have in mind, but start it simple.\n\n   c) There are some general functions that can be applied to all classes.\n   i.e: special effects when eating an object, cancelling it, dipping it, etc.\n   Here is a few hints for adding that:\n\n   - cancel_item() function, in zap.c, specifies what to do when cancelling.\n   - dodip() in potion.c, for special effects when dipping an object.\n   - eatspecial() in eat.c.\n   - dropy() in do.c, when dropping an object (i.e: a crysknife).\n\n   \n   8.1. Adding a tool\n\n   Your new added tool should have an effect when a)pplying it. That's defined\n   in the doapply() function, inside the apply.c file.\n   There is a huge switch depending on the object type (switch(obj-&gt;otyp));\n   note that different objects are referenced with its name in upper case; that\n   constant is generated by the makedefs command (remember?) in the onames.h\n   file. \n\n   What a tool does when applying is defined in its 'case'; if simple the\n   code is directly put there, if not a 'use_&lt;tool-name&gt;' function is defined\n   above. Studying such functions is a very good exercise, as they provide\n   lots of useful functions.\n\n\n   8.2. Adding a wand\n\n   A wand must have extra code in two ocasions: engraving with it and \n   -obviously- zapping it.\n\n   In engrave.c file we found the doengrave() function. There you should add\n   the appropiate 'case' entry and the message or code for anything you want.\n   Note the differences between directional &amp; no directional wands.\n\n   In zap.c you should edit different functions depending also in the direc-\n   tional capability of your wand:\n\n      non-directional     --------- &gt;  function zapnodir()\n\n      directional         --------- &gt;  function bhitm() (wand hits monster).\n                              |---- &gt;  function bhito() (wand hits object).\n                              |---- &gt;  function zapyourself() (you, silly).\n\n\n   In general adding a wand it is more difficult than any other object.\n   Better start with something else.\n\n\n   8.3. Adding a potion\n\n   In this case look in file potion.c, for this functions:\n\n   peffects():  Describes what happens when potion is quaffed.\n\n   potionhit(): Describes what happens when potion hits a monster.\n\n   potionbreathe(): Potion vapors effect.\n\n   Also you'd like to edit the dodip() function where some special effects\n   can be added for dipping cases.\n\n\n   8.4. Adding armor/weapon\n\n   Unless you want some special feature, there is nothing to do.\n\n   Good place for adding code is function dmgval() in weapon.c: it adds\n   special damage bonuses for a certain weapon hitting a certain monster.\n\n\n   8.5. Adding a ring\n\n   Functions to look for in this case:\n\n   - dosinkring() in do.c. That describes the effects when dropping a ring\n    in a sink.\n\n   - Ring_on() in do_wear.c  What happens when a ring is put on.\n\n   - Ring_off_or_gone() in do_wear.c  The opposite way.\n\n   - eatring() in eat.c  Polymorphed player eats a ring.\n\n\n   8.6. Adding an amulet \n   \n   Quite similar to rings. Edit the functions Amulet_on() &amp; Amulet_off in\n   do_wear.c\n\n\n   8.7. Adding a spellbook \n\n   First, in spell.c edit two functions:\n\n   study_book(): for learning a spell.\n   spelleffects(): for casting a spell.\n\n   As many spells behave like wands you may also have to edit the functions\n   bhitm(), bhito() &amp; zapyourself() in zap.c, a la wand class.\n\n\n   8.8. Adding food\n\n   Just two functions here, both in eat.c\n\n   fprefx(): called when first bite of food.\n   fpostfx(): called when consumed food.\n\n   You should at least add the 'case' lines for the default behaviour.\n\n\n9. Creating a new room type\n---------------------------\n\n   To explain how to create a new room type, I will use an example: a clinic,\n   that is, a room full of nurses.\n\n   First of all, go to the include directory and edit the mkroom.h file. After\n   the line\n\t\t#define TEMPLE 10\n   add\n\t\t#define CLINIC 11\n\n   Look than then you'll have to increment the SHOPBASE &amp; subsequents defines\n   to reflect the change, so MAXRTYPE becomes 22.\n\n   Now edit the rm.h file and after\n\t\tBitfield(is_cavernous_lev,1);\n\n   add\n\t\tBitfield(has_clinic,1);\n\n   so we can add a special message (for example an ambulance like sound) when\n   being in a level that has a clinic.\n\n   That's all for the include files. Go to the src directory and edit mkroom.c\n   Look for the mkroom() function and after the line\n\t\tcase BARRACKS:  mkzoo(BARRACKS); break;\n\n   add\n\t\tcase CLINIC:     mkzoo(CLINIC); break;\n\n   Take note that we are just adding a new non-shop room type, because the\n   previous mkshop() call if (roomtype &gt;= SHOPBASE). We could define a \n   complete 'mkclinic()' function (see for example mktemple) but it is quite\n   simpler to use the mkzoo() code. That function will create a room and \n   fill it -function fill_zoo- with the appropiate monsters.\n\n   After that, we should edit the mkshop() function. Why? because in wizard\n   mode we could specify a room type to be created using the environment\n   variable SHOPTYPE. For example, if SHOPTYPE='G' starting nethack will\n   create a general shop in first level, 'Z' will create a zoo, etc... It is\n   not necessary, but certainly a good idea to add a new SHOPTYPE for our\n   new room, so we can test it quickly.\n\n   So, after \n\t\t\tif(*ep == 't' || *ep == 'T' || *ep == '\\\\'){\n                                mkzoo(COURT);\n                                return;\n                        }\n\n   put the following:\n\n                        if(*ep == 'c' || *ep == 'C'){\n                                mkzoo(CLINIC);\n                                return;\n                        }\n\n   Now go for the fill_zoo() itself. After\n\n\t        case ZOO:\n\t            goldlim = 500 * level_difficulty();\n\t\t    break;\n\n   just add\n\t\tcase CLINIC\n\t\t    break;\n\n   Now we have to select the monster to be created in our room. After\n\n  \t#ifdef ARMY\n                    \t(type == BARRACKS)&#160;? squadmon()&#160;:\n\t#endif \n\n   Add\n\t\t\t(type == CLINIC)&#160;? &amp;mons[PM_NURSE]:\n\n   That is, if room type is CLINIC, monster to be created is a nurse. Several\n   things to note here: you can add a more complex function -see for example,\n   the courtmon() function- to select several monsters; also look how the\n   central point of the room is selected in other cases to create a special\n   monster -for example a queen bee in a beehive-.\n\n   If you want to add objects to the room, several lines after, you'll see:\n\n                    case BARRACKS:\n                        if(!rn2(20))    /* the payroll and some loot */\n                            (void) mksobj_at((rn2(3))&#160;? LARGE_BOX&#160;: CHEST,\n                                             sx, sy, TRUE);\n                        break;\n\n   That is, 1 in 20 make a large box or a chest. We could put something like:\n\n\t\t    case CLINIC:\n\t\t\tif(!rn2(10))\n\t\t\t    (void) mksobj_at(ICE_BOX,sx,sy,TRUE);\n\t\t\tbreak;\n\n   To create random ice boxes. It doesn't have to be a container, can be any\n   object you like.\n\n   Finally add a flag indicating that the level has a clinic:\n\n              case CLINIC:\n                  level.flags.has_clinic = 1;\n                  break;\n\n   You could now recompile and try out your new room using the SHOPTYPE \n   variable, but it will never generated in a normal dungeon. For that, we\n   have to edit mklev.c\n\n   First, at the beginning of the clear_level_structures() function add the\n   line:\n\t\tlevel.flags.has_clinic = 0;\n\n   so the flag is reset.\n\n   Later, look for the code:\n\n        if(depth(&amp;u.uz) &gt; 1 &amp;&amp;\n           depth(&amp;u.uz) &lt; depth(&amp;medusa_level) &amp;&amp;\n           rn2(depth(&amp;u.uz)) &lt; 3) mkroom(SHOPBASE);\n        else if(depth(&amp;u.uz) &gt; 4 &amp;&amp; !rn2(6)) mkroom(COURT);\n        else if(depth(&amp;u.uz) &gt; 6 &amp;&amp; !rn2(7)) mkroom(ZOO);\n        else if(depth(&amp;u.uz) &gt; 8 &amp;&amp; !rn2(5)) mkroom(TEMPLE);\n        else if(depth(&amp;u.uz) &gt; 9 &amp;&amp; !rn2(5) &amp;&amp;\n           !(mons[PM_KILLER_BEE].geno &amp; (G_GENOD | G_EXTINCT))) mkroom(BEEHIVE);\n        else if(depth(&amp;u.uz) &gt; 11 &amp;&amp; !rn2(6)) mkroom(MORGUE);\n        else\n\n   As you can see, here is where is defined when a certain room can be genera-\n   ted: i.e. zoo's after level 6 one in 7 times, etc... So adding a line like\n   \n        if (depth(&amp;u.uz) &gt; 10 &amp;&amp; !rn2(4)) mkroom(CLINIC)\n\n   will generate a clinic quite frecuently over dungeon level 10.\n\n\n   Next, edit the sounds.c file. Look for dosounds() and after\n\n\t#ifdef ARMY\n\t    if (level.flags.has_barracks &amp;&amp; !rn2(200)) {\n\t\tstatic const char *barracks_msg[4] = {\n\t\t\t\"hear blades being honed.\",\n\t\t\t\"hear loud snoring.\",\n\t\t\t\"hear dice being thrown.\",\n\t\t\t\"hear General MacArthur!\",\n\t\t};\n\t\tYou(barracks_msg[rn2(3)+hallu]);\n\t\treturn;\n\t    }\n\t#endif /* ARMY */\n\n   add\n\t#ifdef CLINIC\n\t    if (level.flags.has_hospital &amp;&amp; !rn2(200)) {\n\t\tstatic const char *hospital_msg[4] = {\n\t\t\t\"hear something about streptococus.\",\n\t\t\t\"smell chloroform nearby.\",\n\t\t\t\"hear someone cursing viruses.\",\n\t\t\t\"seem to hear Doctor Frankenstein.\",\n\t\t};\n\t\tYou(hospital_msg[rn2(3)+hallu]);\n\t\treturn;\n\t    }\n\t#endif /* CLINIC */\n\n   so we get a funny message randomly when having a clinic in level.\n\n   Last, edit hack.c and see check_special_room(), to add a salute to the\n   player entering a clinic:\n\n\t        case CLINIC:\n                    You(\"enter a modern hospital.\");\n                    break;\n\n   Also after\n\t#ifdef ARMY\n                            case BARRACKS:\n                                level.flags.has_barracks = 0;\n                                break;\n\t#endif\n\n   add\n\t#ifdef CLINIC\n                            case CLINIC:\n                                level.flags.has_clinic = 0;\n                                break;\n\t#endif\n\n   Last of all, edit sp_lev.c and after\n\t#ifdef ARMY\n\t\t    case BARRACKS:\n\t\t\tlevel.flags.has_barracks = TRUE;\n\t\t\tbreak;\n\t#endif\n   add\n\t#ifdef CLINIC\n\t\t    case CLINIC:\n\t\t\tlevel.flags.has_clinic = TRUE;\n\t\t\tbreak;\n\t#endif\n\n   inside the fill_room() function.\n\n   Recompile your code. Congratulations. You just added a new room.\n\n\n10. Creating a new shop type\n----------------------------\n\n   Along this chapter we will work to add a 'pet shop' as an example.\n\n   Adding a new shop is similar to adding a new room: we have to start with\n   the mkroom.h file. After the\n\t\n\t\t#define BOOKSHOP 20\n\n   line add \n\t\t#define PETSHOP 21\n\n   and increase the numbers for UNIQUESHOP, CANDLESHOP &amp; MAXRTYPE. (of course\n   if you already added other rooms in chapter 9 put the correct number\n   accordingly).\n\n   Now edit the file shknam.c, where most of the shop code is located. First\n   thing you'll note is several 'static const char *shksomething[]' arrays;\n   those are the shopkeeper names for each type of shop. So, after the \n   definition of shkgeneral[], add a new array with the names for our petshops:\n\n   static const char *shkpetshop[] = {\n\t   \"Valoo\",\"Tisney\",\"Jakuna\",\n\t   \"\"\n\t   };\n\n   Note the array ends with a \"\" string. Also you should put more than 3 names,\n   but for our example is enough.\n\n   Later on the 'const struct shclass shtypes[]' array is defined. It sets\n   the shop types, with these fields:\n\n   - Name of the shop (i.e:\"general store\").\n   \n   - Letter that identifies this type of shop. (i.e: SCROLL_CLASS). It is\n    later used for the SHOPTYPE environment variable in wizard mode.\n\n   -&#160;% probability. Note that the total of all types should be 100, so for\n   adding a new one you'll have to low the probability of other(s).\n\n   - Object placement type:\n\t\tD_SCATTER = normal placement.\n\t\tD_SHOP    = shop-like placement.\n\t\tD_TEMPLE  = temple-like placement.\n\n   - Objects sold there, prefixed with the probability of each. i.e:\n\t {{85, RING_CLASS}, {10, GEM_CLASS}, {5, AMULET_CLASS}, {0, 0}}\n\n      means: rings (85% stock), gems(10%), amulets(5%). Note the NULL pair\n      at the end.\n      Also if defining a concrete object (instead of a class) a minus sign\n      is needed, as in:\n\t {{90, WAND_CLASS}, {5, -LEATHER_GLOVES}, {5, -ELVEN_CLOAK}, {0, 0}}\n\n      Note also that the array is defined (in mkroom.h) as 5 elements long,\n      so a shop cannot stock more than 5 classes/concrete objects. (You can\n      always increase that value as an alternative, of course).\n\n   - Names array -the shksomething array-.\n\n   So, in our case put something like:\n\n   {\"pet shop\", VENOM_CLASS, 5, D_SHOP,\n\t{{70, -FIGURINE},{20,-TRIPE_RATION},{10,-LEASH}}, shkpetshop}\n\n   meaning: create FIGURINES 70% of the time, 20% tripe rations &amp; 10% leash.\n   Also this shop will be created if setting SHOPTYPE=\".\" or 5% of the time\n   a shop is created. The probability of the general store should be changed\n   from 44 to 39.\n\n   And that's all. Easy, isn't it?.\n\n   Just recompile the code and check it out setting:\n\n   export SHOPTYPE=.   (or set SHOPTYPE=. depending in your OS, or unix SHELL).\n   nethack -u wizard -D\n\n\n11. Goodbye\n-----------\n\n   Hundreds of other things can be added to the game, but this is the end;\n   from here you're on your own. I hope you found this reading useful. Just \n   some last recommendations:\n\n      1. Put lots of comments in your code. From experience, in a week or two\n        you'll forget why something was that way or the other.\n\n      2. Interchange information about new ideas in rec.games.roguelike.nethack\n        newsgroup. They can help you to refine your ideas or coming up with\n        new ones.\n\n      3. Send your modifications to the dev team (at the mail address \n        nethack-bugs@linc.cis.upenn.edu). You can possible win inmortality.\n\n      4. Play nethack a lot.\n\n\n   Good luck and happy hacking!!\n\n\n\n\t\t-------------------------------------\n\t\tApendix A. REFERENCE FUNCTION LISTING\n\t\t-------------------------------------\n\n   For your convenience here go some interesting functions: \n\nMonster naming functions\n------------------------\n\t\tThey all take a pointer to a monst structure as parameter and \n\t\treturn a string:\n\nchar *mon_nam(struct monst *)\n                the rust monster  it  the invisible orc  Fido\nchar *l_monnam(struct monst *)\n\t\trust monster    it  invisible orc      dog called fido\nchar *Monnam(struct monst *)\n\t\tThe rust monster    It  The invisible orc  Fido\nchar *Adjmonnam(struct monst *)\n\t\tThe poor rust monster  It  The poor invisible orc The poor Fido\nchar *Amonnam(struct monst *)\n\t\tA rust monster      It  An invisible orc   Fido\nchar *a_monnam(struct monst *)\n\t\ta rust monster      it  an invisible orc   Fido\n\n\nObject naming functions\n-----------------------\n\nchar *xname(struct obj *)\n\t\t\"poisoned arrow\"\nchar *doname(struct obj *)\n\t\t\"poisoned +0 arrow\"\nchar *an(struct obj *)\n\t\t\"a poisoned arrow\"\nchar *An(struct obj *)\n\t\t\"A poisoned arrow\"\nchar *The(struct obj *)\n\t\t\"The poisoned arrow\"\nchar *the(struct obj *)\n\t\t\"the poisoned arrow\"\nchar *makeplural(char *) \n\t\tTakes a string an pluralizes it. It is quite smart, \n\t\tso the \"homunculus\" plural becomes \"humunculi\", etc...\nchar *makesingular(char *) \n\t\tJust the opposite.\n\n\nDisplay functions\n-----------------\n\t\t(Please refer to the doc/window.doc file for more information).\n\npline(char *, ...)\n\t\tTakes the same arguments as the standard printf() function,\n\t\tand displays the result in the screen. It is massively used\n\t\tthroughout the code.\nYou(char *, ...)\n\t\tA shorter way to display the \"You do something\" messages.\n\t\tpline(\"You sit\") is equivalent to You(\"sit\").\nYour(char *, ...)\n\t\tA shorter way to display the \"Your something\" messages.\n\t\tpline(\"Your hands glow\") is equivalent to Your(\"hands glow\").\nverbalize(char *, ...)\n\t\tIt also behaves as printf(), but displays the resulting string\n\t\tbetween \"\". It is used for sounds made by other monsters.\nimpossible(char *, ...)\n\t\tDisplay an error message with the \"impossible:\" before it.\n\n\nSeveral object related functions\n--------------------------------\n\nstruct obj *readobjnam(char *)\n\t\tIt creates an object from a string. Mainly used in the\n\t\twishing routines.\nint weight(obj)\n\t\tReturns the weight of an object. (not obvious: it can be\n\t\ta container).\nvoid docall(struct obj *)\n\t\tAsk the player to call an object.\nmakeknown(obj-&gt;otyp)\n\t\tIt's not a real function, just a macro. Marks an object type\n\t\tas identified.\nvoid curse(struct obj *)\n\t\tCurses an object.\nvoid uncurse(struct obj *)\n\t\tUncurses an object.\nvoid bless(struct obj *)\n\t\tBlesses an object.\nvoid unbless(struct obj *)\n\t\tUnblesses an object.\nvoid move_object(struct obj *,int,int)\n\t\tMove object to x,y position.\nvoid remove_object(struct obj *)\n\t\tRemove object.\nvoid place_object(struct obj *,int,int)\n\t\tPut object in x,y position.\nint bhito(struct obj *, struct obj *)\n\t\tObject was hit by the effect of wand indicated in second \n\t\tparameter.\nvoid cancel_item(struct obj *)\n\t\tObject has been hit by cancellation ray.\n\n\nSeveral monster related functions\n---------------------------------\nstruct monst *newmonst(struct permonst *)\n\t\tAllocs a new 'monst' struct. It doesn't add it to the chained\n\t\tlist of monsters. Tipically the process will be:\n\t\t\tmtmp = newmonst(ptr-&gt;pxlth);\n\t\t\t*mtmp = zeromonst; /* clear all entries in structure */\n\t\t\tmtmp-&gt;nmon = fmon;\n\t\t\tfmon = mtmp;\n\t\tShouldn't be used directly. Better use makemon().\nstruct monst *makemon(struct permonst, int, int)\n\t\tCreates a new monster in the position determined by the two\n\t\tother parameters (x,y). It returns the newly created monst\n\t\tstruct if success, NULL otherwise.\n\t\tThe first parameter can be null; in that case a random monster\n\t\twill be created.\n\t\tThe (x,y) position can also be 0 to indicate a random location.\nvoid relmon(struct monst *mon)\n\t\tRelease monster from display and monster list.\nboolean mnearto(struct monst *,xchar, xchar, boolean)\n\t\tPut monster near (or at) location if possible. The boolean\n\t\tparameter is for forcing another one to move. Returns \n\t\t1 - if a monster was moved from x, y to put mtmp at x, y\n\t\t0 - in most cases.\nstruct permonst *grow_up(struct monst *, struct monst *)\n\t\tMonster grows up to a bigger version. The last monst struct\n\t\tparameter is the victim, if any. If there is none it implies\n\t\ta gain level potion.\nvoid mongone(struct monst *)\n\t\tMonster dissapears. The struct is released.\nvoid setmangry(struct monst *)\n\t\tMonster gets angry. If already was it, does nothing.\nboolean angry_guards(register boolean)\n\t\tFunction used to angry guards in town. The parameter just indi-\n\t\tcate to display messages if true. Returns TRUE if any guard\n\t\twas there.\nvoid pacify_guards()\n\t\tThe name says it all.\nvoid wake_up(struct monst *)\n\t\tWake up -and angry- a monster.\nvoid wake_nearby()\n\t\tWake up nearby monsters.\nvoid mon_to_stone(struct monst *)\n\t\tChanges the monster into a stone monster of the same type.\nboolean monnear(struct monst *, x, y)\n\t\tIs the square close enough for the monster to move or \n\t\tattack into?\nint minwater(struct monst *)\n\t\tCheck monster and water for compatibility, 0 (survived), \n\t\t1 (drowned)\nint rndmonnum()\n\t\tSelect a random, common monster type.\nSounds functions\n----------------\n\nvoid dosounds()\n\t\tMake a sound, depending of what is in current level (shop,\n\t\tthrones, etc...)\nvoid growl(struct monst *)\n\t\tMonster is happy.\nvoid yelp(struct monst *)\n\t\tMonster is not so happy.\nvoid whimper(struct monst *)\n\t\tMonster is about to die.\nvoid beg(struct monst *)\n\t\tMonster begs for food.\nint domonnoise(struct monst *)\n\t\tDo whatever sound a monster does.\nint dotalk()\n\t\tThe #chat command.\n\n\t\t\nMonsters&lt;-&gt;objects functions\n----------------------------\n\nint mongets(struct monst *, int)\n\t\tIt creates an object and gives it to a monster. The int is\n\t\tthe identifier of the object as defined in onames.h (created\n\t\tby makedefs). i.e. BLUE_DRAGON_SCALE_MAIL\nvoid m_useup(struct monst *, struct obj *)\n\t\tAn object is consumed by a monster. The obj struct is freed.\nvoid mpickobj(struct monst *, struct obj *)\n\t\tAn object is picked by a monster.\nvoid mpickgems(struct monst *)\n\t\tA monster picks up the gems under him.\nvoid mpickgold(struct monst *)\n\t\tA monster picks up the gold under him.\nvoid mpickstuff(struct monst *)\n\t\tA monster picks up things under him. What it takes it depend\n\t\ton the M-FLAGS defined for this type of monster.\nvoid meatobj(struct monst *)\n\t\tMonster eats whatever in his position. Used for gelatinous\n\t\tcubes.\nvoid meatgold(struct monst *)\n\t\tA expensive meal&#160;:-)\nboolean can_carry(struct monst *, struct obj *)\n\t\tReturns TRUE if the monster can carry that object\nstruct obj *make_corpse(struct monst *)\n\t\tCreates a monster corpse, a \"special\" corpse, or nothing \n\t\tif it doesn't leave corpses.\n\nShop related functions\n----------------------\n\nstruct monst *shop_keeper(char rmno)\n\t\tReturns the shopkeeper given the room number. Example of usage:\n\t\t\tstruct monst *shkp;\n\t\t\tshkp=shop_keeper(*in_rooms(u.ux,u.uy,SHOPBASE));\nint inhishop(struct monst *)\n\t\tReturns true if shopkeeper is in his shop.\nvoid mkshobj_at(const struct shclass *,int,int)\n\t\tMake an object of the appropriate type in a shop square.\nint shkinit(const struct shclass *,struct mkroom *sroom)\n\t\tCreate a new shopkeeper in the given room.\nboolean saleable(int,struct obj *)\n\t\tReturns TRUE if the shop -indicated by the index - stocks that\n\t\ttype of objects.\n\nOther interesting functions\n---------------------------\n\nint rn2(int x)\n\t\tReturns a random number between 0 &amp; x.\n\t\t( 0 &lt;= rn2(x) &lt; x )\nint rnl(int x)\n\t\tReturns a random number between 0 &amp; x, just as rn2(), but\n\t\tthis time the player's luck affects the result: good luck\n\t\tapproaches 0, bad luck approaches x-1.\nchar *getrumor(int)\n\t\tReturns a \"rumor\" string. if int = 1 rumor is always true,\n\t\t-1 means false and 0 is random.\nvoid exercise(int, boolean)\n\t\tExercise an attribute (A_INT,A_CHA,A_WIS,A_STR,A_DEX). If\n\t\tTRUE increases, FALSE decreases.\nfind_misc() \nuse_misc()\n\t\tBoth functions are used in muse.c to detect an object/action\n\t\tthat a monster can do and execute it.\nvoid mkroom(int)\n\t\tMake and stock a room of a given type.\nboolean has_dnstairs(struct mkroom *)\n\t\tReturns true if room has downstairs.\nboolean has_upstairs(struct mkroom *)\n\t\tReturns true if room has upstairs.\nschar depth(d_level)\n\t\tReturns the depth of a level, in floors below the surface.\n\t\t(note levels in different dungeons can have the same depth).\ndoengrave()\n\t\tUser engraves.\nint bhitm(struct monst *, struct obj *)\n\t\tMonster was hit by the effect of wand or spell indicated\n\t\tin second parameter.\nint zapyourself(struct obj *)\n\t\tThe name says it all: player zapped himself with wand or spell.\nvoid zapnodir(struct obj *)\n\t\tZapping a non-directional wand.\nint breaks(struct obj *, boolean)\n\t\tObject breaks. The boolean flag indicates if object is or not\n\t\tin the fobj chain.\nint peffects(struct obj *)\n\t\tFunction for potion quaffing effects.\nvoid potionhit(struct monst *, struct obj *)\n\t\tPotion hits monster.\nvoid potionbreathe(struct obj *)\n\t\tVapors effects.\nvoid dosinkring(struct obj *)\n\t\tRing is dropped in a sink.\nvoid eatring(struct obj *)\n\t\tPolymorphed player eats a ring.\nvoid Ring_on(struct obj *)\n\t\tRing effects when on.\nvoid Ring_off_or_gone(struct obj *,boolean)\n\t\tRing is removed. The boolean flag indicates if gone (stolen).\nvoid Amulet_on()\nvoid Amulet_off()\n\t\tSimilar idea, but for amulets.\nvoid fprefx(struct obj *)\n\t\tCalled at first bite on food.\nvoid fpostfx(struct obj *)\n\t\tCalled after last bite on food.\nint study_book(struct obj *)\n\t\tStudy a spellbook.\nint spelleffects(struct obj *, boolean)\n\t\tCast a spell. boolean flag indicates if at player himself.\n</pre>\n<div class=\"license_basedon\">\n<p><i>This page is based on a spoiler by German Martin, available at <a class=\"external text\" href=\"http://web.archive.org/web/20160802031704/http://members.shaw.ca/rob.ellwood/sources.txt\">http://web.archive.org/web/20160802031704/http://members.shaw.ca/rob.ellwood/sources.txt</a></i>\n</p>\n</div>\n<div style=\"display:none; right:10px; padding-bottom: 17px\" class=\"metadata topicon nopopups\"><div style=\"margin-top: -10px\"><a href=\"/wiki/NetHackWiki:Next_version\" title=\"This article is unlikely to require revision for the next version of NetHack. Click here for more information.\"><img alt=\"This article is unlikely to require revision for the next version of NetHack. Click here for more information.\" src=\"/images/5/58/Noversion.png\" width=\"32\" height=\"32\" /></a></div></div>\n\n<!-- \nNewPP limit report\nCached time: 20240926182534\nCache expiry: 604800\nDynamic content: false\nCPU time usage: 0.026 seconds\nReal time usage: 0.055 seconds\nPreprocessor visited node count: 95/1000000\nPreprocessor generated node count: 557/1000000\nPost‐expand include size: 2137/2097152 bytes\nTemplate argument size: 569/2097152 bytes\nHighest expansion depth: 8/40\nExpensive parser function count: 0/100\nUnstrip recursion depth: 0/20\nUnstrip post‐expand size: 68162/5000000 bytes\n-->\n<!--\nTransclusion expansion time report (%,ms,calls,template)\n100.00%   20.539      1 -total\n 61.58%   12.648      1 Template:Noversion\n 51.16%   10.507      1 Template:Version_icon\n 23.67%    4.862      1 Template:Verbatim_spoiler\n 20.42%    4.195      1 Template:Top_icon\n 11.74%    2.412      1 Template:Basedon\n-->\n\n<!-- Saved in parser cache with key wikihackdb:pcache:idhash:25421-0!canonical and timestamp 20240926182534 and revision id 105385\n -->\n</div></div>\t\t\t\t\t<div class=\"printfooter\">\n\t\t\t\t\t\tRetrieved from \"<a dir=\"ltr\" href=\"https://nethackwiki.com/index.php?title=Beginner%27s_guide_to_NetHack_sources&amp;oldid=105385\">https://nethackwiki.com/index.php?title=Beginner%27s_guide_to_NetHack_sources&amp;oldid=105385</a>\"\t\t\t\t\t</div>\n\t\t\t\t<div id=\"catlinks\" class=\"catlinks\" data-mw=\"interface\"><div id=\"mw-normal-catlinks\" class=\"mw-normal-catlinks\"><a href=\"/wiki/Special:Categories\" title=\"Special:Categories\">Category</a>: <ul><li><a href=\"/wiki/Category:Spoiler_files\" title=\"Category:Spoiler files\">Spoiler files</a></li></ul></div></div>\t\t\t\t<div class=\"visualClear\"></div>\n\t\t\t\t\t\t\t</div>\n\t\t</div>\n\t\t<div id=\"mw-navigation\">\n\t\t\t<h2>Navigation menu</h2>\n\t\t\t<div id=\"mw-head\">\n\t\t\t\t\t\t\t\t\t<div id=\"p-personal\" role=\"navigation\" class=\"\" aria-labelledby=\"p-personal-label\">\n\t\t\t\t\t\t<h3 id=\"p-personal-label\">Personal tools</h3>\n\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t<li id=\"pt-createaccount\"><a href=\"/index.php?title=Special:CreateAccount&amp;returnto=Beginner%27s+guide+to+NetHack+sources\" title=\"You are encouraged to create an account and log in; however, it is not mandatory\">Create account</a></li><li id=\"pt-login\"><a href=\"/index.php?title=Special:UserLogin&amp;returnto=Beginner%27s+guide+to+NetHack+sources\" title=\"You are encouraged to log in; however, it is not mandatory [o]\" accesskey=\"o\">Log in</a></li>\t\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div id=\"left-navigation\">\n\t\t\t\t\t\t\t\t\t\t<div id=\"p-namespaces\" role=\"navigation\" class=\"vectorTabs\" aria-labelledby=\"p-namespaces-label\">\n\t\t\t\t\t\t<h3 id=\"p-namespaces-label\">Namespaces</h3>\n\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t<li id=\"ca-nstab-main\" class=\"selected\"><span><a href=\"/wiki/Beginner%27s_guide_to_NetHack_sources\" title=\"View the content page [c]\" accesskey=\"c\">Page</a></span></li><li id=\"ca-talk\"><span><a href=\"/wiki/Talk:Beginner%27s_guide_to_NetHack_sources\" rel=\"discussion\" title=\"Discussion about the content page [t]\" accesskey=\"t\">Discussion</a></span></li>\t\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div id=\"p-variants\" role=\"navigation\" class=\"vectorMenu emptyPortlet\" aria-labelledby=\"p-variants-label\">\n\t\t\t\t\t\t\t\t\t\t\t\t<input type=\"checkbox\" class=\"vectorMenuCheckbox\" aria-labelledby=\"p-variants-label\" />\n\t\t\t\t\t\t<h3 id=\"p-variants-label\">\n\t\t\t\t\t\t\t<span>Variants</span>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t<div class=\"menu\">\n\t\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t<div id=\"right-navigation\">\n\t\t\t\t\t\t\t\t\t\t<div id=\"p-views\" role=\"navigation\" class=\"vectorTabs\" aria-labelledby=\"p-views-label\">\n\t\t\t\t\t\t<h3 id=\"p-views-label\">Views</h3>\n\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t<li id=\"ca-view\" class=\"collapsible selected\"><span><a href=\"/wiki/Beginner%27s_guide_to_NetHack_sources\">Read</a></span></li><li id=\"ca-viewsource\" class=\"collapsible\"><span><a href=\"/index.php?title=Beginner%27s_guide_to_NetHack_sources&amp;action=edit\" title=\"This page is protected.&#10;You can view its source [e]\" accesskey=\"e\">View source</a></span></li><li id=\"ca-history\" class=\"collapsible\"><span><a href=\"/index.php?title=Beginner%27s_guide_to_NetHack_sources&amp;action=history\" title=\"Past revisions of this page [h]\" accesskey=\"h\">View history</a></span></li>\t\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div id=\"p-cactions\" role=\"navigation\" class=\"vectorMenu emptyPortlet\" aria-labelledby=\"p-cactions-label\">\n\t\t\t\t\t\t<input type=\"checkbox\" class=\"vectorMenuCheckbox\" aria-labelledby=\"p-cactions-label\" />\n\t\t\t\t\t\t<h3 id=\"p-cactions-label\"><span>More</span></h3>\n\t\t\t\t\t\t<div class=\"menu\">\n\t\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div id=\"p-search\" role=\"search\">\n\t\t\t\t\t\t<h3>\n\t\t\t\t\t\t\t<label for=\"searchInput\">Search</label>\n\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t<form action=\"/index.php\" id=\"searchform\">\n\t\t\t\t\t\t\t<div id=\"simpleSearch\">\n\t\t\t\t\t\t\t\t<input type=\"search\" name=\"search\" placeholder=\"Search NetHackWiki\" title=\"Search NetHackWiki [f]\" accesskey=\"f\" id=\"searchInput\"/><input type=\"hidden\" value=\"Special:Search\" name=\"title\"/><input type=\"submit\" name=\"fulltext\" value=\"Search\" title=\"Search the pages for this text\" id=\"mw-searchButton\" class=\"searchButton mw-fallbackSearchButton\"/><input type=\"submit\" name=\"go\" value=\"Go\" title=\"Go to a page with this exact name if it exists\" id=\"searchButton\" class=\"searchButton\"/>\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</form>\n\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div id=\"mw-panel\">\n\t\t\t\t<div id=\"p-logo\" role=\"banner\"><a class=\"mw-wiki-logo\" href=\"/wiki/Main_Page\"  title=\"Visit the main page\"></a></div>\n\t\t\t\t\t\t<div class=\"portal\" role=\"navigation\" id=\"p-navigation\" aria-labelledby=\"p-navigation-label\">\n\t\t\t<h3 id=\"p-navigation-label\">Navigation</h3>\n\t\t\t<div class=\"body\">\n\t\t\t\t\t\t\t\t<ul>\n\t\t\t\t\t<li id=\"n-NetHack-Wiki\"><a href=\"/wiki/Main_Page\">NetHack Wiki</a></li><li id=\"n-Forum\"><a href=\"/wiki/Forum:Watercooler\">Forum</a></li><li id=\"n-portal\"><a href=\"/wiki/NetHackWiki:Community_Portal\" title=\"About the project, what you can do, where to find things\">Community portal</a></li><li id=\"n-recentchanges\"><a href=\"/wiki/Special:RecentChanges\" title=\"A list of recent changes in the wiki [r]\" accesskey=\"r\">Recent changes</a></li><li id=\"n-randompage\"><a href=\"/wiki/Special:Random\" title=\"Load a random page [x]\" accesskey=\"x\">Random page</a></li>\t\t\t\t</ul>\n\t\t\t\t\t\t\t</div>\n\t\t</div>\n\t\t\t<div class=\"portal\" role=\"navigation\" id=\"p-Popular_pages\" aria-labelledby=\"p-Popular_pages-label\">\n\t\t\t<h3 id=\"p-Popular_pages-label\">Popular pages</h3>\n\t\t\t<div class=\"body\">\n\t\t\t\t\t\t\t\t<ul>\n\t\t\t\t\t<li id=\"n-Dungeon-features\"><a href=\"/wiki/Dungeon_feature\">Dungeon features</a></li><li id=\"n-Monsters\"><a href=\"/wiki/Monster#Canonical_list_of_monsters\">Monsters</a></li><li id=\"n-In.2FExtrinsics\"><a href=\"/wiki/Property#Intrinsic_properties\">In/Extrinsics</a></li><li id=\"n-Items\"><a href=\"/wiki/Item\">Items</a></li><li id=\"n-Spells\"><a href=\"/wiki/Spellbook#List_of_spellbooks\">Spells</a></li><li id=\"n-Game-options\"><a href=\"/wiki/Options\">Game options</a></li><li id=\"n-Websites\"><a href=\"/wiki/Websites\">Websites</a></li>\t\t\t\t</ul>\n\t\t\t\t\t\t\t</div>\n\t\t</div>\n\t\t\t<div class=\"portal\" role=\"navigation\" id=\"p-contributing\" aria-labelledby=\"p-contributing-label\">\n\t\t\t<h3 id=\"p-contributing-label\">Contributing</h3>\n\t\t\t<div class=\"body\">\n\t\t\t\t\t\t\t\t<ul>\n\t\t\t\t\t<li id=\"n-Style-guide\"><a href=\"/wiki/NetHackWiki:Style_guide\">Style guide</a></li><li id=\"n-help\"><a href=\"/wiki/NetHackWiki:How_to_help\" title=\"The place to find out\">How to help</a></li><li id=\"n-Current-projects\"><a href=\"/wiki/NetHackWiki:Current_projects\">Current projects</a></li>\t\t\t\t</ul>\n\t\t\t\t\t\t\t</div>\n\t\t</div>\n\t\t\t<div class=\"portal\" role=\"navigation\" id=\"p-tb\" aria-labelledby=\"p-tb-label\">\n\t\t\t<h3 id=\"p-tb-label\">Tools</h3>\n\t\t\t<div class=\"body\">\n\t\t\t\t\t\t\t\t<ul>\n\t\t\t\t\t<li id=\"t-whatlinkshere\"><a href=\"/wiki/Special:WhatLinksHere/Beginner%27s_guide_to_NetHack_sources\" title=\"A list of all wiki pages that link here [j]\" accesskey=\"j\">What links here</a></li><li id=\"t-recentchangeslinked\"><a href=\"/wiki/Special:RecentChangesLinked/Beginner%27s_guide_to_NetHack_sources\" rel=\"nofollow\" title=\"Recent changes in pages linked from this page [k]\" accesskey=\"k\">Related changes</a></li><li id=\"t-specialpages\"><a href=\"/wiki/Special:SpecialPages\" title=\"A list of all special pages [q]\" accesskey=\"q\">Special pages</a></li><li id=\"t-print\"><a href=\"/index.php?title=Beginner%27s_guide_to_NetHack_sources&amp;printable=yes\" rel=\"alternate\" title=\"Printable version of this page [p]\" accesskey=\"p\">Printable version</a></li><li id=\"t-permalink\"><a href=\"/index.php?title=Beginner%27s_guide_to_NetHack_sources&amp;oldid=105385\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-info\"><a href=\"/index.php?title=Beginner%27s_guide_to_NetHack_sources&amp;action=info\" title=\"More information about this page\">Page information</a></li>\t\t\t\t</ul>\n\t\t\t\t\t\t\t</div>\n\t\t</div>\n\t\t\t\t</div>\n\t\t</div>\n\t\t\t\t<div id=\"footer\" role=\"contentinfo\">\n\t\t\t\t\t\t<ul id=\"footer-info\">\n\t\t\t\t\t\t\t\t<li id=\"footer-info-lastmod\"> This page was last edited on 29 April 2017, at 01:04.</li>\n\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t<ul id=\"footer-places\">\n\t\t\t\t\t\t\t\t<li id=\"footer-places-about\"><a href=\"/wiki/NetHackWiki:About\" title=\"NetHackWiki:About\">About NetHackWiki</a></li>\n\t\t\t\t\t\t\t\t<li id=\"footer-places-disclaimer\"><a href=\"/wiki/NetHackWiki:General_disclaimer\" title=\"NetHackWiki:General disclaimer\">Disclaimers</a></li>\n\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t\t\t\t\t<ul id=\"footer-icons\" class=\"noprint\">\n\t\t\t\t\t\t\t\t\t\t<li id=\"footer-poweredbyico\">\n\t\t\t\t\t\t<a href=\"//www.mediawiki.org/\"><img src=\"/resources/assets/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\" srcset=\"/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x\" width=\"88\" height=\"31\"/></a>\t\t\t\t\t</li>\n\t\t\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t<div style=\"clear: both;\"></div>\n\t\t</div>\n\t\t\n<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({\"wgPageParseReport\":{\"limitreport\":{\"cputime\":\"0.026\",\"walltime\":\"0.055\",\"ppvisitednodes\":{\"value\":95,\"limit\":1000000},\"ppgeneratednodes\":{\"value\":557,\"limit\":1000000},\"postexpandincludesize\":{\"value\":2137,\"limit\":2097152},\"templateargumentsize\":{\"value\":569,\"limit\":2097152},\"expansiondepth\":{\"value\":8,\"limit\":40},\"expensivefunctioncount\":{\"value\":0,\"limit\":100},\"unstrip-depth\":{\"value\":0,\"limit\":20},\"unstrip-size\":{\"value\":68162,\"limit\":5000000},\"timingprofile\":[\"100.00%   20.539      1 -total\",\" 61.58%   12.648      1 Template:Noversion\",\" 51.16%   10.507      1 Template:Version_icon\",\" 23.67%    4.862      1 Template:Verbatim_spoiler\",\" 20.42%    4.195      1 Template:Top_icon\",\" 11.74%    2.412      1 Template:Basedon\"]},\"cachereport\":{\"timestamp\":\"20240926182534\",\"ttl\":604800,\"transientcontent\":false}}});mw.config.set({\"wgBackendResponseTime\":127});});</script>\n\t</body>\n</html>\n","rawPage":"{{verbatim spoiler}}\n\n<pre>\n\t BEGINNER'S GUIDE TO NETHACK SOURCES\n        ---------------------- by German Martin --\n                                        german@spain.hp.com\n\n                  \t\t   version 1.0  March '95\n\nContents\n--------\n\n   1. About this document.\n   2. Hey, I want to modify the game!\n   3. Starting point.\n   4. The wizard mode.\n   5. Creating a new level.\n   6. Creating a new monster.\n   7. Refining your monster.\n\t   7.0. The 'monst' struct.\n\t   7.1. Adding a new attack type.\n\t   7.2. Adding new monster's abilities.\n\t   7.3. Adding a 'mextra' struct.\n   8. Creating a new object.\n\t   8.0. The 'objects' array.\n\t   8.1. Adding a tool.\n\t   8.2. Adding a wand.\n\t   8.3. Adding a potion.\n\t   8.4. Adding armor/weapon.\n\t   8.5. Adding a ring.\n\t   8.6. Adding an amulet.\n\t   8.7. Adding a spellbook.\n\t   8.8. Adding food.\n   9. Creating a new room type.\n  10. Creating a new shop type.\n  11. Goodbye.\n  Apendix A. Reference Function listing\n\n\n1. About this document\n----------------------\n\n   Have you played - and enjoyed - nethack for several [ months | years ] ?\n  Do you have some cool new ideas for the game but nobody seems to hear you?\n  Do you have access to a machine with a C compiler? Have you ever programmed\n  before?\n\n   If you answered yes to the above questions then this paper can be of your\n  interest.\n\n   Around middle '94 I started to look around in the nethack sources; loving\n  the game I really wanted to add some new monsters & features, but the task\n  was quite painful. I'm not a C newbie, but 100 (actually more) source\n  files was more than I could manage: even trying to find the main() entry\n  to the code proved to be difficult. The help provided by the inlined \n  comments is useless for the newcomer. Now, nine months later, I've learned\n  a lot about the main structures in the code: I've been able to add new\n  monsters, objects, rooms, levels and behaviours. I - not being a member of\n  the Dev Team, in case you were wondered - don't pretend to have a full\n  knowledge of the huge beast, but my objective here is to help new ideas\n  to be added to the game, not being a complete guide to the code.\n\n   So, it is quite possible that you found many things incorrect here; more\n  than possible - that is, sure - that you found many things incomplete.\n  OK, send the bug/comment/addition to me and I'd modify/add it.\n\n   Please, USE THIS AT YOUR OWN RISK. If you get nothing but frustration don't\n  flame me: I was only trying to help.\n\n   All the documentation here refers to Nethack 3.1.3 (the current official\n  version at the date this is written).\n\n\n2. Hey, I want to modify the game!\n----------------------------------\n\n   OK. You have started to play nethack last week; got an account in a Unix\n  machine and thought \"Hey, I have a great idea! I'll learn C while modifying\n  this game! All I have to do is follow this cookbook!\". Forget it. Unless you\n  are a reincarnation of Leonardo da Vinci you'll get nothing but a headache.\n\n   In other words, to use this info you need at last:\n\n     - Few knowledge about the OS you are running in. That is, how to edit,\n      move, create and remove files basically.\n\n     - Good knowledge of the C programming language. That is, more than the\n      printf(\"Hello world\\n\") program. This includes the C preprocessor.\n\n     - A C compiler and feel comfortable with it.\n\n     - A blessed potion of gain ability.\n\n\n3. Starting point\n-----------------\n\n   The first thing you have to do is compile the sources by yourself. You\n   don't have to understand the whole process, but surely you need to be\n   able to compile the official code and get it running before you add any-\n   thing to the game. Refer to the README file in the top directory and to\n   the Install.XXX  (XXX depending of your operating system) in /sys/XXX\n   directory.\n\n   Once you have compiled the sources suddenly you are now aware of what\n   to expect.\n\n\n4. The wizard mode\n------------------\n   As you probably know, the wizard mode is a way to start nethack with a\n   few extra commands:\n\n\t\t^E  ==  detect secret doors and traps.\n\t\t^F  ==  do magic mapping.\n\t\t^G  ==  create monster.\n\t\t^I  ==  identify items in pack.\n\t\t^O  ==  tell locations of special levels.\n\t\t^T  ==  do intra-level teleport.\n\t\t^V  ==  do trans-level teleport.\n\t\t^W  ==  make wish.\n\t\t^X  ==  show intrinsic attributes.\n\n     plus some changes for known actions: i.e. read a scroll of create\n   monster allows to specify the type of monster.\n\n   That allows you to quickly try out the new feature/change you just added.\n   To start it, just type:\n\n                nethack -u wizard -D\n\n   It should work, but take present:\n\n   - If in a unix machine you should be the correct user-id.\n   - have a look in include/config.h and search for the #define WIZARD lines;\n    maybe you need to put another name after the -u.\n\n   Throughout your process of modifying nethack you should make extensible\n   usage of this mode so better make sure it works. (As an alternative you\n   can always play a complete game to try out your new monster in the astral\n   level :-) )\n\n\n\n5. Creating a new level\n-----------------------\n\n   To create a new level is easy. In fact, it doesn't require any knowledge\n   of C: the dev team prepared it for us.\n\n   Under the \"util\" directory the process of creating a nethack executable\n   should have left a program called 'lev_comp' (lev_comp.exe if in MS-DOS).\n   That binary is capable of create a new special level for nethack: give it\n   a description file (named <something>.des) and it gives you a level file\n   (named <something>.lev) suitable for the nethack binary:\n\n\n            mylevel.des -----------\n                                   |\n                                __ | __\n                                \\  V  /\n                              ___\\___/___\n                              |         | _\n                              |lev_comp |/\n                              |         |  -----> mylevel.lev\n                              -------------\n\n   The lev_comp compiler has a manual page (have a look in the \"doc\" directory)\n   called 'lev_comp.6'. If you are in a unix machine a command like \n                          nroff -man lev_comp.6 | more\n   should give you a standard formatted man page. If not... well, you should\n   have to get used to the .SH .PP etc... garbage in the file. This man page\n   shows (quite obtusely) how to create a .des file; but better than starting\n   from scratch is starting trying to understand a predefined file.\n   For example, let's view the begining of \"dat/castle.des\" file:\n\n\tMAZE:\"castle\",random\n\tFLAGS: noteleport\n\tGEOMETRY:center,center\n\tMAP\n\t}}}}}}}}}.............................................}}}}}}}}}\n\t}-------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}\n\t}|.....|-----------------------------------------------|.....|}\n\t}|.....+...............................................+.....|}\n\t}-------------------------------+-----------------------------}\n\t}}}}}}|........|..........+...........|.......S.S.......|}}}}}}\n\t.....}|........|..........|...........|.......|.|.......|}.....\n\t.....}|........------------...........---------S---------}.....\n\t.....}|...{....+..........+.........\\.S.................+......\n\t.....}|........------------...........---------S---------}.....\n\t.....}|........|..........|...........|.......|.|.......|}.....\n\t}}}}}}|........|..........+...........|.......S.S.......|}}}}}}\n\t}-------------------------------+-----------------------------}\n\t}|.....+...............................................+.....|}\n\t}|.....|-----------------------------------------------|.....|}\n\t}-------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}\n\t}}}}}}}}}.............................................}}}}}}}}}\n\tENDMAP\n\n   Sounds familiar? This file is the description from where the castle\n   level is created. The part showed here just sets the level aspect: a\n   drawed castle centered between mazes (note the MAZE line). \n\n   The rest of the file puts doors, traps, objects and monsters in a random\n   or specific position (with coordinates relative to the previous map).\n\n   The man page describes the exact syntax, so if you dare you can now start\n   modifying the whole file; but let's make a very easy change and see how it\n   works: suppose you feel the soldiers at the castle are too wimpy and think\n   changing them to more difficult monsters, say minotaurs for example. So,\n   just change the lines:\n\n   MONSTER:'@',\"soldier\",(08,06) and subsequents\n\n   with\n\n   MONSTER:'H',\"minotaur\",(08,06) etc...\n\n   (Note that with this change we are chosing a specific monster. We could have\n   chosen to create monsters of a certain class, like\n\n   MONSTER:'D',RANDOM,(08,06)   # Create a random type dragon )\n\n   Save the new castle.des file and run: (from the dat directory)\n\n      ../util/lev_comp castle.des      (change the /'s with \\'s if in MS-DOS)\n\n   That creates a new 'castle.lev' file in the 'dat' directory. To try it,\n   copy it to the playing directory (something like games/nethack) and start\n   a game in wizard mode. Teleport to the castle, wish for a floating eye\n   corpse and a blindfold and have a look: you should have lots of brown H's!\n\n\n   But now it is time to deal with the original subject: we wanted to added\n   a NEW level to nethack, not just modifying one. Let the castle.des alone\n   and create a newlevel.des!\n\n   For that, we have to introduce a new compiler: dgn_comp, the dungeon\n   compiler. As the lev_comp it has a manual page: dgn_comp.6. Its purpose\n   is a step ahead: it takes a file describing the complete dungeon (as a\n   collection of levels) and creates a \"dungeon\" file suitable for the\n   nethack binary.\n\n   The description file in question is called \"dungeon.def\":\n\n\tDUNGEON:        \"The Dungeons of Doom\" \"D\" (25, 5)\n\tALIGNMENT:      unaligned\n\t%MULDGN BRANCH: \"The Gnomish Mines\" @ (2, 3)\n\t%REINCARNATION LEVEL:           \"rogue\" \"R\" @ (15, 4)\n\tLEVEL:          \"oracle\" \"O\" @ (5, 5)\n\tLEVALIGN:       neutral\n\tLEVEL:          \"bigroom\" \"B\" @ (10, 3) 15\n\t%MULDGN CHAINBRANCH:    \"The Quest\" \"oracle\" + (6, 2) portal\n\t%MULDGN BRANCH:         \"Fort Ludios\" @ (18, 4) portal\n\tRNDLEVEL:       \"medusa\" \"none\" @ (-5, 4) 2\n\tLEVALIGN:       chaotic\n\tLEVEL:          \"castle\" \"none\" @ (-1, 0)\n\tCHAINBRANCH:    \"Gehennom\" \"castle\" + (0, 0) no_down\n\tBRANCH:         \"The Elemental Planes\" @ (1, 0) no_down up\n\n   As you probably knew, there are 'levels' and branches of the main dungeon,\n   being composed of levels. The easiest thing is to add a simple level inside\n   the main dungeon: \n\n   Suppose you created a new mylevel.des file where you define a 'mylevel' \n   level:\n\n   MAZE:\"mylevel\",' '\n\n   (IMPORTANT note here: usually the file is named the same as the MAZE it\n   defines, as in castle.des, but the name for the .lev file is taken from\n   the MAZE line !!)\n\n   To add it to the main dungeon we can add a line after the bigroom one:\n\n   LEVEL:\t\"mylevel\" \"none\" @ (15,2)\n\n   That is, create the 'mylevel' level randomly at 15 +-2 level deep. The \n   level won't left bones files (the 'none' part).\n\n   And run ../util/dgn_comp dungeon.def  to get the 'dungeon' file. Copy it\n   to the game directory and try it out (wizard mode command Ctrl-O is quite\n   useful here).\n\n   If there is any error loading the new level, nethack will create a random\n   maze instead.\n\n   Finally, if we wanted to add a whole new branch to the dungeon, we will\n   put a line like:\n\n   %MULDGN BRANCH: \"newbranch\" @ (18, 1)\n   \n   and later on, the lines defining the levels in this new branch:\n\n   DUNGEON:        \"newbranch\" \"S\" (4,0)\n   DESCRIPTION:    mazelike\n   LEVEL:          \"mylevel1\" \"none\" @ (1, 0)\n   LEVEL:          \"mylevel2\" \"none\" @ (2, 0)\n   LEVEL:          \"mylevel3\" \"none\" @ (3, 0)\n   LEVEL:          \"mylevel4\" \"none\" @ (4, 0)\n\n\n   Now you should take a while and play around with the existing .des files\n   and become familiar with the syntax. Creating new levels and dungeon wasn't\n   difficult, was it?\n\n   Maybe this chapter covers all your needs; but if you really want \n   exciting new emotions, read on.\n\n\n6. Creating a new monster\n-------------------------\n\n      \"Beware, there will be no return! Still read? (y/n)\"\n      \n   Welcome to Darkness of Mordor... This is going to be painful but the\n   reward is great: some modification could be blessed by the dev team and\n   you will reach inmortality! And anyway, modifying nethack will give you\n   even happier hours than playing it.\n\n   So, let's cope with it:\n\n   For start, you should know that there are two HUGE arrays: one defining the\n   possible monsters and the other defining the possible objects. The first\n   one is called 'mons': it's an array of 'permonst' structs defined in the\n   file monst.c, under the src directory (by the way, after this point, I'll\n   stop saying where the files are located: you should be familiar with the\n   directory structure by now). The 'permonst' struct is defined in the\n   file permonst.h, and giving it a look should give you an idea of what \n   element of the struct is for, but, for your convenience here is an expla-\n   nation of what to put in a new entry for the mons array, i.e:\n\n\n        {\"myself\", S_HUMAN, 1, 10, 10, 0, 0, G_GENO | G_NOGEN,\n        { { AT_WEAP, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK,\n          NO_ATTK, NO_ATTK, NO_ATTK },\n        WT_HUMAN, 400, PL_NSIZ, MS_HUMANOID, MZ_HUMAN, 0, 0,\n        M1_NEEDPICK | M1_HUMANOID | M1_OMNIVORE,\n        M2_HUMAN | M2_STRONG | M2_COLLECT, 0, C(HI_DOMESTIC)}\n\n   -name: (\"myself\") is the name for the monster.\n\n   -symbol: (S_HUMAN) is the letter used for it. The complete list is defined\n\t  in the file monsym.h\n\n   -level: (1). The monster is initially created with this level.\n\n   -move rate: (10). Ranges from 0 -don't move- to 30 -really fast-.\n\n   -AC: (10). Come on! you now quite well what this is.\n\n   -magic resistance: (0). Ranges from 0 -none- to 127 -full-.\n\n   -alignment: (0). negative value means chaotic, positive lawful.\n\n   -creation/geno flags: (G_GENO | G_NOGEN) \n\tthese are flags or'ded, with this meaning:\n\n        G_UNIQ          /* generated only once */\n        G_NOHELL        /* not generated in \"hell\" */\n        G_HELL          /* generated only in \"hell\" */\n        G_NOGEN         /* generated only specially */\n        G_NOCORPSE      /* no corpse left ever */\n        G_SGROUP        /* appear in small groups normally */\n        G_LGROUP        /* appear in large groups normally */\n        G_GENO          /* can be genocided */\n        G_GENOD         /* have been genocided */\n        G_EXTINCT       /* have been extinguished as\n                           population control */\n        G_FREQ          /* creation frequency mask */\n\n                 (from monsym.h)\n\n   -attack: ({ { AT_WEAP, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK,\n           NO_ATTK, NO_ATTK, NO_ATTK },)\n      This defines how the monster attacks. This element is composed of six \n      'attack' struct, each one being the form:\n\n\t  ( attack_type, damage_type, # of dice, # of sides of each )\n\n      where attack_type is one of:\n\n        AT_NONE         /* passive monster (ex. acid blob) */\n        AT_CLAW         /* claw (punch, hit, etc.) */\n        AT_BITE         /* bite */\n        AT_KICK         /* kick */\n        AT_BUTT         /* head butt (ex. a unicorn) */\n        AT_TUCH         /* touches */\n        AT_STNG         /* sting */\n        AT_HUGS         /* crushing bearhug */\n        AT_SPIT         /* spits substance - ranged */\n        AT_ENGL         /* engulf (swallow or by a butt) */\n        AT_BREA         /* breath - ranged */\n        AT_EXPL         /* explodes - proximity */\n        AT_GAZE         /* gaze - ranged */\n        AT_TENT         /* tentacles */\n        AT_WEAP         /* uses weapon */\n        AT_MAGC         /* uses magic spell(s) */\n\n      damage_type is one of:\n\n        AD_PHYS         /* ordinary physical */\n        AD_MAGM         /* magic missiles */\n        AD_FIRE         /* fire damage */\n        AD_COLD         /* frost damage */\n        AD_SLEE         /* sleep ray */\n        AD_DISN         /* disintegration (death ray) */\n        AD_ELEC         /* shock damage */\n        AD_DRST         /* drains str (poison) */\n        AD_ACID         /* acid damage */\n        AD_SPC1         /* for extension of buzz() */\n        AD_SPC2         /* for extension of buzz() */\n        AD_BLND         /* blinds (glowing eye) */\n        AD_STUN         /* stuns */\n        AD_SLOW         /* slows */\n        AD_PLYS         /* paralyses */\n        AD_DRLI         /* drains life levels (Vampire) */\n        AD_DREN         /* drains magic energy */\n        AD_LEGS         /* damages legs (xan) */\n        AD_STON         /* petrifies (Medusa, Cockatrice) */\n        AD_STCK         /* sticks to you (Mimic) */\n        AD_SGLD         /* steals gold (Leppie) */\n        AD_SITM         /* steals item (Nymphs) */\n        AD_SEDU         /* seduces & steals multiple items */\n        AD_TLPT         /* teleports you (Quantum Mech.) */\n        AD_RUST         /* rusts armour (Rust Monster)*/\n        AD_CONF         /* confuses (Umber Hulk) */\n        AD_DGST         /* digests opponent (trapper, etc.) */\n        AD_HEAL         /* heals opponent's wounds (nurse) */\n        AD_WRAP         /* special \"stick\" for eels */\n        AD_WERE         /* confers lycanthropy */\n        AD_DRDX         /* drains dexterity (Quasit) */\n        AD_DRCO         /* drains constitution */\n        AD_DRIN         /* drains intelligence (mind flayer) */\n        AD_DISE         /* confers diseases */\n        AD_DCAY         /* decays organics (Brown pudding) */\n        AD_SSEX         /* Succubus seduction (extended) */\n        AD_DETH         /* for Death only */\n        AD_PEST         /* for Pestilence only */\n        AD_FAMN         /* for Famine only */\n        AD_CLRC         /* random clerical spell */\n        AD_SPEL         /* random magic spell */\n        AD_RBRE         /* random breath weapon */\n        AD_SAMU         /* hits, may steal Amulet (Wizard) */\n        AD_CURS         /* random curse (ex. gremlin) */\n\n      and the # dice/faces sets a range of damage:\n\n           i.e:   1,6     means a possible damage between 1 and 6,\n              but 3,7     means a possible damage between 3 and 21.\n\n      So, a monster can attack six times per turn at maximum. To attack less\n      times use the 'NO_ATTACK' entry.\n\n   -weight: (WT_HUMAN). Can be one of several defines like WT_DRAGON, WT_HUMAN,\n      WT_ELF, but also a direct number can be used.\n\n   -nutritional value: (400). The title says it all.\n\n   -extension length: (PL_NSIZ). Here comes a problem...This is the size of an\n      extra struct added to the normal permonst if the monster has any. For\n      example, shopkeepers have an extra struct used to manage the shop\n      code, dogs an extra to manage taming levels, etc... For the moment\n      forget about this part.\n\n   -sounds made: (MS_HUMAN). It is one of: (from monflag.h)\n\n        MS_SILENT       /* makes no sound */\n        MS_BARK         /* if full moon, may howl */\n        MS_MEW          /* mews or hisses */\n        MS_ROAR         /* roars */\n        MS_GROWL        /* growls */\n        MS_SQEEK        /* squeaks, as a rodent */\n        MS_SQAWK        /* squawks, as a bird */\n        MS_HISS         /* hisses */\n        MS_BUZZ         /* buzzes (killer bee) */\n        MS_GRUNT        /* grunts (or speaks own language) */\n        MS_NEIGH        /* neighs, as an equine */\n        MS_WAIL         /* wails, as a tortured soul */\n        MS_GURGLE       /* gurgles, as liquid or through saliva */\n        MS_BURBLE       /* burbles (jabberwock) */\n        MS_ANIMAL       /* up to here are animal noises */\n        MS_SHRIEK       /* wakes up others */\n        MS_BONES        /* rattles bones (skeleton) */\n        MS_LAUGH        /* grins, smiles, giggles, and laughs */\n        MS_MUMBLE       /* says something or other */\n        MS_IMITATE      /* imitates others (leocrotta) */\n        MS_ORC          /* intelligent brutes */\n        MS_HUMANOID     /* generic traveling companion */\n        MS_ARREST       /* \"Stop in the name of the law!\" (Kops) */\n        MS_SOLDIER      /* army and watchmen expressions */\n        MS_GUARD        /* \"Please drop that gold and follow me.\" */\n        MS_DJINNI       /* \"Thank you for freeing me!\" */\n        MS_NURSE        /* \"Take off your shirt, please.\" */\n        MS_SEDUCE       /* \"Hello, sailor.\" (Nymphs) */\n        MS_VAMPIRE      /* vampiric seduction, Vlad's exclamations */\n        MS_BRIBE        /* asks for money, or berates you */\n        MS_CUSS         /* berates (demons) or intimidates (Wiz) */\n        MS_RIDER        /* astral level special monsters */\n        MS_LEADER       /* your class leader */\n        MS_NEMESIS      /* your nemesis */\n        MS_GUARDIAN     /* your leader's guards */\n        MS_SELL         /* demand payment, complain about shoplifters */\n        MS_ORACLE       /* do a consultation */\n        MS_PRIEST       /* ask for contribution; do cleansing */\n\n\n   -physical size: (MZ_HUMAN). Is one of:\n\n        MZ_TINY         0               /* < 2' */\n        MZ_SMALL        1               /* 2-4' */\n        MZ_MEDIUM       2               /* 4-7' */\n        MZ_HUMAN        MZ_MEDIUM       /* human-sized */\n        MZ_LARGE        3               /* 7-12' */\n        MZ_HUGE         4               /* 12-25' */\n        MZ_GIGANTIC     7               /* off the scale */\n\n   -resistance conferred (randomly) when eaten: (0)\n\n        MR_FIRE         /* resists fire */\n        MR_COLD         /* resists cold */\n        MR_SLEEP        /* resists sleep */\n        MR_DISINT       /* resists disintegration */\n        MR_ELEC         /* resists atomicity */\n        MR_POISON       /* resists poison */\n        MR_ACID         /* resists acid */\n        MR_STONE        /* resists petrification */\n\n   -First group of flags: (specify the monster behaviour)\n          (M1_NEEDPICK | M1_HUMANOID | M1_OMNIVORE)\n\n        M1_FLY          /* can fly or float */\n        M1_SWIM         /* can traverse water */\n        M1_AMORPHOUS    /* can flow under doors */\n        M1_WALLWALK     /* can phase thru rock */\n        M1_CLING        /* can cling to ceiling */\n        M1_TUNNEL       /* can tunnel thru rock */\n        M1_NEEDPICK     /* needs pick to tunnel */\n        M1_CONCEAL      /* hides under objects */\n        M1_HIDE         /* mimics, blends in with ceiling */\n        M1_AMPHIBIOUS   /* can survive underwater */\n        M1_BREATHLESS   /* doesn't need to breathe */\n        M1_NOEYES       /* no eyes to gaze into or blind */\n        M1_NOHANDS      /* no hands to handle things */\n        M1_NOLIMBS      /* no arms/legs to kick/wear on */\n        M1_NOHEAD       /* no head to behead */\n        M1_MINDLESS     /* has no mind--golem, zombie, mold */\n        M1_HUMANOID     /* has humanoid head/arms/torso */\n        M1_ANIMAL       /* has animal body */\n        M1_SLITHY       /* has serpent body */\n        M1_UNSOLID      /* has no solid or liquid body */\n        M1_THICK_HIDE   /* has thick hide or scales */\n        M1_OVIPAROUS    /* can lay eggs */\n        M1_REGEN        /* regenerates hit points */\n        M1_SEE_INVIS    /* can see invisible creatures */\n        M1_TPORT        /* can teleport */\n        M1_TPORT_CNTRL  /* controls where it teleports to */\n        M1_ACID         /* acidic to eat */\n        M1_POIS         /* poisonous to eat */\n        M1_CARNIVORE    /* eats corpses */\n        M1_HERBIVORE    /* eats fruits */\n        M1_OMNIVORE     /* eats both */\n        M1_METALLIVORE  /* eats metal */\n\n\n   -Second group of flags: (specify more monster behaviour)\n        (M2_HUMAN | M2_STRONG | M2_COLLECT)\n\n        M2_NOPOLY       /* players mayn't poly into one */\n        M2_UNDEAD       /* is walking dead */\n        M2_WERE         /* is a lycanthrope */\n        M2_ELF          /* is an elf */\n        M2_DWARF        /* is a dwarf */\n        M2_GIANT        /* is a giant */\n        M2_ORC          /* is an orc */\n        M2_HUMAN        /* is a human */\n        M2_DEMON        /* is a demon */\n        M2_MERC         /* is a guard or soldier */\n        M2_LORD         /* is a lord to its kind */\n        M2_PRINCE       /* is an overlord to its kind */\n        M2_MINION       /* is a minion of a deity */\n        M2_MALE         /* always male */\n        M2_FEMALE       /* always female */\n        M2_NEUTER       /* neither male nor female */\n        M2_PNAME        /* monster name is a proper name */\n        M2_HOSTILE      /* always starts hostile */\n        M2_PEACEFUL     /* always starts peaceful */\n        M2_DOMESTIC     /* can be tamed by feeding */\n        M2_WANDER       /* wanders randomly */\n        M2_STALK        /* follows you to other levels */\n        M2_NASTY        /* extra-nasty monster (more xp) */\n        M2_STRONG       /* strong (or big) monster */\n        M2_ROCKTHROW    /* throws boulders */\n        M2_GREEDY       /* likes gold */\n        M2_JEWELS       /* likes gems */\n        M2_COLLECT      /* picks up weapons and food */\n        M2_MAGIC        /* picks up magic items */\n\n   -Third group of flags: (0) (specify even more monster behaviour)\n\n        M3_WANTSAMUL    /* would like to steal the amulet */\n        M3_WANTSBELL    /* wants the bell */\n        M3_WANTSBOOK    /* wants the book */\n        M3_WANTSCAND    /* wants the candelabrum */\n        M3_WANTSARTI    /* wants the quest artifact */\n        M3_WANTSALL     /* wants any major artifact */\n        M3_WANTSALL     /* wants any major artifact */\n        M3_WAITFORU     /* waits to see you or get attacked */\n        M3_CLOSE        /* lets you close unless attacked */\n        M3_COVETOUS     /* wants something */\n        M3_WAITMASK     /* waiting... */\n\n   -symbol color: (C(HI_DOMESTIC))\n\n        C(RED), C(BROWN), C(HI_DOMESTIC), etc...\n\n            (HI_DOMESTIC is the color for a peaceful monster).\n\n   You should also follow this rules, as the glorious dev team says:\n\n  \n        Rule #1:        monsters of a given class are contiguous in the\n                        mons[] array.\n  \n        Rule #2:        monsters of a given class are presented in ascending\n                        order of strength.\n  \n        Rule #3:        monster frequency is included in the geno mask;\n                        the frequency can be from 0 to 7.  0's will also\n                        be skipped during generation.\n  \n        Rule #4:        monster subclasses (e.g. giants) should be kept\n                        together, unless it violates Rule 2.  NOGEN monsters\n                        won't violate Rule 2.\n  \n  \n\n   And that's all. As usual it is easier to begin copying an existing monster.\n   For example if you want to create a stronger centaur, get the plain one\n   and change the AC and attack part.\n\n   Now you need to recompile the whole code. Yes, you read right: the WHOLE\n   CODE. The reason is this: the mons array sets a unique number for each\n   monster used later for reference it in the array. Did you saw a 'makedefs'\n   command while compiling? It is a vital part: generates #define for each\n   monster & object. So if you look at the pm.h file:\n\n\t/* This source file is generated by 'makedefs'.  Do not edit. */\n\t#ifndef PM_H\n\t#define PM_H\n\n\t#define PM_GIANT_ANT    0\n\t#define PM_KILLER_BEE   1\n\t#define PM_SOLDIER_ANT  2\n\t#define PM_FIRE_ANT     3\n\n   you understand now how it works: the sources can use the PM_SOMETHING\n   define to access the permonst struct of a 'something' monster without\n   knowing previously its location.\n\n   If you did set up make or ndmake correctly, make itself will take care of\n   the process of recompiling the code. Note that the *.des files are also\n   recompiled.\n\n   Now, to try out the new monster start nethack in wizard mode and wish for\n   a scroll of create monster. Read it and answer to create a 'your monster'\n   one. Voila! You now have your own monster.\n\n   IMPORTANT NOTE:\n      It is quite important to separate your own code with the appropriate\n   #ifdef, #ifndef statements. Just add the necessary #define SOMETHING \n   line at the end of include/config.h file.\n\n\n7. Refining your monster\n-------------------------\n\n   7.0. The 'monst' struct.\n\n   From the chapter 5 you now have a monster of your own wandering through\n   the dungeons. But surely you want more action: specific objects, armor\n   or weapon for him; concrete chatting sentences, etc... How can you\n   accomplish this? read on.\n\n   Now is the moment to introduce the 'monst' structure. This struct is what\n   defines a 'concrete' monster: hps, taming status, etc... very different\n   from the 'permonst' structure, where the capabilities of all monsters of\n   a type are defined. The elements in 'monst' are defined in monst.h:\n\n   -nmon: All monsters in current level are organized in a chained list. \n   Starting with a first monster descriptor ('fmon') you can navigate through\n   all of them, thanks to this pointer to the next monster:\n\n                    --------    --------   --------   --------\n            fmon -> | nmon ---> | nmon --->| nmon --->| nmon ---> NULL\n                    |      |    |      |   |      |   |      |\n                    | MONST|    | MONST|   | MONST|   | MONST|\n                    |  #1  |    |  #2  |   |  #3  |   |  #4  |\n                    --------    --------   --------   --------\n\n   -data: Is a pointer to the permonst structure for this monster. Obviously,\n   as the weight of a newt is permanent it doesn't make sense to keep it for\n   each concrete newt.\n\n   -m_id: unique number for a monster, asigned at creation time.\n\n   -mnum: Permanent monster index number. Number asigned by makedefs. That is,\n    the PM_NAME_OF_MONSTER #define in include file pm.h.  It is unique to this\n    type of monster.\n\n   -m_lev: Adjusted difficulty level of monster; that is, the level of a \n   monster can have changed from the default one (experience, potions,etc...)\n\n   -malign: Alignment of this monster, relative to the player. A positive\n   number means is good to kill it.\n\n   -mx, my: Position of the monster in the level map (x,y coordinates).\n\n   -mux,muy: Position in the map where the monster thinks player is. May be\n   different from actual one due to cloack of displacement, invisibility, etc.\n\n   -mtrack: Monster track???. Used in the movement routines, but I've no clear\n    idea of what it is.\n\n   -mappearance: For mimics & the wizard. How it looks to the player.\n\n   -m_ap_type: What mappearance is describing. Is one of:\n\tM_AP_NOTHING    0/*mappearance is unused --monster appears as itself */\n\tM_AP_FURNITURE  1/* stairs, a door, an altar, etc. */\n\tM_AP_OBJECT     2/* an object */\n\tM_AP_MONSTER    3/* a monster */\n\n   -mtame: Level of tameness. If greater than 0 monster is tamed, and also\n    implies peacefulness (as it doesn't make sense a tamed monster aggresive\n    to the player).\n\n   -mspec_used: Monster's special ability attack timeout. That is, monster \n   won't use its special ability -like dragon's breath- until this counter \n   reaches 0.\n\n   -female: 1 = yes, 0 = no.\n   -minvis: Monster is invisible. 1 = yes, 0 = no.\n   -cham: Monster is actually a chamaleon. 1 = yes, 0 = no.\n   -mundetected: Monster is hidden (as snakes) and hasn't been detected by\n   the player. 1 = yes, 0 = no.\n   -mcan: Monster has been zapped by a wand of cancellation (or spell).\n   -mspeed: Monster extra speed. 2 bits allow 4 possibilities.\n   -mflee: Monster is currently fleeing.\n   -mfleetim: (7 bits) timeout for that fleeing.\n   -mcansee/mblinded: monster can see / timeout for blinded.\n   -mcanmove/mfrozen: monster can move / timeout for frozen.\n   -msleep: monster is sleeping.\n   -mstun: monster is stunned.\n   -mconf: monster is confused.\n   -mpeaceful: monster is peaceful.\n   -mtrapped: monster is now trapped.\n   -mleashed: leashed is applied to it.\n   -isshk: This monster is a shopkeeper. \n   -isminion: Is a minion.\n   -isgd: is a guard.\n   -ispriest: is a priest.\n   -iswiz: is the wizard of Yendor.\n   -wormno: If a worm, this sets the number this one makes. (there can't be\n    more than 31 per level).\n   -mstrategy: Strategy to follow. (just applies to very special monsters).\n   -mtrapseen: bitmap of traps we've been trapped in.\n   -mlstmv: flag to prevent two moves at once (?). \n   -mgold: How rich this monster is.\n   -minvent: It points to a 'obj' struct. The objects a monster has are \n    organized in a chained list, the same as the 'monst' struct. This is\n    the beginning of that list. (obviously NULL if nothing being carried).\n   -mw: If the monster is wielding a weapon, here it is.\n   -misc_worn_check: Some obscure value for the worms code (?).\n   -weapon_check: Flag to check if monster has to get a weapon.\n   -mnamelth: Length of this monster PROPER name.\n   -mxlth: Length of the 'extra' part of the struct. It differs from monster\n    to monster. Most have any.\n   -meating: Monster is eating timeout.\n   -mextra: Allows access to the 'extra' part of the struct. Profusely used\n    with shopkeepers, for example.\n\n   \n   Uffff! I'm sure you're impressed with this big struct. Don't worry, you\n   don't have to deal with all the fields, at least at the beginning.\n\n   First thing you should have to do is answer this question: Does this monster\n   need any object or special ability not reflected in the M-FLAGS? If the \n   answer is yes, edit the file makemon.c and look for the 'm_initweap' \n   function.\n\n   (NOTE to UNIX users:\n\n   A few tools become invaluable in the process of looking for functions:\n\n     The 'ctags' command allows to create an index for objects; run the line\n\n\t\tctags *.c          (in the src directory)\n\n     this will create a 'tags' file. After that the command 'vi -t m_initweap'\n     will take you directly to the implementation of m_initweap function.\n\n     Also, the 'grep' command allows searching for a string. I.e. Wants to\n     have a look in the chamaleon code? Start looking the output for\n    \t\t grep -i chamaleon | more\n\n   End of NOTE)\n\n\n   The m_initweap function is where the monster gets the objects it needs. A\n   huge switch statement  (switch (mtmp->data->mlet) ) specify what it gets\n   according to its type. This is done with the 'mongets' function. (See\n   Apendix A for a complete listing of nearly 100 useful functions). \n\n   The easiest thing to do is search for a monster similar than ours and\n   copy the code. That way shouldn't be difficult to add a known object to\n   our monster. Note the usage of rn2() function to randomize the monsters\n   armors & weapon.\n\n   Really interesting monsters will have its own armor/weapon/object or type\n   of attack (if not, you will just get variations of standard monsters:\n   tougher newts, wimpy dragons, etc...). For adding a new object have a look\n   in the next section; Now we will see how to add new attacks or behaviours:\n\n\n   7.1. Adding a new attack type.\n\n   Edit the monattk.h file. Go after AT_TENT definition (in standard 3.1.3)\n   and add a line with something like:\n\n       #define AT_HELLO    16    /* Tries to kill you saying Hello */\n\n   This will be your new attack type. Now you have to define a new damage:\n   Put this line after the AD_FAMN definition:\n\n       #define AD_HELLO\t   39    /* You're saluted */\n\n\n   Now go to the src directory and edit the mhitu.c (monster-hits-user) file.\n   Inside the hitmsg() function you should add the code for your AT_HELLO\n   attack type. I.e: just add a line after \n\n                case AT_EXPL:\n                        pline(\"%s explodes!\", Monnam(mtmp));\n                        break;\n\n   like:\n\n                case AT_HELLO:\n                        pline(\"%s says hello to you!\", Monnam(mtmp));\n                        break;\n\n   Here we are introducing one of the most used function: pline() to show a\n   message to the screen (see apendix A for more information).\n\n   Later on look for the mattacku() function. You will have to add more code\n   for your AT_HELLO attack inside the 'switch(mattk->aatyp)'. Easiest is to\n   add a case to the 'hand to hand' attacks.\n\n   Now look for hitmu() function. There we have to add the code for AD_HELLO.\n   I.e., after \n\n            case AD_FAMN:\n                pline(\"%s reaches out, and your body shrivels.\",\n                        Monnam(mtmp));\n                exercise(A_CON, FALSE);\n                morehungry(rn1(40,40));\n                /* plus the normal damage */\n                break;\n\n   add\n\n            case AD_HELLO:\n                hitmsg(mtmp, mattk);\n\t\tmake_confused(2,FALSE);\n\t\tbreak;\n\n   so this new attack confuses you, a la umber hulk gaze.\n\n   That finished the editing for the mhitu.c file. Now do the same with mhitm.c\n   (monster- hits-monster), so a monster can attack another one with AT_HELLO.\n\n\n   7.2. Adding new monster's abilities\n\n   Within this chapter the method to add an action for a monster it is \n   explained. For example, let's add the code so a monster can read a\n   remove curse scroll.\n\n   Edit the muse.c file and look for the #define MUSE_WAN_SPEED_MONSTER 7\n   line. Add a new posibility:\n\n\t#define MUSE_SCR_SCARE_MONSTER 8\n\n   After that, inside the find_misc function look for:\n\n                if(obj->otyp == WAN_POLYMORPH && !mtmp->cham\n                                && monstr[(monsndx(mtmp->data))] < 6) {\n                        m.misc = obj;\n                        m.has_misc = MUSE_WAN_POLYMORPH;\n                }\n\n   and add:\n                if(obj->otyp == SCR_REMOVE_CURSE) {\n                        m.misc =obj;\n                        m.has_misc = MUSE_SCR_REMOVE_CURSE;\n                        }  \n\n   Now a monster is able to detect a remove curse scroll as a potential action.\n   Inside use_misc() we'll add the code to execute that action:\n\n   After the lines\n\n        case MUSE_WAN_POLYMORPH:\n                mzapmsg(mtmp, otmp, TRUE);\n                otmp->spe--;\n                (void) newcham(mtmp, rndmonst());\n                if (oseen) makeknown(WAN_POLYMORPH);\n                return 2;\n\n   Add\n\n        case MUSE_SCR_REMOVE_CURSE:\n                {\n                register struct obj *obj;\n                mreadmsg(mtmp,otmp);\n                pline(\"%s feels than someone is helping %s.\",Monnam(mtmp),\n                                 mtmp->female?\"her\":\"him\");\n                if (!otmp->cursed) {\n                   for(obj=mtmp->minvent;obj;obj=obj->nobj)\n                      if (otmp->blessed || obj->owornmask ||\n                         (obj->otyp == LOADSTONE)) {\n                            if (mtmp->mconf) blessorcurse(obj,2);\n                            else uncurse(obj);\n                            }\n                }\n                if (oseen && !objects[SCR_REMOVE_CURSE].oc_name_known\n                     && !objects[SCR_REMOVE_CURSE].oc_uname)\n                     docall(otmp); /* not makeknown() */\n                m_useup(mtmp, otmp);\n                return 2;\n                }\n\n\n   7.3. Adding a 'mextra' struct.\n\n   Real interesting monster behaviour needs the definition of new variables\n   in the monst struct. For example, suppose you want to add the possibility\n   to pray to god to your new monster; good idea would be to have a timeout\n   so the monster cannot pray every two turns. So, we could just add a new\n   element to the 'struct monst' in monst.h:\n\n\t\tlong praytime;\n\n   but that way EVERY MONSTER will have that variable defined, allocating\n   four bytes although only our new monster will use it.\n\n   Instead of that define a new struct - best in your own new include file-:\n\n\tstruct onlymymonster {\n\t\tlong praytime;\n\t};\n\n   and in the monster's definition in monst.c put 'sizeof(struct onlymymonster)'\n   as the extension length field. To refer to your new variable use this\n   contruction:\n\n\t\t((struct onlymymonster *)&(mon)->mextra[0])->praytime\n\n\t\t     (where mon is a pointer to a monst struct)\n\n   To abbreviate such a beast, use a #define:\n\n\t#define MYMONSTER(mon)   ((struct onlymymonster *)&(mon)->mextra[0])\n\n   so we can use \n\n\tMYMONSTER(mon)->praytime\n\n   Refer to the eshk.h file for an example of using a mextra part. (the\n   code for the shopkeepers).\n\n\n8. Adding a new object\n----------------------\n\n   8.1 The 'objects' array.\n\n   In chapter 6 I introduced you the mons[] array. Now it's the turn of the\n   'objects' array. It is a collection of structs objclass, being composed\n   of these elements: (from objclass.h)\n\n   oc_name_idx: actual name of the object.\n   oc_descr_idx: How the object is described when unknown (not identified).\n   oc_uname: Description given by the user (via the Call command).\n   oc_name_known: If 1, means the actual name is always showed.\n   oc_merge: If 1, merge otherwise equal objects.\n   oc_uses_known: Full description should be given.\n   oc_magic: It is a magical object.\n   oc_charged: This object may have charges.\n   oc_unique: This object is unique (amulet of Yendor, etc...)\n   oc_nowish: The player cannot wish for it.\n   oc_big: Big object.\n   oc_dir: Is it directional? Can be:\n\t\t\t\t\t   NODIR\n\t\t\t\t\t   IMMEDIATE\n\t\t\t\t\t   RAY\n   oc_material: What is it made of? Can be one of:\n\n\t   LIQUID\tWAX\t\tVEGGY\tFLESH\tPAPER\n\t   CLOTH\tLEATHER\t\tWOOD\tBONE\tDRAGON_HIDE\n\t   IRON\t\tMETAL\t\tCOPPER\tSILVER\tGOLD\n\t   PLATINUM\tMITHRIL\t\tPLASTIC\tGLASS\tGEMSTONE\n\t   MINERAL\n\n   oc_oprop: Properties conveyed by this object, i.e.: FIRE_RES, ANTIMAGIC,\n     etc...\n\n   oc_class: object class, i.e. WEAPON_CLASS, FOOD_CLASS, etc...\n   oc_delay: Delay when using such an object.\n   oc_color: Color of the object: Can be \n           BLACK\tRED\t\tGREEN\t\tBROWN\n\t   BLUE\t\tMAGENTA\t\tCYAN\t\tGRAY\n\t   NO_COLOR\tORANGE_COLORED\tBRIGHT_GREEN\tYELLOW\n\t   BRIGHT_BLUE\tBRIGHT_MAGENTA\tBRIGHT_CYAN\tWHITE\n\n       but also take note of this (from color.h):\n\n\t\t#define HI_OBJ          MAGENTA\n\t\t#define HI_METAL        CYAN\n\t\t#define HI_COPPER       YELLOW\n\t\t#define HI_SILVER       GRAY\n\t\t#define HI_GOLD         YELLOW\n\t\t#define HI_LEATHER      BROWN\n\t\t#define HI_CLOTH        BROWN\n\t\t#define HI_ORGANIC      BROWN\n\t\t#define HI_WOOD         BROWN\n\t\t#define HI_PAPER        WHITE\n\t\t#define HI_GLASS        BRIGHT_CYAN\n\t\t#define HI_MINERAL      GRAY\n\t\t#define HI_ZAP          BRIGHT_BLUE\n\n   oc_prob: probability of the object. The total sum of same class objects \n     should be 100.\n   oc_weight: its weight.\n   oc_cost: Base cost in shops. Actual price depends on charisma & hawaiian \n     shirts.\n   oc_wsdam:\n   oc_wldam: max small/large monster damage.\n   oc_oc1:\n   oc_oc2: Flags setting the +- something to the object. Its behaviour depends\n     on the class: for a weapon oc1 is the 'to hit' bonus while oc2 is a\n     negative value; for an armor, oc1 is the enchantment level & oc2 is the\n     - (rusting, etc...); for a spellbook oc2 is the spell level.\n   oc_nutrition: food value.\n\n   But for convenience, several \"#defines\" have been made so adding a certain\n   class of object is more direct. i.e:\n\n#define WEAPON(name,app,kn,mg,bi,prob,wt,cost,sdam,ldam,hitbon,metal,color) OBJE\nCT( \\\n                OBJ(name,app), BITS(kn,mg,1,0,0,1,0,0,bi,0,metal), 0, \\\n                WEAPON_CLASS, prob, 0, \\\n                wt, cost, sdam, ldam, hitbon, 0, wt, color )\n\n   allows to add a new weapon with the WEAPON macro, that sets several default\n   values common for all weapons.\n\n   There are macros for almost everything: WEAPON, FOOD, ARMOR, RING, etc...\n   Just use the one adequate in your case, keeping in mind:\n\n      - Put all common class objects together.\n      - Check the probabilities for the class.\n      - Easiest way is -as usual- copy an existing object and modify it.\n\n   Here there are some examples of entries:\n\n      ARMOR(\"Merlin's helm\", \"sharp-pointed cap\", 0, 1, 0, POLYMORPH_CONTROL,\n         0, 1, 10, 50,10, 0, CLOTH, BRIGHT_BLUE)\n\n      ARMOR(\"sport t-shirt\", NULL, 1, 0, 0, 0, 0, 0, 5, 3,10, 0, CLOTH, BLUE)\n\n      TOOL(\"self-compatible personal computer\",NULL,1, 0, 0, 0, 0,80,  200,\n         PLASTIC, GR AY)\n\n      FOOD(\"hamburger\",            0, 1,  8, 0, VEGGY, 300, BROWN)\n\n\n   That's all for the objects[] array. Now, depending of the class some files\n   should be touched; but first, some general recomendations:\n\n   a) Don't put your object as the first or last of its class: there are TONS\n   of code in the form:\n\n\t\tif ( (object > FIRST_OF_CLASS_X )\n\t\t   && (object < LAST_OF_CLASS_X ) )  \n\t\t   {   \n\t\t\t/* Assume object is of class x */\n\t\t   }\n\t\t   else \n\t\t        /* Print some strange fatal error */\n\n   b) Start with easy objects. Even better: add the object and put no effect\n   for it ---> the warning/error messages will inform you of the correct place\n   to edit.\n    Later put all the complicated things you have in mind, but start it simple.\n\n   c) There are some general functions that can be applied to all classes.\n   i.e: special effects when eating an object, cancelling it, dipping it, etc.\n   Here is a few hints for adding that:\n\n   - cancel_item() function, in zap.c, specifies what to do when cancelling.\n   - dodip() in potion.c, for special effects when dipping an object.\n   - eatspecial() in eat.c.\n   - dropy() in do.c, when dropping an object (i.e: a crysknife).\n\n   \n   8.1. Adding a tool\n\n   Your new added tool should have an effect when a)pplying it. That's defined\n   in the doapply() function, inside the apply.c file.\n   There is a huge switch depending on the object type (switch(obj->otyp));\n   note that different objects are referenced with its name in upper case; that\n   constant is generated by the makedefs command (remember?) in the onames.h\n   file. \n\n   What a tool does when applying is defined in its 'case'; if simple the\n   code is directly put there, if not a 'use_<tool-name>' function is defined\n   above. Studying such functions is a very good exercise, as they provide\n   lots of useful functions.\n\n\n   8.2. Adding a wand\n\n   A wand must have extra code in two ocasions: engraving with it and \n   -obviously- zapping it.\n\n   In engrave.c file we found the doengrave() function. There you should add\n   the appropiate 'case' entry and the message or code for anything you want.\n   Note the differences between directional & no directional wands.\n\n   In zap.c you should edit different functions depending also in the direc-\n   tional capability of your wand:\n\n      non-directional     --------- >  function zapnodir()\n\n      directional         --------- >  function bhitm() (wand hits monster).\n                              |---- >  function bhito() (wand hits object).\n                              |---- >  function zapyourself() (you, silly).\n\n\n   In general adding a wand it is more difficult than any other object.\n   Better start with something else.\n\n\n   8.3. Adding a potion\n\n   In this case look in file potion.c, for this functions:\n\n   peffects():  Describes what happens when potion is quaffed.\n\n   potionhit(): Describes what happens when potion hits a monster.\n\n   potionbreathe(): Potion vapors effect.\n\n   Also you'd like to edit the dodip() function where some special effects\n   can be added for dipping cases.\n\n\n   8.4. Adding armor/weapon\n\n   Unless you want some special feature, there is nothing to do.\n\n   Good place for adding code is function dmgval() in weapon.c: it adds\n   special damage bonuses for a certain weapon hitting a certain monster.\n\n\n   8.5. Adding a ring\n\n   Functions to look for in this case:\n\n   - dosinkring() in do.c. That describes the effects when dropping a ring\n    in a sink.\n\n   - Ring_on() in do_wear.c  What happens when a ring is put on.\n\n   - Ring_off_or_gone() in do_wear.c  The opposite way.\n\n   - eatring() in eat.c  Polymorphed player eats a ring.\n\n\n   8.6. Adding an amulet \n   \n   Quite similar to rings. Edit the functions Amulet_on() & Amulet_off in\n   do_wear.c\n\n\n   8.7. Adding a spellbook \n\n   First, in spell.c edit two functions:\n\n   study_book(): for learning a spell.\n   spelleffects(): for casting a spell.\n\n   As many spells behave like wands you may also have to edit the functions\n   bhitm(), bhito() & zapyourself() in zap.c, a la wand class.\n\n\n   8.8. Adding food\n\n   Just two functions here, both in eat.c\n\n   fprefx(): called when first bite of food.\n   fpostfx(): called when consumed food.\n\n   You should at least add the 'case' lines for the default behaviour.\n\n\n9. Creating a new room type\n---------------------------\n\n   To explain how to create a new room type, I will use an example: a clinic,\n   that is, a room full of nurses.\n\n   First of all, go to the include directory and edit the mkroom.h file. After\n   the line\n\t\t#define TEMPLE 10\n   add\n\t\t#define CLINIC 11\n\n   Look than then you'll have to increment the SHOPBASE & subsequents defines\n   to reflect the change, so MAXRTYPE becomes 22.\n\n   Now edit the rm.h file and after\n\t\tBitfield(is_cavernous_lev,1);\n\n   add\n\t\tBitfield(has_clinic,1);\n\n   so we can add a special message (for example an ambulance like sound) when\n   being in a level that has a clinic.\n\n   That's all for the include files. Go to the src directory and edit mkroom.c\n   Look for the mkroom() function and after the line\n\t\tcase BARRACKS:  mkzoo(BARRACKS); break;\n\n   add\n\t\tcase CLINIC:     mkzoo(CLINIC); break;\n\n   Take note that we are just adding a new non-shop room type, because the\n   previous mkshop() call if (roomtype >= SHOPBASE). We could define a \n   complete 'mkclinic()' function (see for example mktemple) but it is quite\n   simpler to use the mkzoo() code. That function will create a room and \n   fill it -function fill_zoo- with the appropiate monsters.\n\n   After that, we should edit the mkshop() function. Why? because in wizard\n   mode we could specify a room type to be created using the environment\n   variable SHOPTYPE. For example, if SHOPTYPE='G' starting nethack will\n   create a general shop in first level, 'Z' will create a zoo, etc... It is\n   not necessary, but certainly a good idea to add a new SHOPTYPE for our\n   new room, so we can test it quickly.\n\n   So, after \n\t\t\tif(*ep == 't' || *ep == 'T' || *ep == '\\\\'){\n                                mkzoo(COURT);\n                                return;\n                        }\n\n   put the following:\n\n                        if(*ep == 'c' || *ep == 'C'){\n                                mkzoo(CLINIC);\n                                return;\n                        }\n\n   Now go for the fill_zoo() itself. After\n\n\t        case ZOO:\n\t            goldlim = 500 * level_difficulty();\n\t\t    break;\n\n   just add\n\t\tcase CLINIC\n\t\t    break;\n\n   Now we have to select the monster to be created in our room. After\n\n  \t#ifdef ARMY\n                    \t(type == BARRACKS) ? squadmon() :\n\t#endif \n\n   Add\n\t\t\t(type == CLINIC) ? &mons[PM_NURSE]:\n\n   That is, if room type is CLINIC, monster to be created is a nurse. Several\n   things to note here: you can add a more complex function -see for example,\n   the courtmon() function- to select several monsters; also look how the\n   central point of the room is selected in other cases to create a special\n   monster -for example a queen bee in a beehive-.\n\n   If you want to add objects to the room, several lines after, you'll see:\n\n                    case BARRACKS:\n                        if(!rn2(20))    /* the payroll and some loot */\n                            (void) mksobj_at((rn2(3)) ? LARGE_BOX : CHEST,\n                                             sx, sy, TRUE);\n                        break;\n\n   That is, 1 in 20 make a large box or a chest. We could put something like:\n\n\t\t    case CLINIC:\n\t\t\tif(!rn2(10))\n\t\t\t    (void) mksobj_at(ICE_BOX,sx,sy,TRUE);\n\t\t\tbreak;\n\n   To create random ice boxes. It doesn't have to be a container, can be any\n   object you like.\n\n   Finally add a flag indicating that the level has a clinic:\n\n              case CLINIC:\n                  level.flags.has_clinic = 1;\n                  break;\n\n   You could now recompile and try out your new room using the SHOPTYPE \n   variable, but it will never generated in a normal dungeon. For that, we\n   have to edit mklev.c\n\n   First, at the beginning of the clear_level_structures() function add the\n   line:\n\t\tlevel.flags.has_clinic = 0;\n\n   so the flag is reset.\n\n   Later, look for the code:\n\n        if(depth(&u.uz) > 1 &&\n           depth(&u.uz) < depth(&medusa_level) &&\n           rn2(depth(&u.uz)) < 3) mkroom(SHOPBASE);\n        else if(depth(&u.uz) > 4 && !rn2(6)) mkroom(COURT);\n        else if(depth(&u.uz) > 6 && !rn2(7)) mkroom(ZOO);\n        else if(depth(&u.uz) > 8 && !rn2(5)) mkroom(TEMPLE);\n        else if(depth(&u.uz) > 9 && !rn2(5) &&\n           !(mons[PM_KILLER_BEE].geno & (G_GENOD | G_EXTINCT))) mkroom(BEEHIVE);\n        else if(depth(&u.uz) > 11 && !rn2(6)) mkroom(MORGUE);\n        else\n\n   As you can see, here is where is defined when a certain room can be genera-\n   ted: i.e. zoo's after level 6 one in 7 times, etc... So adding a line like\n   \n        if (depth(&u.uz) > 10 && !rn2(4)) mkroom(CLINIC)\n\n   will generate a clinic quite frecuently over dungeon level 10.\n\n\n   Next, edit the sounds.c file. Look for dosounds() and after\n\n\t#ifdef ARMY\n\t    if (level.flags.has_barracks && !rn2(200)) {\n\t\tstatic const char *barracks_msg[4] = {\n\t\t\t\"hear blades being honed.\",\n\t\t\t\"hear loud snoring.\",\n\t\t\t\"hear dice being thrown.\",\n\t\t\t\"hear General MacArthur!\",\n\t\t};\n\t\tYou(barracks_msg[rn2(3)+hallu]);\n\t\treturn;\n\t    }\n\t#endif /* ARMY */\n\n   add\n\t#ifdef CLINIC\n\t    if (level.flags.has_hospital && !rn2(200)) {\n\t\tstatic const char *hospital_msg[4] = {\n\t\t\t\"hear something about streptococus.\",\n\t\t\t\"smell chloroform nearby.\",\n\t\t\t\"hear someone cursing viruses.\",\n\t\t\t\"seem to hear Doctor Frankenstein.\",\n\t\t};\n\t\tYou(hospital_msg[rn2(3)+hallu]);\n\t\treturn;\n\t    }\n\t#endif /* CLINIC */\n\n   so we get a funny message randomly when having a clinic in level.\n\n   Last, edit hack.c and see check_special_room(), to add a salute to the\n   player entering a clinic:\n\n\t        case CLINIC:\n                    You(\"enter a modern hospital.\");\n                    break;\n\n   Also after\n\t#ifdef ARMY\n                            case BARRACKS:\n                                level.flags.has_barracks = 0;\n                                break;\n\t#endif\n\n   add\n\t#ifdef CLINIC\n                            case CLINIC:\n                                level.flags.has_clinic = 0;\n                                break;\n\t#endif\n\n   Last of all, edit sp_lev.c and after\n\t#ifdef ARMY\n\t\t    case BARRACKS:\n\t\t\tlevel.flags.has_barracks = TRUE;\n\t\t\tbreak;\n\t#endif\n   add\n\t#ifdef CLINIC\n\t\t    case CLINIC:\n\t\t\tlevel.flags.has_clinic = TRUE;\n\t\t\tbreak;\n\t#endif\n\n   inside the fill_room() function.\n\n   Recompile your code. Congratulations. You just added a new room.\n\n\n10. Creating a new shop type\n----------------------------\n\n   Along this chapter we will work to add a 'pet shop' as an example.\n\n   Adding a new shop is similar to adding a new room: we have to start with\n   the mkroom.h file. After the\n\t\n\t\t#define BOOKSHOP 20\n\n   line add \n\t\t#define PETSHOP 21\n\n   and increase the numbers for UNIQUESHOP, CANDLESHOP & MAXRTYPE. (of course\n   if you already added other rooms in chapter 9 put the correct number\n   accordingly).\n\n   Now edit the file shknam.c, where most of the shop code is located. First\n   thing you'll note is several 'static const char *shksomething[]' arrays;\n   those are the shopkeeper names for each type of shop. So, after the \n   definition of shkgeneral[], add a new array with the names for our petshops:\n\n   static const char *shkpetshop[] = {\n\t   \"Valoo\",\"Tisney\",\"Jakuna\",\n\t   \"\"\n\t   };\n\n   Note the array ends with a \"\" string. Also you should put more than 3 names,\n   but for our example is enough.\n\n   Later on the 'const struct shclass shtypes[]' array is defined. It sets\n   the shop types, with these fields:\n\n   - Name of the shop (i.e:\"general store\").\n   \n   - Letter that identifies this type of shop. (i.e: SCROLL_CLASS). It is\n    later used for the SHOPTYPE environment variable in wizard mode.\n\n   - % probability. Note that the total of all types should be 100, so for\n   adding a new one you'll have to low the probability of other(s).\n\n   - Object placement type:\n\t\tD_SCATTER = normal placement.\n\t\tD_SHOP    = shop-like placement.\n\t\tD_TEMPLE  = temple-like placement.\n\n   - Objects sold there, prefixed with the probability of each. i.e:\n\t {{85, RING_CLASS}, {10, GEM_CLASS}, {5, AMULET_CLASS}, {0, 0}}\n\n      means: rings (85% stock), gems(10%), amulets(5%). Note the NULL pair\n      at the end.\n      Also if defining a concrete object (instead of a class) a minus sign\n      is needed, as in:\n\t {{90, WAND_CLASS}, {5, -LEATHER_GLOVES}, {5, -ELVEN_CLOAK}, {0, 0}}\n\n      Note also that the array is defined (in mkroom.h) as 5 elements long,\n      so a shop cannot stock more than 5 classes/concrete objects. (You can\n      always increase that value as an alternative, of course).\n\n   - Names array -the shksomething array-.\n\n   So, in our case put something like:\n\n   {\"pet shop\", VENOM_CLASS, 5, D_SHOP,\n\t{{70, -FIGURINE},{20,-TRIPE_RATION},{10,-LEASH}}, shkpetshop}\n\n   meaning: create FIGURINES 70% of the time, 20% tripe rations & 10% leash.\n   Also this shop will be created if setting SHOPTYPE=\".\" or 5% of the time\n   a shop is created. The probability of the general store should be changed\n   from 44 to 39.\n\n   And that's all. Easy, isn't it?.\n\n   Just recompile the code and check it out setting:\n\n   export SHOPTYPE=.   (or set SHOPTYPE=. depending in your OS, or unix SHELL).\n   nethack -u wizard -D\n\n\n11. Goodbye\n-----------\n\n   Hundreds of other things can be added to the game, but this is the end;\n   from here you're on your own. I hope you found this reading useful. Just \n   some last recommendations:\n\n      1. Put lots of comments in your code. From experience, in a week or two\n        you'll forget why something was that way or the other.\n\n      2. Interchange information about new ideas in rec.games.roguelike.nethack\n        newsgroup. They can help you to refine your ideas or coming up with\n        new ones.\n\n      3. Send your modifications to the dev team (at the mail address \n        nethack-bugs@linc.cis.upenn.edu). You can possible win inmortality.\n\n      4. Play nethack a lot.\n\n\n   Good luck and happy hacking!!\n\n\n\n\t\t-------------------------------------\n\t\tApendix A. REFERENCE FUNCTION LISTING\n\t\t-------------------------------------\n\n   For your convenience here go some interesting functions: \n\nMonster naming functions\n------------------------\n\t\tThey all take a pointer to a monst structure as parameter and \n\t\treturn a string:\n\nchar *mon_nam(struct monst *)\n                the rust monster  it  the invisible orc  Fido\nchar *l_monnam(struct monst *)\n\t\trust monster    it  invisible orc      dog called fido\nchar *Monnam(struct monst *)\n\t\tThe rust monster    It  The invisible orc  Fido\nchar *Adjmonnam(struct monst *)\n\t\tThe poor rust monster  It  The poor invisible orc The poor Fido\nchar *Amonnam(struct monst *)\n\t\tA rust monster      It  An invisible orc   Fido\nchar *a_monnam(struct monst *)\n\t\ta rust monster      it  an invisible orc   Fido\n\n\nObject naming functions\n-----------------------\n\nchar *xname(struct obj *)\n\t\t\"poisoned arrow\"\nchar *doname(struct obj *)\n\t\t\"poisoned +0 arrow\"\nchar *an(struct obj *)\n\t\t\"a poisoned arrow\"\nchar *An(struct obj *)\n\t\t\"A poisoned arrow\"\nchar *The(struct obj *)\n\t\t\"The poisoned arrow\"\nchar *the(struct obj *)\n\t\t\"the poisoned arrow\"\nchar *makeplural(char *) \n\t\tTakes a string an pluralizes it. It is quite smart, \n\t\tso the \"homunculus\" plural becomes \"humunculi\", etc...\nchar *makesingular(char *) \n\t\tJust the opposite.\n\n\nDisplay functions\n-----------------\n\t\t(Please refer to the doc/window.doc file for more information).\n\npline(char *, ...)\n\t\tTakes the same arguments as the standard printf() function,\n\t\tand displays the result in the screen. It is massively used\n\t\tthroughout the code.\nYou(char *, ...)\n\t\tA shorter way to display the \"You do something\" messages.\n\t\tpline(\"You sit\") is equivalent to You(\"sit\").\nYour(char *, ...)\n\t\tA shorter way to display the \"Your something\" messages.\n\t\tpline(\"Your hands glow\") is equivalent to Your(\"hands glow\").\nverbalize(char *, ...)\n\t\tIt also behaves as printf(), but displays the resulting string\n\t\tbetween \"\". It is used for sounds made by other monsters.\nimpossible(char *, ...)\n\t\tDisplay an error message with the \"impossible:\" before it.\n\n\nSeveral object related functions\n--------------------------------\n\nstruct obj *readobjnam(char *)\n\t\tIt creates an object from a string. Mainly used in the\n\t\twishing routines.\nint weight(obj)\n\t\tReturns the weight of an object. (not obvious: it can be\n\t\ta container).\nvoid docall(struct obj *)\n\t\tAsk the player to call an object.\nmakeknown(obj->otyp)\n\t\tIt's not a real function, just a macro. Marks an object type\n\t\tas identified.\nvoid curse(struct obj *)\n\t\tCurses an object.\nvoid uncurse(struct obj *)\n\t\tUncurses an object.\nvoid bless(struct obj *)\n\t\tBlesses an object.\nvoid unbless(struct obj *)\n\t\tUnblesses an object.\nvoid move_object(struct obj *,int,int)\n\t\tMove object to x,y position.\nvoid remove_object(struct obj *)\n\t\tRemove object.\nvoid place_object(struct obj *,int,int)\n\t\tPut object in x,y position.\nint bhito(struct obj *, struct obj *)\n\t\tObject was hit by the effect of wand indicated in second \n\t\tparameter.\nvoid cancel_item(struct obj *)\n\t\tObject has been hit by cancellation ray.\n\n\nSeveral monster related functions\n---------------------------------\nstruct monst *newmonst(struct permonst *)\n\t\tAllocs a new 'monst' struct. It doesn't add it to the chained\n\t\tlist of monsters. Tipically the process will be:\n\t\t\tmtmp = newmonst(ptr->pxlth);\n\t\t\t*mtmp = zeromonst; /* clear all entries in structure */\n\t\t\tmtmp->nmon = fmon;\n\t\t\tfmon = mtmp;\n\t\tShouldn't be used directly. Better use makemon().\nstruct monst *makemon(struct permonst, int, int)\n\t\tCreates a new monster in the position determined by the two\n\t\tother parameters (x,y). It returns the newly created monst\n\t\tstruct if success, NULL otherwise.\n\t\tThe first parameter can be null; in that case a random monster\n\t\twill be created.\n\t\tThe (x,y) position can also be 0 to indicate a random location.\nvoid relmon(struct monst *mon)\n\t\tRelease monster from display and monster list.\nboolean mnearto(struct monst *,xchar, xchar, boolean)\n\t\tPut monster near (or at) location if possible. The boolean\n\t\tparameter is for forcing another one to move. Returns \n\t\t1 - if a monster was moved from x, y to put mtmp at x, y\n\t\t0 - in most cases.\nstruct permonst *grow_up(struct monst *, struct monst *)\n\t\tMonster grows up to a bigger version. The last monst struct\n\t\tparameter is the victim, if any. If there is none it implies\n\t\ta gain level potion.\nvoid mongone(struct monst *)\n\t\tMonster dissapears. The struct is released.\nvoid setmangry(struct monst *)\n\t\tMonster gets angry. If already was it, does nothing.\nboolean angry_guards(register boolean)\n\t\tFunction used to angry guards in town. The parameter just indi-\n\t\tcate to display messages if true. Returns TRUE if any guard\n\t\twas there.\nvoid pacify_guards()\n\t\tThe name says it all.\nvoid wake_up(struct monst *)\n\t\tWake up -and angry- a monster.\nvoid wake_nearby()\n\t\tWake up nearby monsters.\nvoid mon_to_stone(struct monst *)\n\t\tChanges the monster into a stone monster of the same type.\nboolean monnear(struct monst *, x, y)\n\t\tIs the square close enough for the monster to move or \n\t\tattack into?\nint minwater(struct monst *)\n\t\tCheck monster and water for compatibility, 0 (survived), \n\t\t1 (drowned)\nint rndmonnum()\n\t\tSelect a random, common monster type.\nSounds functions\n----------------\n\nvoid dosounds()\n\t\tMake a sound, depending of what is in current level (shop,\n\t\tthrones, etc...)\nvoid growl(struct monst *)\n\t\tMonster is happy.\nvoid yelp(struct monst *)\n\t\tMonster is not so happy.\nvoid whimper(struct monst *)\n\t\tMonster is about to die.\nvoid beg(struct monst *)\n\t\tMonster begs for food.\nint domonnoise(struct monst *)\n\t\tDo whatever sound a monster does.\nint dotalk()\n\t\tThe #chat command.\n\n\t\t\nMonsters<->objects functions\n----------------------------\n\nint mongets(struct monst *, int)\n\t\tIt creates an object and gives it to a monster. The int is\n\t\tthe identifier of the object as defined in onames.h (created\n\t\tby makedefs). i.e. BLUE_DRAGON_SCALE_MAIL\nvoid m_useup(struct monst *, struct obj *)\n\t\tAn object is consumed by a monster. The obj struct is freed.\nvoid mpickobj(struct monst *, struct obj *)\n\t\tAn object is picked by a monster.\nvoid mpickgems(struct monst *)\n\t\tA monster picks up the gems under him.\nvoid mpickgold(struct monst *)\n\t\tA monster picks up the gold under him.\nvoid mpickstuff(struct monst *)\n\t\tA monster picks up things under him. What it takes it depend\n\t\ton the M-FLAGS defined for this type of monster.\nvoid meatobj(struct monst *)\n\t\tMonster eats whatever in his position. Used for gelatinous\n\t\tcubes.\nvoid meatgold(struct monst *)\n\t\tA expensive meal :-)\nboolean can_carry(struct monst *, struct obj *)\n\t\tReturns TRUE if the monster can carry that object\nstruct obj *make_corpse(struct monst *)\n\t\tCreates a monster corpse, a \"special\" corpse, or nothing \n\t\tif it doesn't leave corpses.\n\nShop related functions\n----------------------\n\nstruct monst *shop_keeper(char rmno)\n\t\tReturns the shopkeeper given the room number. Example of usage:\n\t\t\tstruct monst *shkp;\n\t\t\tshkp=shop_keeper(*in_rooms(u.ux,u.uy,SHOPBASE));\nint inhishop(struct monst *)\n\t\tReturns true if shopkeeper is in his shop.\nvoid mkshobj_at(const struct shclass *,int,int)\n\t\tMake an object of the appropriate type in a shop square.\nint shkinit(const struct shclass *,struct mkroom *sroom)\n\t\tCreate a new shopkeeper in the given room.\nboolean saleable(int,struct obj *)\n\t\tReturns TRUE if the shop -indicated by the index - stocks that\n\t\ttype of objects.\n\nOther interesting functions\n---------------------------\n\nint rn2(int x)\n\t\tReturns a random number between 0 & x.\n\t\t( 0 <= rn2(x) < x )\nint rnl(int x)\n\t\tReturns a random number between 0 & x, just as rn2(), but\n\t\tthis time the player's luck affects the result: good luck\n\t\tapproaches 0, bad luck approaches x-1.\nchar *getrumor(int)\n\t\tReturns a \"rumor\" string. if int = 1 rumor is always true,\n\t\t-1 means false and 0 is random.\nvoid exercise(int, boolean)\n\t\tExercise an attribute (A_INT,A_CHA,A_WIS,A_STR,A_DEX). If\n\t\tTRUE increases, FALSE decreases.\nfind_misc() \nuse_misc()\n\t\tBoth functions are used in muse.c to detect an object/action\n\t\tthat a monster can do and execute it.\nvoid mkroom(int)\n\t\tMake and stock a room of a given type.\nboolean has_dnstairs(struct mkroom *)\n\t\tReturns true if room has downstairs.\nboolean has_upstairs(struct mkroom *)\n\t\tReturns true if room has upstairs.\nschar depth(d_level)\n\t\tReturns the depth of a level, in floors below the surface.\n\t\t(note levels in different dungeons can have the same depth).\ndoengrave()\n\t\tUser engraves.\nint bhitm(struct monst *, struct obj *)\n\t\tMonster was hit by the effect of wand or spell indicated\n\t\tin second parameter.\nint zapyourself(struct obj *)\n\t\tThe name says it all: player zapped himself with wand or spell.\nvoid zapnodir(struct obj *)\n\t\tZapping a non-directional wand.\nint breaks(struct obj *, boolean)\n\t\tObject breaks. The boolean flag indicates if object is or not\n\t\tin the fobj chain.\nint peffects(struct obj *)\n\t\tFunction for potion quaffing effects.\nvoid potionhit(struct monst *, struct obj *)\n\t\tPotion hits monster.\nvoid potionbreathe(struct obj *)\n\t\tVapors effects.\nvoid dosinkring(struct obj *)\n\t\tRing is dropped in a sink.\nvoid eatring(struct obj *)\n\t\tPolymorphed player eats a ring.\nvoid Ring_on(struct obj *)\n\t\tRing effects when on.\nvoid Ring_off_or_gone(struct obj *,boolean)\n\t\tRing is removed. The boolean flag indicates if gone (stolen).\nvoid Amulet_on()\nvoid Amulet_off()\n\t\tSimilar idea, but for amulets.\nvoid fprefx(struct obj *)\n\t\tCalled at first bite on food.\nvoid fpostfx(struct obj *)\n\t\tCalled after last bite on food.\nint study_book(struct obj *)\n\t\tStudy a spellbook.\nint spelleffects(struct obj *, boolean)\n\t\tCast a spell. boolean flag indicates if at player himself.\n</pre>\n\n{{basedon|name=German Martin|url=http://web.archive.org/web/20160802031704/http://members.shaw.ca/rob.ellwood/sources.txt}}\n{{noversion}}"}